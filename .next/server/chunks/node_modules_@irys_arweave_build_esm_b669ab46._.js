module.exports = {

"[project]/node_modules/@irys/arweave/build/esm/common/lib/crypto/pem.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// @ts-expect-error no typing :c
__turbopack_context__.s({
    "RSA_OID": ()=>RSA_OID,
    "jwkTopem": ()=>jwkTopem,
    "pemTojwk": ()=>pemTojwk
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$asn1$2e$js$2f$lib$2f$asn1$2f$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/asn1.js/lib/asn1/api.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bn$2e$js$2f$lib$2f$bn$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bn.js/lib/bn.js [app-route] (ecmascript)");
;
const define = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$asn1$2e$js$2f$lib$2f$asn1$2f$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].define;
;
function urlize(base64) {
    return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hex2b64url(str) {
    return urlize(Buffer.from(str, "hex").toString("base64"));
}
const RSAPublicKey = define("RSAPublicKey", function() {
    this.seq().obj(this.key("n").int(), this.key("e").int());
});
const AlgorithmIdentifier = define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional().any());
});
const PublicKeyInfo = define("PublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("publicKey").bitstr());
});
const Version = define("Version", function() {
    this.int({
        0: "two-prime",
        1: "multi"
    });
});
const OtherPrimeInfos = define("OtherPrimeInfos", function() {
    this.seq().obj(this.key("ri").int(), this.key("di").int(), this.key("ti").int());
});
const RSAPrivateKey = define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").use(Version), this.key("n").int(), this.key("e").int(), this.key("d").int(), this.key("p").int(), this.key("q").int(), this.key("dp").int(), this.key("dq").int(), this.key("qi").int(), this.key("other").optional().use(OtherPrimeInfos));
});
const PrivateKeyInfo = define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").use(Version), this.key("algorithm").use(AlgorithmIdentifier), this.key("privateKey").bitstr());
});
const RSA_OID = "1.2.840.113549.1.1.1";
function addExtras(obj, extras) {
    extras = extras || {};
    Object.keys(extras).forEach(function(key) {
        obj[key] = extras[key];
    });
    return obj;
}
function pad(hex) {
    return hex.length % 2 === 1 ? "0" + hex : hex;
}
function decodeRsaPublic(buffer, extras) {
    const key = RSAPublicKey.decode(buffer, "der");
    const e = pad(key.e.toString(16));
    const jwk = {
        kty: "RSA",
        n: bn2base64url(key.n),
        e: hex2b64url(e)
    };
    return addExtras(jwk, extras);
}
function decodeRsaPrivate(buffer, extras) {
    const key = RSAPrivateKey.decode(buffer, "der");
    const e = pad(key.e.toString(16));
    const jwk = {
        kty: "RSA",
        n: bn2base64url(key.n),
        e: hex2b64url(e),
        d: bn2base64url(key.d),
        p: bn2base64url(key.p),
        q: bn2base64url(key.q),
        dp: bn2base64url(key.dp),
        dq: bn2base64url(key.dq),
        qi: bn2base64url(key.qi)
    };
    return addExtras(jwk, extras);
}
function decodePublic(buffer, extras) {
    const info = PublicKeyInfo.decode(buffer, "der");
    return decodeRsaPublic(info.publicKey.data, extras);
}
function decodePrivate(buffer, extras) {
    const info = PrivateKeyInfo.decode(buffer, "der");
    return decodeRsaPrivate(info.privateKey.data, extras);
}
function getDecoder(header) {
    const match = /^-----BEGIN (RSA )?(PUBLIC|PRIVATE) KEY-----$/.exec(header);
    if (!match) {
        return null;
    }
    const isRSA = !!match[1];
    const isPrivate = match[2] === "PRIVATE";
    if (isPrivate) {
        return isRSA ? decodeRsaPrivate : decodePrivate;
    } else {
        return isRSA ? decodeRsaPublic : decodePublic;
    }
}
function parse(jwk) {
    return {
        n: string2bn(jwk.n),
        e: string2bn(jwk.e),
        d: jwk.d && string2bn(jwk.d),
        p: jwk.p && string2bn(jwk.p),
        q: jwk.q && string2bn(jwk.q),
        dp: jwk.dp && string2bn(jwk.dp),
        dq: jwk.dq && string2bn(jwk.dq),
        qi: jwk.qi && string2bn(jwk.qi)
    };
}
function bn2base64url(bn) {
    return hex2b64url(pad(bn.toString(16)));
}
function base64url2bn(str) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bn$2e$js$2f$lib$2f$bn$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](Buffer.from(str, "base64"));
}
function string2bn(str) {
    if (/^[0-9]+$/.test(str)) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bn$2e$js$2f$lib$2f$bn$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](str, 10);
    }
    return base64url2bn(str);
}
function pemTojwk(pem, extras) {
    let text = pem.toString().split(/(\r\n|\r|\n)+/g);
    text = text.filter(function(line) {
        return line.trim().length !== 0;
    });
    const decoder = getDecoder(text[0]);
    text = text.slice(1, -1).join("");
    return decoder(Buffer.from(text.replace(/[^\w\d\+\/=]+/g, ""), "base64"), extras);
}
function jwkTopem(json) {
    const jwk = parse(json);
    const isPrivate = !!jwk.d;
    const t = isPrivate ? "PRIVATE" : "PUBLIC";
    const header = "-----BEGIN RSA " + t + " KEY-----\n";
    const footer = "\n-----END RSA " + t + " KEY-----\n";
    let data = Buffer.alloc(0);
    if (isPrivate) {
        jwk.version = "two-prime";
        data = RSAPrivateKey.encode(jwk, "der");
    } else {
        data = RSAPublicKey.encode(jwk, "der");
    }
    const body = data.toString("base64").match(/.{1,64}/g).join("\n");
    return header + body + footer;
} //# sourceMappingURL=pem.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/node/node-driver.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "NodeCryptoDriver": ()=>NodeCryptoDriver,
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$crypto$2f$pem$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/crypto/pem.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
;
;
class NodeCryptoDriver {
    keyLength = 4096;
    publicExponent = 0x10001;
    hashAlgorithm = "sha256";
    encryptionAlgorithm = "aes-256-cbc";
    generateJWK() {
        if (typeof __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["generateKeyPair"] !== "function") {
            throw new Error("Keypair generation not supported in this version of Node, only supported in versions 10+");
        }
        return new Promise((resolve, reject)=>{
            __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["generateKeyPair"]("rsa", {
                modulusLength: this.keyLength,
                publicExponent: this.publicExponent,
                privateKeyEncoding: {
                    type: "pkcs1",
                    format: "pem"
                },
                publicKeyEncoding: {
                    type: "pkcs1",
                    format: "pem"
                }
            }, (err, _publicKey, privateKey)=>{
                if (err) {
                    reject(err);
                }
                resolve(this.pemToJWK(privateKey));
            });
        });
    }
    sign(jwk, data, { saltLength } = {}) {
        return new Promise((resolve)=>{
            resolve(__TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["createSign"](this.hashAlgorithm).update(data).sign({
                key: this.jwkToPem(jwk),
                padding: __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["constants"].RSA_PKCS1_PSS_PADDING,
                saltLength
            }));
        });
    }
    verify(publicModulus, data, signature) {
        return new Promise((resolve)=>{
            const publicKey = {
                kty: "RSA",
                e: "AQAB",
                n: publicModulus
            };
            const pem = this.jwkToPem(publicKey);
            resolve(__TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["createVerify"](this.hashAlgorithm).update(data).verify({
                key: pem,
                padding: __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["constants"].RSA_PKCS1_PSS_PADDING
            }, signature));
        });
    }
    hash(data, algorithm = "SHA-256") {
        return new Promise((resolve)=>{
            resolve(__TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["createHash"](this.parseHashAlgorithm(algorithm)).update(data).digest());
        });
    }
    /**
     * If a key is passed as a buffer it *must* be exactly 32 bytes.
     * If a key is passed as a string then any length may be used.
     *
     * @param {Buffer} data
     * @param {(string | Buffer)} key
     * @returns {Promise<Uint8Array>}
     */ async encrypt(data, key, salt) {
        // create a random string for deriving the key
        // const salt = crypto.randomBytes(16);
        // console.log(salt);
        // As we're using CBC with a randomised IV per cypher we don't really need
        // an additional random salt per passphrase.
        const derivedKey = __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["pbkdf2Sync"](key, salt = salt ? salt : "salt", 100000, 32, this.hashAlgorithm);
        const iv = __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["randomBytes"](16);
        const cipher = __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["createCipheriv"](this.encryptionAlgorithm, derivedKey, iv);
        const encrypted = Buffer.concat([
            iv,
            cipher.update(data),
            cipher.final()
        ]);
        return encrypted;
    }
    /**
     * If a key is passed as a buffer it *must* be exactly 32 bytes.
     * If a key is passed as a string then any length may be used.
     *
     * @param {Buffer} encrypted
     * @param {(string | Buffer)} key
     * @returns {Promise<Uint8Array>}
     */ async decrypt(encrypted, key, salt) {
        try {
            // create a random string for deriving the key
            // const salt = crypto.randomBytes(16).toString('hex');
            // As we're using CBC with a randomised IV per cypher we don't really need
            // an additional random salt per passphrase.
            const derivedKey = __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["pbkdf2Sync"](key, salt = salt ? salt : "salt", 100000, 32, this.hashAlgorithm);
            const iv = encrypted.slice(0, 16);
            const data = encrypted.slice(16);
            const decipher = __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["createDecipheriv"](this.encryptionAlgorithm, derivedKey, iv);
            const decrypted = Buffer.concat([
                decipher.update(data),
                decipher.final()
            ]);
            return decrypted;
        } catch (error) {
            throw new Error("Failed to decrypt");
        }
    }
    jwkToPem(jwk) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$crypto$2f$pem$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["jwkTopem"])(jwk);
    }
    pemToJWK(pem) {
        const jwk = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$crypto$2f$pem$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["pemTojwk"])(pem);
        return jwk;
    }
    parseHashAlgorithm(algorithm) {
        switch(algorithm){
            case "SHA-256":
                return "sha256";
            case "SHA-384":
                return "sha384";
            default:
                throw new Error(`Algorithm not supported: ${algorithm}`);
        }
    }
}
const __TURBOPACK__default__export__ = NodeCryptoDriver;
 //# sourceMappingURL=node-driver.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/common/lib/utils.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "arToWinston": ()=>arToWinston,
    "b64UrlDecode": ()=>b64UrlDecode,
    "b64UrlEncode": ()=>b64UrlEncode,
    "b64UrlToBuffer": ()=>b64UrlToBuffer,
    "b64UrlToString": ()=>b64UrlToString,
    "bufferToString": ()=>bufferToString,
    "bufferTob64": ()=>bufferTob64,
    "bufferTob64Url": ()=>bufferTob64Url,
    "concatBuffers": ()=>concatBuffers,
    "stringToB64Url": ()=>stringToB64Url,
    "stringToBuffer": ()=>stringToBuffer,
    "winstonToAr": ()=>winstonToAr
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64$2d$js$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/base64-js/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bignumber.js/bignumber.mjs [app-route] (ecmascript)");
;
;
function concatBuffers(buffers) {
    let totalLength = 0;
    for (const b of buffers)totalLength += b.byteLength;
    const temp = new Uint8Array(totalLength);
    let offset = 0;
    temp.set(new Uint8Array(buffers[0]), offset);
    offset += buffers[0].byteLength;
    for(let i = 1; i < buffers.length; i++){
        temp.set(new Uint8Array(buffers[i]), offset);
        offset += buffers[i].byteLength;
    }
    return temp;
}
function b64UrlToString(b64UrlString) {
    const buffer = b64UrlToBuffer(b64UrlString);
    return bufferToString(buffer);
}
function bufferToString(buffer) {
    return new TextDecoder("utf-8", {
        fatal: true
    }).decode(buffer);
}
function stringToBuffer(string) {
    return new TextEncoder().encode(string);
}
function stringToB64Url(string) {
    return bufferTob64Url(stringToBuffer(string));
}
function b64UrlToBuffer(b64UrlString) {
    return new Uint8Array((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64$2d$js$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["toByteArray"])(b64UrlDecode(b64UrlString)));
}
function bufferTob64(buffer) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64$2d$js$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fromByteArray"])(new Uint8Array(buffer));
}
function bufferTob64Url(buffer) {
    return b64UrlEncode(bufferTob64(buffer));
}
function b64UrlEncode(b64UrlString) {
    return b64UrlString.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
}
function b64UrlDecode(b64UrlString) {
    b64UrlString = b64UrlString.replace(/\-/g, "+").replace(/\_/g, "/");
    let padding;
    b64UrlString.length % 4 == 0 ? padding = 0 : padding = 4 - b64UrlString.length % 4;
    return b64UrlString.concat("=".repeat(padding));
}
function winstonToAr(winston) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](winston).shiftedBy(-12);
}
function arToWinston(ar) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](ar).shiftedBy(12);
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/common/lib/transaction.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/* eslint-disable no-case-declarations */ __turbopack_context__.s({
    "ArweaveTag": ()=>ArweaveTag,
    "default": ()=>Transaction
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/utils.js [app-route] (ecmascript)");
;
;
class BaseObject {
    get(field, options) {
        if (!Object.getOwnPropertyNames(this).includes(field)) {
            throw new Error(`Field "${field}" is not a property of the Arweave Transaction class.`);
        }
        // Handle fields that are Uint8Arrays.
        // To maintain compat we encode them to b64url
        // if decode option is not specificed.
        if (this[field] instanceof Uint8Array) {
            if (options && options.decode && options.string) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["bufferToString"](this[field]);
            }
            if (options && options.decode && !options.string) {
                return this[field];
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["bufferTob64Url"](this[field]);
        }
        if (this[field] instanceof Array) {
            if (options?.decode !== undefined || options?.string !== undefined) {
                if (field === "tags") {
                    console.warn(`Did you mean to use 'transaction["tags"]' ?`);
                }
                throw new Error(`Cannot decode or stringify an array.`);
            }
            return this[field];
        }
        if (options && options.decode == true) {
            if (options && options.string) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["b64UrlToString"](this[field]);
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["b64UrlToBuffer"](this[field]);
        }
        return this[field];
    }
}
class ArweaveTag extends BaseObject {
    name;
    value;
    constructor(name, value /* _decode = false */ ){
        super();
        this.name = name;
        this.value = value;
    }
}
class Transaction extends BaseObject {
    format = 2;
    id = "";
    last_tx = "";
    owner = "";
    tags = [];
    target = "";
    quantity = "0";
    data_size = "0";
    data = new Uint8Array();
    data_root = "";
    reward = "0";
    signature = "";
    merkle;
    deepHash;
    // Computed when needed.
    chunks;
    constructor({ attributes, deps }){
        super();
        this.merkle = deps.merkle;
        this.deepHash = deps.deepHash;
        Object.assign(this, attributes);
        // If something passes in a Tx that has been toJSON'ed and back,
        // or where the data was filled in from /tx/data endpoint.
        // data will be b64url encoded, so decode it.
        if (typeof this.data === "string") {
            this.data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["b64UrlToBuffer"](this.data);
        }
        if (attributes.tags) {
            this.tags = attributes.tags /* .map((tag: { name: string; value: string }) => {
              return new Tag(tag.name, tag.value);
            }) */ ;
        }
    }
    addTag(name, value) {
        this.tags.push({
            name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringToB64Url"](name),
            value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringToB64Url"](value)
        });
    }
    toJSON() {
        return {
            format: this.format,
            id: this.id,
            last_tx: this.last_tx,
            owner: this.owner,
            tags: this.tags,
            target: this.target,
            quantity: this.quantity,
            data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["bufferTob64Url"](this.data),
            data_size: this.data_size,
            data_root: this.data_root,
            data_tree: this.data_tree,
            reward: this.reward,
            signature: this.signature
        };
    }
    setOwner(owner) {
        this.owner = owner;
    }
    setSignature({ id, owner, reward, tags, signature }) {
        this.id = id;
        this.owner = owner;
        if (reward) this.reward = reward;
        if (tags) this.tags = tags;
        this.signature = signature;
    }
    async prepareChunks(data) {
        // Note: we *do not* use `this.data`, the caller may be
        // operating on a transaction with an zero length data field.
        // This function computes the chunks for the data passed in and
        // assigns the result to this transaction. It should not read the
        // data *from* this transaction.
        if (!this.chunks && data.byteLength > 0) {
            this.chunks = await this.merkle.generateTransactionChunks(data);
            this.data_root = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["bufferTob64Url"])(this.chunks.data_root);
        }
        if (!this.chunks && data.byteLength === 0) {
            this.chunks = {
                chunks: [],
                data_root: new Uint8Array(),
                proofs: []
            };
            this.data_root = "";
        }
    }
    // Returns a chunk in a format suitable for posting to /chunk.
    // Similar to `prepareChunks()` this does not operate `this.data`,
    // instead using the data passed in.
    getChunk(idx, data) {
        if (!this.chunks) {
            throw new Error(`Chunks have not been prepared`);
        }
        const proof = this.chunks.proofs[idx];
        const chunk = this.chunks.chunks[idx];
        return {
            data_root: this.data_root,
            data_size: this.data_size,
            data_path: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["bufferTob64Url"](proof.proof),
            offset: proof.offset.toString(),
            chunk: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["bufferTob64Url"](data.slice(chunk.minByteRange, chunk.maxByteRange))
        };
    }
    async getSignatureData() {
        switch(this.format){
            case 1:
                const tags = this.tags.reduce((accumulator, tag)=>{
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["concatBuffers"]([
                        accumulator,
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["b64UrlToBuffer"])(tag.name),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["b64UrlToBuffer"])(tag.value)
                    ]);
                }, new Uint8Array());
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["concatBuffers"]([
                    this.get("owner", {
                        decode: true,
                        string: false
                    }),
                    this.get("target", {
                        decode: true,
                        string: false
                    }),
                    this.get("data", {
                        decode: true,
                        string: false
                    }),
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringToBuffer"](this.quantity),
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringToBuffer"](this.reward),
                    this.get("last_tx", {
                        decode: true,
                        string: false
                    }),
                    tags
                ]);
            case 2:
                if (!this.data_root) {
                    await this.prepareChunks(this.data);
                }
                const tagList = this.tags.map((tag)=>[
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["b64UrlToBuffer"])(tag.name),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["b64UrlToBuffer"])(tag.value)
                    ]);
                return await this.deepHash.deepHash([
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringToBuffer"](this.format.toString()),
                    this.get("owner", {
                        decode: true,
                        string: false
                    }),
                    this.get("target", {
                        decode: true,
                        string: false
                    }),
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringToBuffer"](this.quantity),
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringToBuffer"](this.reward),
                    this.get("last_tx", {
                        decode: true,
                        string: false
                    }),
                    tagList,
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringToBuffer"](this.data_size),
                    this.get("data_root", {
                        decode: true,
                        string: false
                    })
                ]);
            default:
                throw new Error(`Unexpected transaction format: ${this.format}`);
        }
    }
} //# sourceMappingURL=transaction.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/common/lib/error.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>ArweaveError,
    "getError": ()=>getError
});
class ArweaveError extends Error {
    type;
    response;
    constructor(type, optional = {}){
        if (optional.message) {
            super(optional.message);
        } else {
            super();
        }
        this.type = type;
        this.response = optional.response;
    }
    getType() {
        return this.type;
    }
}
function getError(resp) {
    let data = resp.data;
    if (typeof resp.data === "string") {
        try {
            data = JSON.parse(resp.data);
        } catch (e) {}
    }
    if (resp.data instanceof ArrayBuffer || resp.data instanceof Uint8Array) {
        try {
            data = JSON.parse(data.toString());
        } catch (e) {}
    }
    return data ? data.error || data : resp.statusText || "unknown";
} //# sourceMappingURL=error.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/common/blocks.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/* eslint-disable @typescript-eslint/naming-convention */ __turbopack_context__.s({
    "default": ()=>Blocks
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$error$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/error.js [app-route] (ecmascript)");
;
class Blocks {
    api;
    network;
    constructor(api, network){
        this.api = api;
        this.network = network;
    }
    /**
     * Gets a block by its "indep_hash"
     */ async getByHash(indepHash) {
        const response = await this.api.get(`block/hash/${indepHash}`);
        if (response.status === 200) {
            return response.data;
        } else {
            if (response.status === 404) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$error$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]("BLOCK_NOT_FOUND" /* ArweaveErrorType.BLOCK_NOT_FOUND */ );
            } else {
                throw new Error(`Error while loading block data: ${response}`);
            }
        }
    }
    /**
     * Gets a block by its "indep_hash"
     */ async getByHeight(height) {
        const response = await this.api.get(`block/height/${height}`);
        if (response.status === 200) {
            return response.data;
        } else {
            if (response.status === 404) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$error$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]("BLOCK_NOT_FOUND" /* ArweaveErrorType.BLOCK_NOT_FOUND */ );
            } else {
                throw new Error(`Error while loading block data: ${response}`);
            }
        }
    }
    /**
     * Gets current block data (ie. block with indep_hash = Network.getInfo().current)
     */ async getCurrent() {
        const { current } = await this.network.getInfo();
        return await this.getByHash(current);
    }
} //# sourceMappingURL=blocks.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/common/lib/merkle.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @see {@link https://github.com/ArweaveTeam/arweave/blob/fbc381e0e36efffa45d13f2faa6199d3766edaa2/apps/arweave/src/ar_merkle.erl}
 */ __turbopack_context__.s({
    "MAX_CHUNK_SIZE": ()=>MAX_CHUNK_SIZE,
    "MIN_CHUNK_SIZE": ()=>MIN_CHUNK_SIZE,
    "Merkle": ()=>Merkle,
    "arrayCompare": ()=>arrayCompare,
    "arrayFlatten": ()=>arrayFlatten,
    "bufferToInt": ()=>bufferToInt,
    "default": ()=>__TURBOPACK__default__export__,
    "intToBuffer": ()=>intToBuffer
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$arweave$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/arweave.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/utils.js [app-route] (ecmascript)");
;
;
const MAX_CHUNK_SIZE = 256 * 1024;
const MIN_CHUNK_SIZE = 32 * 1024;
const NOTE_SIZE = 32;
const HASH_SIZE = 32;
class Merkle {
    crypto;
    constructor(opts){
        this.crypto = opts.deps.crypto;
    }
    /**
     * Takes the input data and chunks it into (mostly) equal sized chunks.
     * The last chunk will be a bit smaller as it contains the remainder
     * from the chunking process.
     */ async chunkData(data) {
        const chunks = [];
        let rest = data;
        let cursor = 0;
        while(rest.byteLength >= MAX_CHUNK_SIZE){
            let chunkSize = MAX_CHUNK_SIZE;
            // If the total bytes left will produce a chunk < MIN_CHUNK_SIZE,
            // then adjust the amount we put in this 2nd last chunk.
            const nextChunkSize = rest.byteLength - MAX_CHUNK_SIZE;
            if (nextChunkSize > 0 && nextChunkSize < MIN_CHUNK_SIZE) {
                chunkSize = Math.ceil(rest.byteLength / 2);
            // console.log(`Last chunk will be: ${nextChunkSize} which is below ${MIN_CHUNK_SIZE}, adjusting current to ${chunkSize} with ${rest.byteLength} left.`)
            }
            const chunk = rest.slice(0, chunkSize);
            const dataHash = await this.crypto.hash(chunk);
            cursor += chunk.byteLength;
            chunks.push({
                dataHash,
                minByteRange: cursor - chunk.byteLength,
                maxByteRange: cursor
            });
            rest = rest.slice(chunkSize);
        }
        chunks.push({
            dataHash: await this.crypto.hash(rest),
            minByteRange: cursor,
            maxByteRange: cursor + rest.byteLength
        });
        return chunks;
    }
    async generateLeaves(chunks) {
        return Promise.all(chunks.map(async ({ dataHash, minByteRange, maxByteRange })=>{
            return {
                type: "leaf",
                id: await this.hash(await Promise.all([
                    this.hash(dataHash),
                    this.hash(intToBuffer(maxByteRange))
                ])),
                dataHash: dataHash,
                minByteRange,
                maxByteRange
            };
        }));
    }
    /**
     * Builds an arweave merkle tree and gets the root hash for the given input.
     */ async computeRootHash(data) {
        const rootNode = await this.generateTree(data);
        return rootNode.id;
    }
    async generateTree(data) {
        const rootNode = await this.buildLayers(await this.generateLeaves(await this.chunkData(data)));
        return rootNode;
    }
    /**
     * Generates the data_root, chunks & proofs
     * needed for a transaction.
     *
     * This also checks if the last chunk is a zero-length
     * chunk and discards that chunk and proof if so.
     * (we do not need to upload this zero length chunk)
     *
     * @param data
     */ async generateTransactionChunks(data) {
        const chunks = await this.chunkData(data);
        const leaves = await this.generateLeaves(chunks);
        const root = await this.buildLayers(leaves);
        const proofs = await this.generateProofs(root);
        // Discard the last chunk & proof if it's zero length.
        const lastChunk = chunks.slice(-1)[0];
        if (lastChunk.maxByteRange - lastChunk.minByteRange === 0) {
            chunks.splice(chunks.length - 1, 1);
            proofs.splice(proofs.length - 1, 1);
        }
        return {
            data_root: root.id,
            chunks,
            proofs
        };
    }
    /**
     * Starting with the bottom layer of leaf nodes, hash every second pair
     * into a new branch node, push those branch nodes onto a new layer,
     * and then recurse, building up the tree to it's root, where the
     * layer only consists of two items.
     */ async buildLayers(nodes, level = 0) {
        // If there is only 1 node left, this is going to be the root node
        if (nodes.length < 2) {
            const root = nodes[0];
            // console.log("Root layer", root);
            return root;
        }
        const nextLayer = [];
        for(let i = 0; i < nodes.length; i += 2){
            nextLayer.push(await this.hashBranch(nodes[i], nodes[i + 1]));
        }
        // console.log("Layer", nextLayer);
        return this.buildLayers(nextLayer, level + 1);
    }
    /**
     * Recursively search through all branches of the tree,
     * and generate a proof for each leaf node.
     */ generateProofs(root) {
        const proofs = this.resolveBranchProofs(root);
        if (!Array.isArray(proofs)) {
            return [
                proofs
            ];
        }
        return arrayFlatten(proofs);
    }
    resolveBranchProofs(node, proof = new Uint8Array(), depth = 0) {
        if (node.type == "leaf") {
            return {
                offset: node.maxByteRange - 1,
                proof: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["concatBuffers"])([
                    proof,
                    node.dataHash,
                    intToBuffer(node.maxByteRange)
                ])
            };
        }
        if (node.type == "branch") {
            const partialProof = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["concatBuffers"])([
                proof,
                node.leftChild.id,
                node.rightChild.id,
                intToBuffer(node.byteRange)
            ]);
            return [
                this.resolveBranchProofs(node.leftChild, partialProof, depth + 1),
                this.resolveBranchProofs(node.rightChild, partialProof, depth + 1)
            ];
        }
        throw new Error(`Unexpected node type`);
    }
    async validatePath(id, dest, leftBound, rightBound, path) {
        if (rightBound <= 0) {
            return false;
        }
        if (dest >= rightBound) {
            return this.validatePath(id, 0, rightBound - 1, rightBound, path);
        }
        if (dest < 0) {
            return this.validatePath(id, 0, 0, rightBound, path);
        }
        if (path.length == HASH_SIZE + NOTE_SIZE) {
            const pathData = path.slice(0, HASH_SIZE);
            const endOffsetBuffer = path.slice(pathData.length, pathData.length + NOTE_SIZE);
            const pathDataHash = await this.hash([
                await this.hash(pathData),
                await this.hash(endOffsetBuffer)
            ]);
            const result = arrayCompare(id, pathDataHash);
            if (result) {
                return {
                    offset: rightBound - 1,
                    leftBound: leftBound,
                    rightBound: rightBound,
                    chunkSize: rightBound - leftBound
                };
            }
            return false;
        }
        const left = path.slice(0, HASH_SIZE);
        const right = path.slice(left.length, left.length + HASH_SIZE);
        const offsetBuffer = path.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);
        const offset = bufferToInt(offsetBuffer);
        const remainder = path.slice(left.length + right.length + offsetBuffer.length);
        const pathHash = await this.hash([
            await this.hash(left),
            await this.hash(right),
            await this.hash(offsetBuffer)
        ]);
        if (arrayCompare(id, pathHash)) {
            if (dest < offset) {
                return await this.validatePath(left, dest, leftBound, Math.min(rightBound, offset), remainder);
            }
            return await this.validatePath(right, dest, Math.max(leftBound, offset), rightBound, remainder);
        }
        return false;
    }
    async hashBranch(left, right) {
        if (!right) {
            return left;
        }
        const branch = {
            type: "branch",
            id: await this.hash([
                await this.hash(left.id),
                await this.hash(right.id),
                await this.hash(intToBuffer(left.maxByteRange))
            ]),
            byteRange: left.maxByteRange,
            maxByteRange: right.maxByteRange,
            leftChild: left,
            rightChild: right
        };
        return branch;
    }
    async hash(data) {
        if (Array.isArray(data)) {
            data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$arweave$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].utils.concatBuffers(data);
        }
        return new Uint8Array(await this.crypto.hash(data));
    }
    /**
     * Inspect an arweave chunk proof.
     * Takes proof, parses, reads and displays the values for console logging.
     * One proof section per line
     * Format: left,right,offset => hash
     */ async debug(proof, output = "") {
        if (proof.byteLength < 1) {
            return output;
        }
        const left = proof.slice(0, HASH_SIZE);
        const right = proof.slice(left.length, left.length + HASH_SIZE);
        const offsetBuffer = proof.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);
        const offset = bufferToInt(offsetBuffer);
        const remainder = proof.slice(left.length + right.length + offsetBuffer.length);
        const pathHash = await this.hash([
            await this.hash(left),
            await this.hash(right),
            await this.hash(offsetBuffer)
        ]);
        const updatedOutput = `${output}\n${JSON.stringify(Buffer.from(left))},${JSON.stringify(Buffer.from(right))},${offset} => ${JSON.stringify(pathHash)}`;
        return this.debug(remainder, updatedOutput);
    }
}
function arrayFlatten(input) {
    const flat = [];
    input.forEach((item)=>{
        if (Array.isArray(item)) {
            flat.push(...arrayFlatten(item));
        } else {
            flat.push(item);
        }
    });
    return flat;
}
function intToBuffer(note) {
    const buffer = new Uint8Array(NOTE_SIZE);
    for(let i = buffer.length - 1; i >= 0; i--){
        const byte = note % 256;
        buffer[i] = byte;
        note = (note - byte) / 256;
    }
    return buffer;
}
function bufferToInt(buffer) {
    let value = 0;
    for(let i = 0; i < buffer.length; i++){
        value *= 256;
        value += buffer[i];
    }
    return value;
}
const arrayCompare = (a, b)=>a.every((value, index)=>b[index] === value);
const __TURBOPACK__default__export__ = Merkle;
 //# sourceMappingURL=merkle.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/common/chunks.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>Chunks
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bignumber.js/bignumber.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$error$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/error.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/utils.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$merkle$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/merkle.js [app-route] (ecmascript)");
;
;
;
;
class Chunks {
    api;
    constructor(api){
        this.api = api;
    }
    async getTransactionMetadata(id) {
        const resp = await this.api.get(`tx/${id}/offset`);
        if (resp.status === 200) {
            return resp.data;
        }
        throw new Error(`Unable to get transaction offset: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$error$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getError"])(resp)}`);
    }
    async getChunk(offset) {
        const resp = await this.api.get(`chunk/${offset}`);
        if (resp.status === 200) {
            return resp.data;
        }
        throw new Error(`Unable to get chunk: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$error$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getError"])(resp)}`);
    }
    async getChunkData(offset) {
        const chunk = await this.getChunk(offset);
        const buf = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["b64UrlToBuffer"](chunk.chunk);
        return buf;
    }
    firstChunkOffset(offsetResponse) {
        return parseInt(offsetResponse.offset) - parseInt(offsetResponse.size) + 1;
    }
    /**
     * Downloads chunks from the configured API peers, with a default concurrency of 10
     * @param id - ID of the transaction to download
     * @param options - Options object for configuring the downloader
     * @param options.concurrency - The number of chunks to download simultaneously. reduce on slower connections.
     * @returns
     */ async downloadChunkedData(id, options) {
        const offsetResponse = await this.getTransactionMetadata(id);
        const size = parseInt(offsetResponse.size);
        const data = new Uint8Array(size);
        let byte = 0;
        for await (const chunkData of this.concurrentChunkDownloader(id, options)){
            data.set(chunkData, byte);
            byte += chunkData.length;
        }
        return data;
    }
    async *concurrentChunkDownloader(id, options) {
        const opts = {
            concurrency: 10,
            ...options
        };
        const metadata = await this.getTransactionMetadata(id);
        // use big numbers for safety
        const endOffset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](metadata.offset);
        const size = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](metadata.size);
        const startOffset = endOffset.minus(size).plus(1);
        let processedBytes = 0;
        const chunks = Math.ceil(size.dividedBy(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$merkle$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_CHUNK_SIZE"]).toNumber());
        const downloadData = (offset)=>this.getChunkData(offset.toString()).then((r)=>{
                processedBytes += r.length;
                return r;
            });
        const processing = [];
        // only parallelise everything except last two chunks.
        // last two due to merkle rebalancing due to minimum chunk size, see https://github.com/ArweaveTeam/arweave-js/blob/ce441f8d4e66a2524cfe86bbbcaed34b887ba193/src/common/lib/merkle.ts#LL53C19-L53C19
        const parallelChunks = chunks - 2;
        const concurrency = Math.min(parallelChunks, opts.concurrency);
        let currChunk = 0;
        // logger.debug(`[downloadTx] Tx ${txId} start ${startOffset} size ${size} chunks ${chunks} concurrency ${concurrency}`);
        for(let i = 0; i < concurrency; i++)processing.push(downloadData(startOffset.plus(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$merkle$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_CHUNK_SIZE"] * currChunk++)));
        while(currChunk < parallelChunks){
            processing.push(downloadData(startOffset.plus(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$merkle$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_CHUNK_SIZE"] * currChunk++)));
            // yield await so that processedBytes works properly
            yield processing.shift();
        }
        while(processing.length > 0)yield processing.shift();
        yield downloadData(startOffset.plus(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$merkle$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_CHUNK_SIZE"] * currChunk++));
        if (size.isGreaterThan(processedBytes)) yield downloadData(startOffset.plus(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$merkle$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_CHUNK_SIZE"] * currChunk++));
        if (!size.isEqualTo(processedBytes)) throw new Error(`got ${processedBytes}B, expected ${size.toString()}B`);
        return;
    }
} //# sourceMappingURL=chunks.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/common/lib/crypto/crypto-augment.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "augmentCrypto": ()=>augmentCrypto
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/utils.js [app-route] (ecmascript)");
;
function augmentCrypto(crypto, augments) {
    const crypt = crypto;
    crypt.deepHash = new augments.deepHash({
        deps: {
            utils: {
                stringToBuffer: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringToBuffer"],
                concatBuffers: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["concatBuffers"]
            },
            crypto
        }
    });
    return crypt;
//   crypto: Class<CryptoInterface>,
//   augments: { deepHash: Class<DeepHash, ConstructorParameters<typeof DeepHash>> },
// ): AugmentedCrypto {
//   const cryptoAugment = class Crypto extends crypto implements CryptoInterface {
//     public deepHash: DeepHash;
//     constructor() {
//       super();
//       this.deepHash = new augments.deepHash({ deps: { crypto: this, utils: ArweaveUtils } });
//     }
//   };
//   return new cryptoAugment();
} //# sourceMappingURL=crypto-augment.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/common/lib/deepHash.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "DeepHash": ()=>DeepHash
});
class DeepHash {
    crypto;
    utils;
    constructor({ deps }){
        this.crypto = deps.crypto;
        this.utils = deps.utils;
    }
    async deepHash(data) {
        if (Array.isArray(data)) {
            const tag = this.utils.concatBuffers([
                this.utils.stringToBuffer("list"),
                this.utils.stringToBuffer(data.length.toString())
            ]);
            return await this.deepHashChunks(data, await this.crypto.hash(tag, "SHA-384"));
        }
        const tag = this.utils.concatBuffers([
            this.utils.stringToBuffer("blob"),
            this.utils.stringToBuffer(data.byteLength.toString())
        ]);
        const taggedHash = this.utils.concatBuffers([
            await this.crypto.hash(tag, "SHA-384"),
            await this.crypto.hash(data, "SHA-384")
        ]);
        return await this.crypto.hash(taggedHash, "SHA-384");
    }
    async deepHashChunks(chunks, acc) {
        if (chunks.length < 1) return acc;
        const hashPair = this.utils.concatBuffers([
            acc,
            await this.deepHash(chunks[0])
        ]);
        const newAcc = await this.crypto.hash(hashPair, "SHA-384");
        return await this.deepHashChunks(chunks.slice(1), newAcc);
    }
} //# sourceMappingURL=deepHash.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/common/lib/api.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>Api
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/axios/lib/axios.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$async$2d$retry$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/async-retry/lib/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$arweave$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/arweave.js [app-route] (ecmascript)");
;
;
;
class Api {
    _instance;
    cookieMap = new Map();
    config;
    constructor(config){
        if (config) this.applyConfig(config);
    }
    applyConfig(config) {
        this.config = this.mergeDefaults(config);
        this._instance = undefined;
    }
    getConfig() {
        return this.config;
    }
    async requestInterceptor(request) {
        const cookies = this.cookieMap.get(new URL(request.baseURL ?? "").host);
        if (cookies) request.headers.cookie = cookies;
        return request;
    }
    async responseInterceptor(response) {
        const setCookie = response.headers?.["set-cookie"];
        if (setCookie) this.cookieMap.set(response.request.host, setCookie);
        return response;
    }
    mergeDefaults(config) {
        config.headers ??= {};
        if (config.network && !Object.keys(config.headers).includes("x-network")) config.headers["x-network"] = config.network;
        return {
            url: config.url,
            timeout: config.timeout ?? 20000,
            logging: config.logging ?? false,
            logger: config.logger ?? console.log,
            headers: {
                ...config.headers,
                "x-irys-arweave-version": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$arweave$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].VERSION
            },
            withCredentials: config.withCredentials ?? false,
            retry: {
                retries: 3,
                maxTimeout: 5_000
            }
        };
    }
    async get(path, config) {
        try {
            return await this.request(path, {
                ...config,
                method: "GET"
            });
        } catch (error) {
            if (error.response?.status) return error.response;
            throw error;
        }
    }
    async post(path, body, config) {
        try {
            return await this.request(path, {
                data: body,
                ...config,
                method: "POST"
            });
        } catch (error) {
            if (error.response?.status) return error.response;
            throw error;
        }
    }
    get instance() {
        if (this._instance) return this._instance;
        const instance = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].create({
            baseURL: this.config.url.toString(),
            timeout: this.config.timeout,
            maxContentLength: 1024 * 1024 * 512,
            headers: this.config.headers,
            withCredentials: this.config.withCredentials
        });
        if (this.config.withCredentials) {
            instance.interceptors.request.use(this.requestInterceptor.bind(this));
            instance.interceptors.response.use(this.responseInterceptor.bind(this));
        }
        if (this.config.logging) {
            instance.interceptors.request.use((request)=>{
                this.config.logger(`Requesting: ${request.baseURL}/${request.url}`);
                return request;
            });
            instance.interceptors.response.use((response)=>{
                this.config.logger(`Response: ${response.config.url} - ${response.status}`);
                return response;
            });
        }
        return this._instance = instance;
    }
    async request(path, config) {
        const instance = this.instance;
        const url = config?.url ?? new URL(path, this.config.url).toString();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$async$2d$retry$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])((_)=>instance({
                ...config,
                url
            }), {
            ...this.config.retry,
            ...config?.retry
        });
    }
} //# sourceMappingURL=api.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/common/lib/fallbackApi.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "FallbackApi": ()=>FallbackApi,
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/api.js [app-route] (ecmascript)");
;
const isApiConfig = (o)=>typeof o !== "string" && "url" in o;
const defaultFallbackConfig = {
    maxAttempts: 15,
    randomlySelect: true
};
class FallbackApi {
    minerInstances = [];
    globalConfig;
    gatewayInstances = [];
    constructor({ gateways, miners, opts }){
        this.globalConfig = opts?.globalConfig ?? {};
        if (miners) this.addMiners(miners);
        if (gateways) this.addGateways(gateways);
    // this.gatewayInstance = this.minerInstances[0];
    }
    async addPeersFrom(url, options) {
        const peers = (await this.get("", {
            url: new URL("/peers", url).toString()
        })).data;
        this.addMiners(peers.slice(0, options?.limit).map((p)=>`http://${p}`));
    }
    addMiners(hosts) {
        hosts.forEach((h)=>this.minerInstances.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](isApiConfig(h) ? h : {
                url: new URL(h),
                ...this.globalConfig
            })));
    }
    addGateways(hosts) {
        hosts.forEach((h)=>this.gatewayInstances.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](isApiConfig(h) ? h : {
                url: new URL(h),
                ...this.globalConfig
            })));
    }
    async get(path, config) {
        return this.request(path, {
            ...config,
            method: "GET"
        });
    }
    async post(path, body, config) {
        return this.request(path, {
            data: body,
            ...config,
            method: "POST"
        });
    }
    async request(path, config) {
        const fallbackConfig = {
            ...defaultFallbackConfig,
            ...config?.fallback
        };
        let attempts = 0;
        const errors = [];
        const instances = config?.gatewayOnly ? this.gatewayInstances : this.gatewayInstances.concat(this.minerInstances);
        const maxAttempts = Math.min(Math.max(fallbackConfig?.maxAttempts, 1), instances.length);
        const onFallback = fallbackConfig?.onFallback;
        if (instances.length === 0) throw new Error(`Unable to run request due to 0 configured gateways/miners.`);
        while(attempts++ < maxAttempts){
            const apiInstance = instances.at(fallbackConfig?.randomlySelect ? Math.floor(Math.random() * instances.length) : attempts - 1);
            if (!apiInstance) continue;
            try {
                return await apiInstance.request(path, {
                    ...config
                });
            } catch (e) {
                onFallback?.(e, apiInstance);
                errors.push(e);
                if (attempts >= maxAttempts) throw e;
            }
        }
        throw new Error("unreachable");
    }
}
const __TURBOPACK__default__export__ = FallbackApi;
 //# sourceMappingURL=fallbackApi.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/common/network.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>Network
});
class Network {
    api;
    constructor(api){
        this.api = api;
    }
    getInfo() {
        return this.api.get(`info`).then((response)=>{
            return response.data;
        });
    }
    getPeers() {
        return this.api.get(`peers`).then((response)=>{
            return response.data;
        });
    }
} //# sourceMappingURL=network.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/common/lib/transaction-uploader.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "FATAL_CHUNK_UPLOAD_ERRORS": ()=>FATAL_CHUNK_UPLOAD_ERRORS,
    "TransactionUploader": ()=>TransactionUploader
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/transaction.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$error$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/error.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/utils.js [app-route] (ecmascript)");
;
;
;
// import { validatePath } from "./merkle.js";
// Maximum amount of chunks we will upload in the body.
const MAX_CHUNKS_IN_BODY = 1;
const FATAL_CHUNK_UPLOAD_ERRORS = [
    "invalid_json",
    "chunk_too_big",
    "data_path_too_big",
    "offset_too_big",
    "data_size_too_big",
    "chunk_proof_ratio_not_attractive",
    "invalid_proof"
];
// Amount we will delay on receiving an error response but do want to continue.
const ERROR_DELAY = 1000 * 40;
class TransactionUploader {
    chunkIndex = 0;
    txPosted = false;
    transaction;
    lastRequestTimeEnd = 0;
    totalErrors = 0;
    data;
    lastResponseStatus = 0;
    lastResponseError = "";
    get isComplete() {
        return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
    }
    get totalChunks() {
        return this.transaction.chunks.chunks.length;
    }
    get uploadedChunks() {
        return this.chunkIndex;
    }
    get pctComplete() {
        return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
    }
    crypto;
    api;
    merkle;
    deepHash;
    constructor({ deps, transaction }){
        if (!transaction.id) {
            throw new Error(`Transaction is not signed`);
        }
        if (!transaction.chunks) {
            throw new Error(`Transaction chunks not prepared`);
        }
        this.api = deps.api;
        this.crypto = deps.crypto;
        this.merkle = deps.merkle;
        this.deepHash = deps.deepHash;
        // Make a copy of transaction, zeroing the data so we can serialize.
        this.data = transaction.data;
        this.transaction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
            attributes: Object.assign({}, transaction, {
                data: new Uint8Array(0)
            }),
            deps: {
                merkle: deps.merkle,
                deepHash: deps.deepHash
            }
        });
    }
    /**
     * Uploads the next part of the transaction.
     * On the first call this posts the transaction
     * itself and on any subsequent calls uploads the
     * next chunk until it completes.
     */ async uploadChunk(chunkIndex_) {
        if (this.isComplete) {
            throw new Error(`Upload is already complete`);
        }
        if (this.lastResponseError !== "") {
            this.totalErrors++;
        } else {
            this.totalErrors = 0;
        }
        // We have been trying for about an hour receiving an
        // error every time, so eventually bail.
        if (this.totalErrors === 100) {
            throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
        }
        let delay = this.lastResponseError === "" ? 0 : Math.max(this.lastRequestTimeEnd + ERROR_DELAY - Date.now(), ERROR_DELAY);
        if (delay > 0) {
            // Jitter delay bcoz networks, subtract up to 30% from 40 seconds
            delay = delay - delay * Math.random() * 0.3;
            await new Promise((res)=>setTimeout(res, delay));
        }
        this.lastResponseError = "";
        if (!this.txPosted) {
            await this.postTransaction();
            return;
        }
        if (chunkIndex_) {
            this.chunkIndex = chunkIndex_;
        }
        const chunk = this.transaction.getChunk(chunkIndex_ || this.chunkIndex, this.data);
        const chunkOk = await this.merkle.validatePath(this.transaction.chunks.data_root, parseInt(chunk.offset), 0, parseInt(chunk.data_size), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["b64UrlToBuffer"])(chunk.data_path));
        if (!chunkOk) {
            throw new Error(`Unable to validate chunk ${this.chunkIndex}`);
        }
        // Catch network errors and turn them into objects with status -1 and an error message.
        const resp = await this.api.post(`chunk`, this.transaction.getChunk(this.chunkIndex, this.data)).catch((e)=>{
            console.error(e.message);
            return {
                status: -1,
                data: {
                    error: e.message
                }
            };
        });
        this.lastRequestTimeEnd = Date.now();
        this.lastResponseStatus = resp.status;
        if (this.lastResponseStatus == 200) {
            this.chunkIndex++;
        } else {
            this.lastResponseError = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$error$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getError"])(resp);
            if (FATAL_CHUNK_UPLOAD_ERRORS.includes(this.lastResponseError)) {
                throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
            }
        }
    }
    /**
     * Reconstructs an upload from its serialized state and data.
     * Checks if data matches the expected data_root.
     *
     * @param serialized
     * @param data
     */ static async fromSerialized({ serialized, data, deps }) {
        if (!serialized || typeof serialized.chunkIndex !== "number" || typeof serialized.transaction !== "object") {
            throw new Error(`Serialized object does not match expected format.`);
        }
        // Everything looks ok, reconstruct the TransactionUpload,
        // prepare the chunks again and verify the data_root matches
        const transaction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](serialized.transaction);
        if (!transaction.chunks) {
            await transaction.prepareChunks(data);
        }
        const upload = new TransactionUploader({
            deps,
            transaction
        });
        // Copy the serialized upload information, and data passed in.
        upload.chunkIndex = serialized.chunkIndex;
        upload.lastRequestTimeEnd = serialized.lastRequestTimeEnd;
        upload.lastResponseError = serialized.lastResponseError;
        upload.lastResponseStatus = serialized.lastResponseStatus;
        upload.txPosted = serialized.txPosted;
        upload.data = data;
        if (upload.transaction.data_root !== serialized.transaction.data_root) {
            throw new Error(`Data mismatch: Uploader doesn't match provided data.`);
        }
        return upload;
    }
    /**
     * Reconstruct an upload from the tx metadata, ie /tx/<id>.
     *
     * @param api
     * @param id
     * @param data
     */ static async fromTransactionId(api, id) {
        const resp = await api.get(`tx/${id}`);
        if (resp.status !== 200) {
            throw new Error(`Tx ${id} not found: ${resp.status}`);
        }
        const transaction = resp.data;
        transaction.data = new Uint8Array(0);
        const serialized = {
            txPosted: true,
            chunkIndex: 0,
            lastResponseError: "",
            lastRequestTimeEnd: 0,
            lastResponseStatus: 0,
            transaction
        };
        return serialized;
    }
    toJSON() {
        return {
            chunkIndex: this.chunkIndex,
            transaction: this.transaction,
            lastRequestTimeEnd: this.lastRequestTimeEnd,
            lastResponseStatus: this.lastResponseStatus,
            lastResponseError: this.lastResponseError,
            txPosted: this.txPosted
        };
    }
    // POST to /tx
    async postTransaction() {
        const uploadInBody = this.totalChunks <= MAX_CHUNKS_IN_BODY;
        if (uploadInBody) {
            // Post the transaction with data.
            this.transaction.data = this.data;
            const resp = await this.api.post(`tx`, this.transaction).catch((e)=>{
                console.error(e);
                return {
                    status: -1,
                    data: {
                        error: e.message
                    }
                };
            });
            this.lastRequestTimeEnd = Date.now();
            this.lastResponseStatus = resp.status;
            this.transaction.data = new Uint8Array(0);
            if (resp.status >= 200 && resp.status < 300) {
                // We are complete.
                this.txPosted = true;
                this.chunkIndex = MAX_CHUNKS_IN_BODY;
                return;
            }
            this.lastResponseError = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$error$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getError"])(resp);
            throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);
        }
        // Post the transaction with no data.
        const resp = await this.api.post(`tx`, this.transaction);
        this.lastRequestTimeEnd = Date.now();
        this.lastResponseStatus = resp.status;
        if (!(resp.status >= 200 && resp.status < 300)) {
            this.lastResponseError = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$error$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getError"])(resp);
            throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);
        }
        this.txPosted = true;
    }
} //# sourceMappingURL=transaction-uploader.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/common/transactions.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>Transactions
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$error$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/error.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/transaction.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/utils.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2d$uploader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/transaction-uploader.js [app-route] (ecmascript)");
;
;
;
;
class Transactions {
    api;
    crypto;
    chunks;
    merkle;
    deepHash;
    constructor({ deps }){
        this.api = deps.api;
        this.crypto = deps.crypto;
        this.chunks = deps.chunks;
        this.merkle = deps.merkle;
        this.deepHash = deps.deepHash;
    }
    getTransactionAnchor() {
        /**
         * Maintain compatibility with erdjs which sets a global axios.defaults.transformResponse
         * in order to overcome some other issue in:  https://github.com/axios/axios/issues/983
         *
         * However, this introduces a problem with ardrive-js, so we will enforce
         * config =  {transformResponse: []} where we do not require a transform
         */ return this.api.get(`tx_anchor`, {
            transformResponse: []
        }).then((response)=>{
            return response.data;
        });
    }
    getPrice(byteSize, targetAddress) {
        const endpoint = targetAddress ? `price/${byteSize}/${targetAddress}` : `price/${byteSize}`;
        return this.api.get(endpoint, {
            transformResponse: [
                /**
                 * We need to specify a response transformer to override
                 * the default JSON.parse behavior, as this causes
                 * winston to be converted to a number and we want to
                 * return it as a winston string.
                 * @param data
                 */ function(data) {
                    return data;
                }
            ]
        }).then((response)=>{
            return response.data;
        });
    }
    async get(id) {
        const response = await this.api.get(`tx/${id}`);
        if (response.status == 200) {
            const data_size = parseInt(response.data.data_size);
            if (response.data.format >= 2 && data_size > 0 && data_size <= 1024 * 1024 * 12) {
                const data = await this.getData(id);
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
                    attributes: {
                        ...response.data,
                        data
                    },
                    deps: {
                        merkle: this.merkle,
                        deepHash: this.deepHash
                    }
                });
            }
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
                attributes: {
                    ...response.data,
                    format: response.data.format || 1
                },
                deps: {
                    merkle: this.merkle,
                    deepHash: this.deepHash
                }
            });
        }
        if (response.status === 404) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$error$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]("TX_NOT_FOUND" /* ArweaveErrorType.TX_NOT_FOUND */ );
        }
        if (response.status === 410) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$error$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]("TX_FAILED" /* ArweaveErrorType.TX_FAILED */ );
        }
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$error$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]("TX_INVALID" /* ArweaveErrorType.TX_INVALID */ );
    }
    fromRaw(attributes) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
            attributes,
            deps: {
                merkle: this.merkle,
                deepHash: this.deepHash
            }
        });
    }
    getStatus(id) {
        return this.api.get(`tx/${id}/status`).then((response)=>{
            if (response.status === 200) {
                return {
                    status: 200,
                    confirmed: response.data
                };
            }
            return {
                status: response.status,
                confirmed: null
            };
        });
    }
    async getData(id) {
        let data = undefined;
        try {
            data = (await this.api.get(`/${id}`, {
                responseType: "arraybuffer"
            })).data;
        } catch (error) {
            console.error(`Error while trying to download contiguous data from gateway cache for ${id}`);
            console.error(error);
        }
        if (!data) {
            console.warn(`Falling back to chunks for ${id}`);
            try {
                data = await this.chunks.downloadChunkedData(id);
            } catch (error) {
                console.error(`Error while trying to download chunked data for ${id}`);
                console.error(error);
            }
        }
        if (!data) {
            throw new Error(`${id} data was not found!`);
        }
        return data;
    }
    async getDataStream(id) {
        let data = undefined;
        try {
            const resData = (await this.api.get(`/${id}`, {
                responseType: "arraybuffer"
            })).data;
            const gen = async function* g() {
                yield resData;
            };
            data = gen();
        } catch (error) {
            console.error(`Error while trying to download contiguous data from gateway cache for ${id}`);
            console.error(error);
        }
        if (!data) {
            console.warn(`Falling back to chunks for ${id}`);
            try {
                const gen = this.chunks.concurrentChunkDownloader(id);
                data = gen;
            } catch (error) {
                console.error(`Error while trying to download chunked data for ${id}`);
                console.error(error);
            }
        }
        if (!data) {
            throw new Error(`${id} data was not found!`);
        }
        return data;
    }
    async sign(transaction, jwk, options) {
        /** Non-exhaustive (only checks key names), but previously no jwk checking was done */ const isJwk = (obj)=>{
            let valid = true;
            [
                "n",
                "e",
                "d",
                "p",
                "q",
                "dp",
                "dq",
                "qi"
            ].map((key)=>!(key in obj) && (valid = false));
            return valid;
        };
        const validJwk = typeof jwk === "object" && isJwk(jwk);
        const externalWallet = typeof arweaveWallet === "object";
        if (!validJwk && !externalWallet) {
            throw new Error(`No valid JWK or external wallet found to sign transaction.`);
        } else if (externalWallet) {
            try {
                const existingPermissions = await arweaveWallet.getPermissions();
                if (!existingPermissions.includes("SIGN_TRANSACTION")) await arweaveWallet.connect([
                    "SIGN_TRANSACTION"
                ]);
            } catch  {
            // Permission is already granted
            }
            // for external compatibility
            transaction.tags = transaction.tags.map((v)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ArweaveTag"](v.name, v.value));
            const signedTransaction = await arweaveWallet.sign(transaction, options);
            transaction.setSignature({
                id: signedTransaction.id,
                owner: signedTransaction.owner,
                reward: signedTransaction.reward,
                tags: signedTransaction.tags,
                signature: signedTransaction.signature
            });
        } else if (validJwk) {
            transaction.setOwner(jwk.n);
            const dataToSign = await transaction.getSignatureData();
            const rawSignature = await this.crypto.sign(jwk, dataToSign, options);
            const id = await this.crypto.hash(rawSignature);
            transaction.setSignature({
                id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["bufferTob64Url"](id),
                owner: jwk.n,
                signature: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["bufferTob64Url"](rawSignature)
            });
        } else {
            // can't get here, but for sanity we'll throw an error.
            throw new Error(`An error occurred while signing. Check wallet is valid`);
        }
    }
    async verify(transaction) {
        const signaturePayload = await transaction.getSignatureData();
        /**
         * The transaction ID should be a SHA-256 hash of the raw signature bytes, so this needs
         * to be recalculated from the signature and checked against the transaction ID.
         */ const rawSignature = transaction.get("signature", {
            decode: true,
            string: false
        });
        const expectedId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["bufferTob64Url"](await this.crypto.hash(rawSignature));
        if (transaction.id !== expectedId) {
            throw new Error(`Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.`);
        }
        /**
         * Now verify the signature is valid and signed by the owner wallet (owner field = originating wallet public key).
         */ return this.crypto.verify(transaction.owner, signaturePayload, rawSignature);
    }
    async post(transaction) {
        if (typeof transaction === "string") {
            transaction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
                attributes: JSON.parse(transaction),
                deps: {
                    merkle: this.merkle,
                    deepHash: this.deepHash
                }
            });
        } else if (typeof transaction.readInt32BE === "function") {
            transaction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
                attributes: JSON.parse(transaction.toString()),
                deps: {
                    merkle: this.merkle,
                    deepHash: this.deepHash
                }
            });
        } else if (typeof transaction === "object" && !(transaction instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])) {
            transaction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
                attributes: transaction,
                deps: {
                    merkle: this.merkle,
                    deepHash: this.deepHash
                }
            });
        }
        if (!(transaction instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])) {
            throw new Error(`Must be Transaction object`);
        }
        if (!transaction.chunks) {
            await transaction.prepareChunks(transaction.data);
        }
        const uploader = await this.getUploader(transaction, transaction.data);
        // Emulate existing error & return value behavior.
        try {
            while(!uploader.isComplete){
                await uploader.uploadChunk();
            }
        } catch (e) {
            if (uploader.lastResponseStatus > 0) {
                return {
                    status: uploader.lastResponseStatus,
                    statusText: uploader.lastResponseError,
                    data: {
                        error: uploader.lastResponseError
                    }
                };
            }
            throw e;
        }
        return {
            status: 200,
            statusText: "OK",
            data: {}
        };
    }
    /**
     * Gets an uploader than can be used to upload a transaction chunk by chunk, giving progress
     * and the ability to resume.
     *
     * Usage example:
     *
     * ```
     * const uploader = arweave.transactions.getUploader(transaction);
     * while (!uploader.isComplete) {
     *   await uploader.uploadChunk();
     *   console.log(`${uploader.pctComplete}%`);
     * }
     * ```
     *
     * @param upload a Transaction object, a previously save progress object, or a transaction id.
     * @param data the data of the transaction. Required when resuming an upload.
     */ async getUploader(upload, data) {
        let uploader;
        if (data instanceof ArrayBuffer) {
            data = new Uint8Array(data);
        }
        if (upload instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]) {
            if (!data) {
                data = upload.data;
            }
            if (!(data instanceof Uint8Array)) {
                throw new Error("Data format is invalid");
            }
            if (!upload.chunks) {
                await upload.prepareChunks(data);
            }
            uploader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2d$uploader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TransactionUploader"]({
                transaction: upload,
                deps: {
                    api: this.api,
                    crypto: this.crypto,
                    merkle: this.merkle,
                    deepHash: this.deepHash
                }
            });
            if (!uploader.data || uploader.data.length === 0) {
                uploader.data = data;
            }
        } else {
            if (typeof upload === "string") {
                upload = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2d$uploader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TransactionUploader"].fromTransactionId(this.api, upload);
            }
            if (!data || !(data instanceof Uint8Array)) {
                throw new Error(`Must provide data when resuming upload`);
            }
            // upload should be a serialized upload.
            uploader = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2d$uploader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TransactionUploader"].fromSerialized({
                deps: {
                    api: this.api,
                    merkle: this.merkle,
                    crypto: this.crypto,
                    deepHash: this.deepHash
                },
                serialized: upload,
                data
            });
        }
        return uploader;
    }
    /**
     * Async generator version of uploader
     *
     * Usage example:
     *
     * ```
     * for await (const uploader of arweave.transactions.upload(tx)) {
     *  console.log(`${uploader.pctComplete}%`);
     * }
     * ```
     *
     * @param upload a Transaction object, a previously save uploader, or a transaction id.
     * @param data the data of the transaction. Required when resuming an upload.
     */ async *upload(upload, data) {
        const uploader = await this.getUploader(upload, data);
        while(!uploader.isComplete){
            await uploader.uploadChunk();
            yield uploader;
        }
        return uploader;
    }
} //# sourceMappingURL=transactions.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/common/wallets.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>Wallets
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/utils.js [app-route] (ecmascript)");
;
class Wallets {
    api;
    crypto;
    constructor(api, crypto){
        this.api = api;
        this.crypto = crypto;
    }
    /**
     * Get the wallet balance for the given address.
     *
     * @param {string} address - The arweave address to get the balance for.
     *
     * @returns {Promise<string>} - Promise which resolves with a winston string balance.
     */ getBalance(address) {
        return this.api.get(`wallet/${address}/balance`, {
            transformResponse: [
                /**
                 * We need to specify a response transformer to override
                 * the default JSON.parse behaviour, as this causes
                 * balances to be converted to a number and we want to
                 * return it as a winston string.
                 * @param data
                 */ function(data) {
                    return data;
                }
            ]
        }).then((response)=>{
            return response.data;
        });
    }
    /**
     * Get the last transaction ID for the given wallet address.
     *
     * @param {string} address - The arweave address to get the transaction for.
     *
     * @returns {Promise<string>} - Promise which resolves with a transaction ID.
     */ getLastTransactionID(address) {
        return this.api.get(`wallet/${address}/last_tx`).then((response)=>{
            return response.data;
        });
    }
    generate() {
        return this.crypto.generateJWK();
    }
    async jwkToAddress(jwk) {
        if (!jwk || jwk === "use_wallet") {
            return this.getAddress();
        } else {
            return this.getAddress(jwk);
        }
    }
    async getAddress(jwk) {
        if (!jwk || jwk === "use_wallet") {
            try {
                await arweaveWallet.connect([
                    "ACCESS_ADDRESS"
                ]);
            } catch  {
            // Permission is already granted
            }
            return arweaveWallet.getActiveAddress();
        } else {
            return this.ownerToAddress(jwk.n);
        }
    }
    async ownerToAddress(owner) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["bufferTob64Url"](await this.crypto.hash(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["b64UrlToBuffer"](owner)));
    }
} //# sourceMappingURL=wallets.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/common/arweave.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// import Ar from "./ar";
__turbopack_context__.s({
    "Arweave": ()=>Arweave,
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$blocks$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/blocks.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$chunks$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/chunks.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$crypto$2f$crypto$2d$augment$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/crypto/crypto-augment.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$deepHash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/deepHash.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$fallbackApi$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/fallbackApi.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$merkle$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/merkle.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/transaction.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/utils.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$network$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/network.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$transactions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/transactions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$wallets$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/wallets.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
class Arweave {
    config;
    api;
    wallets;
    transactions;
    network;
    blocks;
    chunks;
    static init;
    static utils = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__;
    crypto;
    deepHash;
    merkle;
    static VERSION = "0.0.1";
    constructor(config){
        this.config = config;
        if (!config.crypto) throw new Error(`config.crypto is required`); // `crypto` is automatically added by the wrapper constructors, users should never encounter this
        this.crypto = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$crypto$2f$crypto$2d$augment$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["augmentCrypto"])(config.crypto, {
            deepHash: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$deepHash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DeepHash"]
        });
        this.deepHash = this.crypto.deepHash;
        const apiConfig = config.gateways ? Array.isArray(config.gateways) ? config.gateways : [
            config.gateways
        ] : undefined;
        this.api = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$fallbackApi$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
            gateways: apiConfig,
            miners: config.miners
        });
        this.wallets = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$wallets$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](this.api, this.crypto);
        this.chunks = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$chunks$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](this.api);
        this.network = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$network$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](this.api);
        this.blocks = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$blocks$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](this.api, this.network);
        this.merkle = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$merkle$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
            deps: {
                crypto: this.crypto
            }
        });
        this.transactions = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$transactions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
            deps: {
                api: this.api,
                crypto: config.crypto,
                chunks: this.chunks,
                merkle: this.merkle,
                deepHash: this.deepHash
            }
        });
    }
    get utils() {
        return Arweave.utils;
    }
    getConfig() {
        return this.config;
    }
    async createTransaction(attributes, jwk) {
        const transaction = {};
        Object.assign(transaction, attributes);
        if (!attributes.data && !(attributes.target && attributes.quantity)) {
            throw new Error(`A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.`);
        }
        if (attributes.owner == undefined) {
            if (jwk && jwk !== "use_wallet") {
                transaction.owner = jwk.n;
            }
        }
        if (attributes.last_tx == undefined) {
            transaction.last_tx = await this.transactions.getTransactionAnchor();
        }
        if (typeof attributes.data === "string") {
            attributes.data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__.stringToBuffer(attributes.data);
        }
        if (attributes.data instanceof ArrayBuffer) {
            attributes.data = new Uint8Array(attributes.data);
        }
        if (attributes.data && !(attributes.data instanceof Uint8Array)) {
            throw new Error("Expected data to be a string, Uint8Array or ArrayBuffer");
        }
        if (attributes.reward == undefined) {
            const length = attributes.data ? attributes.data.byteLength : 0;
            transaction.reward = await this.transactions.getPrice(length, transaction.target);
        }
        // here we should call prepare chunk
        transaction.data_root = "";
        transaction.data_size = attributes.data ? attributes.data.byteLength.toString() : "0";
        transaction.data = attributes.data || new Uint8Array(0);
        const createdTransaction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
            attributes: transaction,
            deps: {
                merkle: this.merkle,
                deepHash: this.deepHash
            }
        });
        await createdTransaction.getSignatureData();
        return createdTransaction;
    }
}
const __TURBOPACK__default__export__ = Arweave;
 //# sourceMappingURL=arweave.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/common/index.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$arweave$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/arweave.js [app-route] (ecmascript)");
;
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/common/index.js [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$arweave$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/arweave.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/index.js [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@irys/arweave/build/esm/common/arweave.js [app-route] (ecmascript) <export Arweave as default>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$arweave$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Arweave"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$arweave$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/arweave.js [app-route] (ecmascript)");
}),
"[project]/node_modules/@irys/arweave/build/esm/node/stream/chunker.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ChunkBuffer": ()=>ChunkBuffer,
    "chunker": ()=>chunker
});
class ChunkBuffer {
    buffers = [];
    get empty() {
        return this.buffers.length === 0;
    }
    push(...buffers) {
        this.buffers.push(...buffers);
    }
    pop(expectedChunkSize) {
        let totalBufferSize = 0;
        for (const [i, chunk] of this.buffers.entries()){
            totalBufferSize += chunk.byteLength;
            if (totalBufferSize === expectedChunkSize) {
                return Buffer.concat(this.buffers.splice(0, i + 1));
            } else if (totalBufferSize > expectedChunkSize) {
                const chunkOverflowAmount = totalBufferSize - expectedChunkSize;
                const chunkWatermark = chunk.byteLength - chunkOverflowAmount;
                const chunkBelowWatermark = chunk.slice(0, chunkWatermark);
                const chunkOverflow = chunk.slice(chunkWatermark);
                const chunkBuffers = this.buffers.splice(0, i);
                chunkBuffers.push(chunkBelowWatermark);
                this.buffers[0] = chunkOverflow;
                return Buffer.concat(chunkBuffers);
            }
        }
        return null;
    }
    flush() {
        const remaining = Buffer.concat(this.buffers);
        this.buffers.length = 0;
        return remaining;
    }
}
function chunker(expectedChunkSize, { flush } = {
    flush: false
}) {
    return async function*(stream) {
        const chunkBuffer = new ChunkBuffer();
        for await (const chunk of stream){
            chunkBuffer.push(chunk);
            while(true){
                const sizedChunk = chunkBuffer.pop(expectedChunkSize);
                if (!sizedChunk) {
                    break;
                }
                yield sizedChunk;
            }
        }
        if (flush) {
            const flushedBuffer = chunkBuffer.flush();
            if (flushedBuffer.byteLength > 0) {
                yield flushedBuffer;
            }
        }
    };
} //# sourceMappingURL=chunker.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/node/stream/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Stream": ()=>Stream
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream$2f$promises__$5b$external$5d$__$28$stream$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream/promises [external] (stream/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$merkle$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/merkle.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/transaction.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2d$uploader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/transaction-uploader.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/utils.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$node$2f$stream$2f$chunker$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/node/stream/chunker.js [app-route] (ecmascript)");
;
;
;
;
;
;
const MAX_CONCURRENT_CHUNK_UPLOAD_COUNT = 128;
class Stream {
    crypto;
    merkle;
    api;
    transactions;
    deepHash;
    constructor({ deps }){
        this.crypto = deps.crypto;
        this.merkle = deps.merkle;
        this.api = deps.api;
        this.transactions = deps.transactions;
        this.deepHash = deps.deepHash;
    }
    /**
     * Creates an Arweave transaction from the piped data stream.
     */ createTransactionAsync(attributes, jwk) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const oThis = this;
        return async (source)=>{
            const chunks = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$stream$2f$promises__$5b$external$5d$__$28$stream$2f$promises$2c$__cjs$29$__["pipeline"])(source, oThis.generateTransactionChunksAsync());
            const txAttrs = Object.assign({}, attributes);
            txAttrs.owner ??= jwk?.n;
            txAttrs.last_tx ??= await oThis.transactions.getTransactionAnchor();
            const lastChunk = chunks.chunks[chunks.chunks.length - 1];
            const dataByteLength = lastChunk.maxByteRange;
            txAttrs.reward ??= await oThis.transactions.getPrice(dataByteLength, txAttrs.target);
            txAttrs.data_size = dataByteLength.toString();
            const tx = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]({
                attributes: txAttrs,
                deps: {
                    merkle: oThis.merkle,
                    deepHash: oThis.deepHash
                }
            });
            tx.chunks = chunks;
            tx.data_root = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["bufferTob64Url"])(chunks.data_root);
            return tx;
        };
    }
    /**
     * Generates the Arweave transaction chunk information from the piped data stream.
     */ generateTransactionChunksAsync() {
        const crypto = this.crypto;
        return async (source)=>{
            const chunks = [];
            /**
             * @param chunkByteIndex the index the start of the specified chunk is located at within its original data stream.
             */ const addChunk = async (chunkByteIndex, chunk)=>{
                const dataHash = await crypto.hash(chunk);
                const chunkRep = {
                    dataHash,
                    minByteRange: chunkByteIndex,
                    maxByteRange: chunkByteIndex + chunk.byteLength
                };
                chunks.push(chunkRep);
                return chunkRep;
            };
            let chunkStreamByteIndex = 0;
            let previousDataChunk;
            let expectChunkGenerationCompleted = false;
            await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$stream$2f$promises__$5b$external$5d$__$28$stream$2f$promises$2c$__cjs$29$__["pipeline"])(source, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$node$2f$stream$2f$chunker$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["chunker"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$merkle$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_CHUNK_SIZE"], {
                flush: true
            }), async (chunkedSource)=>{
                for await (const chunk of chunkedSource){
                    if (expectChunkGenerationCompleted) {
                        throw Error("Expected chunk generation to have completed.");
                    }
                    if (chunk.byteLength >= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$merkle$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_CHUNK_SIZE"] && chunk.byteLength <= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$merkle$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_CHUNK_SIZE"]) {
                        await addChunk(chunkStreamByteIndex, chunk);
                    } else if (chunk.byteLength < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$merkle$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MIN_CHUNK_SIZE"]) {
                        if (previousDataChunk) {
                            // If this final chunk is smaller than the minimum chunk size, rebalance this final chunk and
                            // the previous chunk to keep the final chunk size above the minimum threshold.
                            const remainingBytes = Buffer.concat([
                                previousDataChunk,
                                chunk
                            ], previousDataChunk.byteLength + chunk.byteLength);
                            const rebalancedSizeForPreviousChunk = Math.ceil(remainingBytes.byteLength / 2);
                            const previousChunk = chunks.pop();
                            const rebalancedPreviousChunk = await addChunk(previousChunk.minByteRange, remainingBytes.slice(0, rebalancedSizeForPreviousChunk));
                            await addChunk(rebalancedPreviousChunk.maxByteRange, remainingBytes.slice(rebalancedSizeForPreviousChunk));
                        } else {
                            // This entire stream should be smaller than the minimum chunk size, just add the chunk in.
                            await addChunk(chunkStreamByteIndex, chunk);
                        }
                        expectChunkGenerationCompleted = true;
                    } else if (chunk.byteLength > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$merkle$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_CHUNK_SIZE"]) {
                        throw Error("Encountered chunk larger than max chunk size.");
                    }
                    chunkStreamByteIndex += chunk.byteLength;
                    previousDataChunk = chunk;
                }
            });
            const leaves = await this.merkle.generateLeaves(chunks);
            const root = await this.merkle.buildLayers(leaves);
            const proofs = this.merkle.generateProofs(root);
            return {
                data_root: root.id,
                chunks,
                proofs
            };
        };
    }
    /**
     * Uploads the piped data to the specified transaction.
     *
     * @param tx
     * @param arweave
     * @param createTx whether or not the passed transaction should be created on the network.
     * This can be false if we want to reseed an existing transaction,
     * @param debugOpts
     */ uploadTransactionAsync(tx, createTx = true, debugOpts) {
        const txId = tx.id;
        const log = (message)=>{
            if (debugOpts?.log) debugOpts.log(`[uploadTransactionAsync:${txId}] ${message}`);
        };
        log(`Starting chunked upload - ${tx.chunks?.chunks?.length} chunks / ${tx.data_size} total bytes`);
        return async (source)=>{
            if (!tx.chunks) {
                throw Error("Transaction has no computed chunks!");
            }
            if (createTx) {
                // Ensure the transaction data field is blank.
                // We'll upload this data in chunks instead.
                tx.data = new Uint8Array(0);
                const createTxRes = await this.api.post(`tx`, tx);
                if (!(createTxRes.status >= 200 && createTxRes.status < 300)) {
                    throw new Error(`Failed to create transaction: status ${createTxRes.status} / data ${createTxRes.data}`);
                }
            }
            const txChunkData = tx.chunks;
            const { chunks, proofs } = txChunkData;
            function prepareChunkUploadPayload(chunkIndex, chunkData) {
                const proof = proofs[chunkIndex];
                return {
                    data_root: tx.data_root,
                    data_size: tx.data_size,
                    data_path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["bufferTob64Url"])(proof.proof),
                    offset: proof.offset.toString(),
                    chunk: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["bufferTob64Url"])(chunkData)
                };
            }
            log(`Starting pipe - MAX_CHUNK_SIZE=${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$merkle$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_CHUNK_SIZE"]}`);
            await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$stream$2f$promises__$5b$external$5d$__$28$stream$2f$promises$2c$__cjs$29$__["pipeline"])(source, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$node$2f$stream$2f$chunker$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["chunker"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$merkle$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MAX_CHUNK_SIZE"], {
                flush: true
            }), async (chunkedSource)=>{
                let chunkIndex = 0;
                let dataRebalancedIntoFinalChunk;
                const activeChunkUploads = [];
                for await (const chunkData of chunkedSource){
                    const currentChunk = chunks[chunkIndex];
                    const chunkSize = currentChunk.maxByteRange - currentChunk.minByteRange;
                    log(`Got chunk - ${chunkData.byteLength} bytes / chunkSize ${chunkSize}`);
                    const expectedToBeFinalRebalancedChunk = dataRebalancedIntoFinalChunk != null;
                    let chunkPayload;
                    if (chunkData.byteLength === chunkSize) {
                        // If the transaction data chunks was never rebalanced this is the only code path that
                        // will execute as the incoming chunked data as the will always be equivalent to `chunkSize`.
                        chunkPayload = prepareChunkUploadPayload(chunkIndex, chunkData);
                    } else if (chunkData.byteLength > chunkSize) {
                        // If the incoming chunk data is larger than the expected size of the current chunk
                        // it means that the transaction had chunks that were rebalanced to meet the minimum chunk size.
                        //
                        // It also means that the chunk we're currently processing should be the second to last
                        // chunk.
                        chunkPayload = prepareChunkUploadPayload(chunkIndex, chunkData.slice(0, chunkSize));
                        dataRebalancedIntoFinalChunk = chunkData.slice(chunkSize);
                    } else if (chunkData.byteLength < chunkSize && expectedToBeFinalRebalancedChunk) {
                        // If this is the final rebalanced chunk, create the upload payload by concatenating the previous
                        // chunk's data that was moved into this and the remaining stream data.
                        chunkPayload = prepareChunkUploadPayload(chunkIndex, Buffer.concat([
                            dataRebalancedIntoFinalChunk,
                            chunkData
                        ], dataRebalancedIntoFinalChunk.length + chunkData.length));
                    } else {
                        throw Error("Transaction data stream terminated incorrectly.");
                    }
                    const chunkValid = await this.merkle.validatePath(txChunkData.data_root, parseInt(chunkPayload.offset), 0, parseInt(chunkPayload.data_size), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["b64UrlToBuffer"])(chunkPayload.data_path));
                    if (!chunkValid) {
                        throw new Error(`Unable to validate chunk ${chunkIndex}.`);
                    }
                    // Upload multiple transaction chunks in parallel to speed up the upload.
                    // If we are already at the maximum concurrent chunk upload limit,
                    // wait till all of them to complete first before continuing.
                    if (activeChunkUploads.length >= MAX_CONCURRENT_CHUNK_UPLOAD_COUNT) {
                        await Promise.all(activeChunkUploads);
                        // Clear the active chunk uploads array.
                        activeChunkUploads.length = 0;
                    }
                    // TODO: allow for this abort code behaviour
                    activeChunkUploads.push(this.api.post("chunk", chunkPayload, {
                        retry: {
                            onRetry: (err)=>!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$transaction$2d$uploader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FATAL_CHUNK_UPLOAD_ERRORS"].includes(err.message)
                        }
                    }));
                    chunkIndex++;
                    log(`Chunk process done - ${chunkIndex}`);
                }
                log(`Active chunks to upload - ${activeChunkUploads.length}`);
                await Promise.all(activeChunkUploads);
                if (chunkIndex < chunks.length) {
                    throw Error(`Transaction upload incomplete: ${chunkIndex + 1}/${chunks.length} chunks uploaded.`);
                }
            }).catch((e)=>{
                log(e.message);
                throw e;
            });
        };
    }
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/node/arweave.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Arweave": ()=>Arweave,
    "NodeArweave": ()=>NodeArweave,
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$arweave$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__Arweave__as__default$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/arweave.js [app-route] (ecmascript) <export Arweave as default>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$node$2f$node$2d$driver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/node/node-driver.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$node$2f$stream$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/node/stream/index.js [app-route] (ecmascript)");
;
;
;
class Arweave extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$arweave$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__Arweave__as__default$3e$__["default"] {
    stream;
    /**
     * Constructor for a new `Arweave` instance - this one uses the node crypto driver
     * @param gateways - Specify the Arweave gateway(s) you want to use for requests
     * @param options - Other configuration options
     * @param options.miners - A list of Arweave miners (peers) to use for requests
     * @param options.gateways - A list of Arweave miners (peers) to use for requests
     */ constructor(gateways, options){
        super({
            crypto: options?.crypto ?? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$node$2f$node$2d$driver$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](),
            ...options,
            gateways: gateways ?? "https://arweave.net"
        });
        this.stream = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$node$2f$stream$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Stream"]({
            deps: {
                crypto: this.crypto,
                api: this.api,
                merkle: this.merkle,
                transactions: this.transactions,
                deepHash: this.deepHash
            }
        });
    }
    static init(apiConfig) {
        return new Arweave(apiConfig);
    }
}
const NodeArweave = Arweave;
const __TURBOPACK__default__export__ = Arweave;
 //# sourceMappingURL=arweave.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/node/index.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$node$2f$arweave$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/node/arweave.js [app-route] (ecmascript)");
;
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@irys/arweave/build/esm/node/index.js [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$node$2f$arweave$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/node/arweave.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$node$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/node/index.js [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@irys/arweave/build/esm/node/arweave.js [app-route] (ecmascript) <export default as Arweave>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Arweave": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$node$2f$arweave$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$node$2f$arweave$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/node/arweave.js [app-route] (ecmascript)");
}),

};

//# sourceMappingURL=node_modules_%40irys_arweave_build_esm_b669ab46._.js.map
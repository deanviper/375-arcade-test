module.exports = {

"[project]/node_modules/@irys/upload-core/dist/esm/hack.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// crypto hack - this is to stop arweave-js's import time(!!!) check for `subtleCrypto` - which occurs if you try to use the root import of this SDK.
__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
const hack = ()=>{
    throw new Error(`Unimplemented`);
};
// @ts-expect-error hack
globalThis.crypto ??= {};
// @ts-expect-error hack
globalThis.crypto.subtle ??= {};
// @ts-expect-error hack
globalThis.crypto.subtle.generateKey ??= hack;
// @ts-expect-error hack
globalThis.crypto.subtle.importKey ??= hack;
// @ts-expect-error hack
globalThis.crypto.subtle.exportKey ??= hack;
// @ts-expect-error hack
globalThis.crypto.subtle.digest ??= hack;
// @ts-expect-error hack
globalThis.crypto.subtle.sign ??= hack;
const __TURBOPACK__default__export__ = hack;
 //# sourceMappingURL=hack.js.map
}),
"[project]/node_modules/@irys/upload-core/dist/esm/transaction.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>buildIrysTransaction
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
;
function buildIrysTransaction(irys) {
    class IrysTransaction extends irys.bundles.DataItem {
        Irys;
        signer;
        constructor(data, irys, opts){
            super(opts?.dataIsRawTransaction === true ? Buffer.from(data) : irys.bundles.createData(data, irys.tokenConfig.getSigner(), {
                ...opts,
                anchor: opts?.anchor ?? __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].randomBytes(32).toString('base64').slice(0, 32)
            }).getRaw());
            this.Irys = irys;
            this.signer = irys.tokenConfig.getSigner();
        }
        sign() {
            return super.sign(this.signer);
        }
        get size() {
            return this.getRaw().length;
        }
        /**
         * @deprecated use upload
         */ async uploadWithReceipt(opts) {
            return (await this.Irys.uploader.uploadTransaction(this, opts)).data;
        }
        async upload(opts) {
            return (await this.Irys.uploader.uploadTransaction(this, opts)).data;
        }
        // static fromRaw(rawTransaction: Buffer, IrysInstance: Irys): IrysTransaction {
        //   return new IrysTransaction(rawTransaction, IrysInstance, { dataIsRawTransaction: true });
        // }
        async getPrice() {
            return this.Irys.utils.getPrice(this.Irys.tokenConfig.name, this.size, {
                tags: this.tags
            });
        }
        async isValid() {
            return irys.bundles.DataItem.verify(this.getRaw());
        }
    }
    return IrysTransaction;
} // export abstract class IrysTransaction extends DataItem {}
 // export interface IrysTransaction extends DataItem {
 //   size: number;
 //   uploadWithReceipt(opts?: UploadOptions): Promise<UploadReceipt>;
 //   upload(opts: UploadOptions & { getReceiptSignature: true }): Promise<UploadReceipt>;
 //   upload(opts?: UploadOptions): Promise<UploadResponse>;
 // }
 //# sourceMappingURL=transaction.js.map
}),
"[project]/node_modules/@irys/upload-core/dist/esm/utils.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Utils": ()=>Utils,
    "default": ()=>__TURBOPACK__default__export__,
    "erc20abi": ()=>erc20abi,
    "httpErrData": ()=>httpErrData,
    "sleep": ()=>sleep
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64url$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/base64url/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bignumber.js/bignumber.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$async$2d$retry$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/async-retry/lib/index.js [app-route] (ecmascript)");
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].set({
    DECIMAL_PLACES: 50
});
const sleep = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));
const httpErrData = (res)=>typeof res.data !== 'string' ? res.statusText : res.data;
class Utils {
    api;
    token;
    tokenConfig;
    bundles;
    constructor(api, token, tokenConfig){
        this.api = api;
        this.token = token;
        this.tokenConfig = tokenConfig;
        this.bundles = this.tokenConfig.irys.bundles;
    }
    /**
     * Throws an error if the provided axios reponse has a status code != 200
     * @param res an axios response
     * @returns nothing if the status code is 200
     */ static checkAndThrow(res, context, exceptions) {
        if (res?.status && !(exceptions ?? []).includes(res.status) && res.status != 200) {
            throw new Error(`HTTP Error: ${context}: ${res.status} ${typeof res.data !== 'string' ? res.statusText : res.data}`);
        }
        return;
    }
    /**
     * Gets the nonce used for withdrawal request validation from the bundler
     * @returns nonce for the current user
     */ async getNonce() {
        const res = await this.api.get(`/account/withdrawals/${this.tokenConfig.name}?address=${this.tokenConfig.address}`);
        Utils.checkAndThrow(res, 'Getting withdrawal nonce');
        return res.data;
    }
    /**
     * Gets the balance on the current bundler for the specified user
     * @param address the user's address to query
     * @returns the balance in winston
     */ async getBalance(address) {
        const res = await this.api.get(`/account/balance/${this.tokenConfig.name}?address=${address}`);
        Utils.checkAndThrow(res, 'Getting balance');
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](res.data.balance);
    }
    /**
     * Queries the bundler to get it's address for a specific token
     * @returns the bundler's address
     */ async getBundlerAddress(token) {
        const res = await this.api.get('/info');
        Utils.checkAndThrow(res, 'Getting Bundler address');
        const address = res.data.addresses[token ?? this.token];
        if (!address) {
            throw new Error(`Specified bundler does not support token ${token}`);
        }
        return address;
    }
    /**
     * Calculates the price for [bytes] bytes paid for with [token] for the loaded Irys node.
     * @param token
     * @param bytes
     * @returns
     */ async getPrice(token, bytes, opts) {
        let path = `/price/${token}/${bytes}`;
        if (opts?.tags) {
            const address = opts.address ?? this.tokenConfig.address;
            path = opts.tags.reduce((b, t)=>b + `&tags=${t.name}|${t.value}`, path + `?address=${address}`);
        } else if (opts?.address) {
            path = path + `?address=${opts?.address}`;
        }
        const res = await this.api.get(path);
        Utils.checkAndThrow(res, 'Getting storage cost');
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](res.data);
    }
    /**
     * This function *estimates* the cost in atomic units for uploading a given set of files
     * note: this function becomes less accurate the smaller your transactions, unless you provide it with an accurate headerSizeAvg
     * @param folderInfo either an array of file sizes in bytes, or an object containing the total number of files and the sum total size of the files in bytes
     * note: for a more precise estimate, you can create an empty (dataless) transaction (make sure you still set tags and other metadata!) and then pass `tx.size` as `headerSizeAvg`
     */ async estimateFolderPrice(folderInfo) {
        if (Array.isArray(folderInfo)) {
            folderInfo = {
                fileCount: folderInfo.length,
                totalBytes: folderInfo.reduce((acc, v)=>acc + v, 0)
            };
        }
        // create a 0 data byte tx to estimate the per tx header overhead
        const headerSizeAvg = folderInfo.headerSizeAvg ?? this.bundles.createData('', this.tokenConfig.getSigner()).getRaw().length;
        const pricePerTxBase = await this.getPrice(this.tokenConfig.name, headerSizeAvg);
        const basePriceForTxs = pricePerTxBase.multipliedBy(folderInfo.fileCount);
        const priceForData = (await this.getPrice(this.tokenConfig.name, folderInfo.totalBytes)).plus(basePriceForTxs).decimalPlaces(0);
        return priceForData;
    }
    /**
     * Returns the decimal values' equivalent in atomic units
     * @example
     * 0.1 ETH -> 100,000,000,000,000,000 wei
     * ```
     * toAtomic(100_000_000_000_000_000) -> 0.1
     * ```
     * @param decimalAmount - amount in decimal
     * @returns amount in atomic units
     */ toAtomic(decimalAmount) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](decimalAmount).multipliedBy(this.tokenConfig.base[1]);
    }
    /**
     * Returns the atomic amounts' equivalent in decimal units
     * @example
     * 100,000,000,000,000,000 wei -> 0.1 ETH
     * ```
     * fromAtomic(0.1) -> 100_000_000_000_000_000
     * ```
     * @param atomicAmount
     * @returns
     */ fromAtomic(atomicAmount) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](atomicAmount).dividedBy(this.tokenConfig.base[1]);
    }
    /**
     * Polls for transaction confirmation (or at least pending status) - used for fast currencies
     * before posting the fund request to the server (so the server doesn't have to poll)
     * @param txid
     * @returns
     */ async confirmationPoll(txid, seconds = 30) {
        if (this.tokenConfig.isSlow) return;
        if (seconds < 0) seconds = 0;
        let lastError;
        let timedout = false;
        let timedOutConfirmedButPending = false;
        const internalPoll = async ()=>{
            while(!timedout){
                const getRes = await this.tokenConfig.getTx(txid).then((v)=>{
                    if (v?.confirmed && !v?.pending) return true;
                    if (v?.confirmed && v?.pending) timedOutConfirmedButPending = true;
                    return false;
                }).catch((err)=>{
                    lastError = err;
                    return false;
                });
                if (getRes) return true;
                await sleep(1000);
            }
            return false;
        };
        const racer = async ()=>{
            await sleep(seconds * 1_000);
            timedout = true;
            return 'RACE';
        };
        const r = await Promise.race([
            racer(),
            internalPoll()
        ]);
        if (r === 'RACE') {
            // for now we failsafe
            if (timedOutConfirmedButPending) return true;
            console.warn(`Tx ${txid} didn't finalize after ${seconds} seconds ${lastError ? ` - ${lastError}` : ''}`);
            return lastError;
        }
        return r;
    }
    /**
     * @deprecated this method is deprecated in favour of fromAtomic - removal slated for 0.12.0
     */ unitConverter(baseUnits) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](baseUnits).dividedBy(this.tokenConfig.base[1]);
    }
    async verifyReceipt(receipt) {
        return Utils.verifyReceipt(this.bundles, receipt);
    }
    static async verifyReceipt(dependencies, receipt) {
        const { id, deadlineHeight, timestamp, public: pubKey, signature, version } = receipt;
        const dh = await dependencies.deepHash([
            dependencies.stringToBuffer('Bundlr'),
            dependencies.stringToBuffer(version),
            dependencies.stringToBuffer(id),
            dependencies.stringToBuffer(deadlineHeight.toString()),
            dependencies.stringToBuffer(timestamp.toString())
        ]);
        return await dependencies.getCryptoDriver().verify(pubKey, dh, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64url$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].toBuffer(signature));
    }
    async getReceipt(txId) {
        // get receipt information from GQL
        const query = `query {
      transactions(ids: ["${txId}"]) {
        edges {
          node {
            receipt {
              signature
              timestamp
              version
              deadlineHeight
            }
          }
        }
      }
    }`;
        const queryRes = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$async$2d$retry$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(async ()=>{
            return await this.api.post('/graphql', {
                query
            }, {
                headers: {
                    'content-type': 'application/json'
                },
                validateStatus: (s)=>s === 200
            });
        });
        const receiptData = queryRes?.data?.data?.transactions?.edges?.at(0)?.node?.receipt;
        if (!receiptData) throw new Error(`Missing required receipt data from node for tx: ${txId}`);
        // get public key from node
        const pubKey = (await this.api.get('/public')).data;
        const receipt = {
            public: pubKey,
            version: receiptData.version,
            id: txId,
            timestamp: receiptData.timestamp,
            validatorSignatures: [],
            signature: receiptData.signature,
            deadlineHeight: receiptData.deadlineHeight,
            // use stub to conform to type
            verify: async ()=>{
                return false;
            }
        };
        // inject method
        receipt.verify = async ()=>this.verifyReceipt(receipt);
        return receipt;
    }
}
const __TURBOPACK__default__export__ = Utils;
const erc20abi = [
    {
        constant: true,
        inputs: [],
        name: 'name',
        outputs: [
            {
                name: '',
                type: 'string'
            }
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function'
    },
    {
        constant: false,
        inputs: [
            {
                name: '_spender',
                type: 'address'
            },
            {
                name: '_value',
                type: 'uint256'
            }
        ],
        name: 'approve',
        outputs: [
            {
                name: '',
                type: 'bool'
            }
        ],
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function'
    },
    {
        constant: true,
        inputs: [],
        name: 'totalSupply',
        outputs: [
            {
                name: '',
                type: 'uint256'
            }
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function'
    },
    {
        constant: false,
        inputs: [
            {
                name: '_from',
                type: 'address'
            },
            {
                name: '_to',
                type: 'address'
            },
            {
                name: '_value',
                type: 'uint256'
            }
        ],
        name: 'transferFrom',
        outputs: [
            {
                name: '',
                type: 'bool'
            }
        ],
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function'
    },
    {
        constant: true,
        inputs: [],
        name: 'decimals',
        outputs: [
            {
                name: '',
                type: 'uint8'
            }
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function'
    },
    {
        constant: true,
        inputs: [
            {
                name: '_owner',
                type: 'address'
            }
        ],
        name: 'balanceOf',
        outputs: [
            {
                name: 'balance',
                type: 'uint256'
            }
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function'
    },
    {
        constant: true,
        inputs: [],
        name: 'symbol',
        outputs: [
            {
                name: '',
                type: 'string'
            }
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function'
    },
    {
        constant: false,
        inputs: [
            {
                name: '_to',
                type: 'address'
            },
            {
                name: '_value',
                type: 'uint256'
            }
        ],
        name: 'transfer',
        outputs: [
            {
                name: '',
                type: 'bool'
            }
        ],
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function'
    },
    {
        constant: true,
        inputs: [
            {
                name: '_owner',
                type: 'address'
            },
            {
                name: '_spender',
                type: 'address'
            }
        ],
        name: 'allowance',
        outputs: [
            {
                name: '',
                type: 'uint256'
            }
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function'
    },
    {
        payable: true,
        stateMutability: 'payable',
        type: 'fallback'
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: 'owner',
                type: 'address'
            },
            {
                indexed: true,
                name: 'spender',
                type: 'address'
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256'
            }
        ],
        name: 'Approval',
        type: 'event'
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: 'from',
                type: 'address'
            },
            {
                indexed: true,
                name: 'to',
                type: 'address'
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256'
            }
        ],
        name: 'Transfer',
        type: 'event'
    }
]; //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@irys/upload-core/dist/esm/withdrawal.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "withdrawBalance": ()=>withdrawBalance
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/utils.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bignumber.js/bignumber.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64url$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/base64url/index.js [app-route] (ecmascript)");
;
;
;
async function withdrawBalance(utils, api, amount) {
    const c = utils.tokenConfig;
    const { deepHash, stringToBuffer } = c.irys.bundles;
    const pkey = await c.getPublicKey();
    const withdrawAll = amount === 'all';
    const data = {
        publicKey: pkey,
        currency: utils.token,
        amount: withdrawAll ? 'all' : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](amount).toString(),
        nonce: await utils.getNonce(),
        signature: '',
        sigType: c.getSigner().signatureType
    };
    const deephash = await deepHash([
        stringToBuffer(data.currency),
        stringToBuffer(data.amount.toString()),
        stringToBuffer(data.nonce.toString())
    ]);
    if (!Buffer.isBuffer(data.publicKey)) {
        data.publicKey = Buffer.from(data.publicKey);
    }
    const signature = await c.sign(deephash);
    const isValid = await c.verify(data.publicKey, deephash, signature);
    data.publicKey = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64url$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].encode(data.publicKey);
    data.signature = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64url$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].encode(Buffer.from(signature));
    const cpk = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64url$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].toBuffer(data.publicKey);
    const csig = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64url$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].toBuffer(data.signature);
    // should match opk and csig
    const dh2 = await deepHash([
        stringToBuffer(data.currency),
        stringToBuffer(data.amount.toString()),
        stringToBuffer(data.nonce.toString())
    ]);
    const isValid2 = await c.verify(cpk, dh2, csig);
    const isValid3 = await c.ownerToAddress(c.name == 'arweave' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64url$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].decode(data.publicKey) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64url$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].toBuffer(data.publicKey)) === c.address;
    if (!(isValid || isValid2 || isValid3)) {
        throw new Error(`Internal withdrawal validation failed - please report this!\nDebug Info:${JSON.stringify(data)}`);
    }
    const res = await api.post('/account/withdraw', data);
    if (res.status === 202) {
        // node has timed/erroed out confirming the withdrawal
        const txId = res.data.tx_id;
        const withdrawalConfirmed = await utils.confirmationPoll(txId);
        if (!(withdrawalConfirmed === true)) throw new Error(`Unable to confirm withdrawal tx ${txId} ${withdrawalConfirmed ? withdrawalConfirmed?.toString() : ''}`);
    } else {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].checkAndThrow(res, 'Withdrawing balance');
    }
    return res.data;
} //# sourceMappingURL=withdrawal.js.map
}),
"[project]/node_modules/@irys/upload-core/dist/esm/irys.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Irys": ()=>Irys,
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/transaction.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/utils.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$withdrawal$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/withdrawal.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$query$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__Query__as__default$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/query.js [app-route] (ecmascript) <export Query as default>");
;
;
;
;
class Irys {
    api;
    utils;
    uploader;
    funder;
    _address;
    token;
    tokenConfig;
    transactions;
    approval;
    _readyPromise;
    url;
    bundles;
    IrysTransaction;
    static VERSION = 'REPLACEMEIRYSVERSION';
    debug = false;
    constructor({ url, bundles }){
        switch(url){
            case 'mainnet':
                url = 'https://uploader.irys.xyz';
                break;
            case 'devnet':
                url = 'https://devnet.irys.xyz';
                break;
        }
        if (!url) throw new Error(`Missing required Irys constructor parameter: URL or valid Network`);
        const parsed = new URL(url);
        // if(parsed.host.startsWith("node1") || parsed.host.includes("arweave")) throw new Error("")
        this.url = parsed;
        this.bundles = bundles;
        this.IrysTransaction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this);
    }
    get address() {
        if (!this._address) throw new Error('Address is undefined, please provide a wallet or run `await irys.ready()`');
        return this._address;
    }
    set address(address) {
        this._address = address;
    }
    get signer() {
        return this.tokenConfig.getSigner();
    }
    async withdrawBalance(amount) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$withdrawal$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withdrawBalance"])(this.utils, this.api, amount);
    }
    async withdrawAll() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$withdrawal$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["withdrawBalance"])(this.utils, this.api, 'all');
    }
    /**
     * @deprecated Use getBalance with no address instead.
     *
     * Gets the balance for the loaded wallet
     * @returns balance (in winston)
     */ async getLoadedBalance() {
        if (!this.address) throw new Error('address is undefined');
        return this.utils.getBalance(this.address);
    }
    /**
     * Gets the balance for the specified address
     * @param address address to query for
     * @returns the balance (in winston)
     */ async getBalance(address) {
        if (address) return this.utils.getBalance(address);
        if (!this.address) throw new Error('address is undefined');
        return this.utils.getBalance(this.address);
    }
    /**
     * Sends amount atomic units to the specified bundler
     * @param amount amount to send in atomic units
     * @returns details about the fund transaction
     */ async fund(amount, multiplier) {
        return this.funder.fund(amount, multiplier);
    }
    /**
     * Calculates the price for [bytes] bytes for the loaded token and Irys node.
     * @param bytes
     * @returns
     */ async getPrice(bytes, opts) {
        return this.utils.getPrice(this.token, bytes, opts);
    }
    async verifyReceipt(receipt) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].verifyReceipt(this.bundles, receipt);
    }
    /**
     * Create a new IrysTransactions (flex token bundles dataItem)
     * @param data
     * @param opts - dataItemCreateOptions
     * @returns - a new IrysTransaction instance
     */ createTransaction(data, opts) {
        return new this.IrysTransaction(data, this, opts);
    }
    /**
     * Returns the signer for the loaded token
     */ getSigner() {
        return this.tokenConfig.getSigner();
    }
    async upload(data, opts) {
        return this.uploader.uploadData(data, opts);
    }
    /**
     * @deprecated - use upload instead
     */ async uploadWithReceipt(data, opts) {
        return this.uploader.uploadData(data, {
            ...opts
        });
    }
    async ready() {
        this.tokenConfig.ready ? await this.tokenConfig.ready() : true;
        this.address = this.tokenConfig.address;
        return this;
    }
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    get transaction() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const oThis = this;
        return {
            fromRaw (rawTransaction) {
                return new oThis.IrysTransaction(rawTransaction, oThis, {
                    dataIsRawTransaction: true
                });
            }
        };
    }
    get search() {
        const q = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$query$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__Query__as__default$3e$__["default"]({
            url: new URL('/graphql', this.url)
        });
        return q.search.bind(q);
    }
    query(queryOpts) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$query$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__Query__as__default$3e$__["default"](queryOpts ?? {
            url: new URL('graphql', this.url)
        });
    }
}
const __TURBOPACK__default__export__ = Irys;
 //# sourceMappingURL=irys.js.map
}),
"[project]/node_modules/@irys/upload-core/dist/esm/api.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Api": ()=>Api,
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/axios/lib/axios.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$irys$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/irys.js [app-route] (ecmascript)");
;
;
class Api {
    _instance;
    cookieMap = new Map();
    config;
    constructor(config){
        if (config) this.applyConfig(config);
    }
    applyConfig(config) {
        this.config = this.mergeDefaults(config);
        this._instance = undefined;
    }
    getConfig() {
        return this.config;
    }
    async requestInterceptor(request) {
        const cookies = this.cookieMap.get(new URL(request.baseURL ?? '').hostname);
        if (cookies) request.headers.cookie = cookies;
        return request;
    }
    async responseInterceptor(response) {
        const setCookie = response.headers?.['set-cookie'];
        if (setCookie) this.cookieMap.set(response.request.host, setCookie);
        return response;
    }
    mergeDefaults(config) {
        return {
            url: config.url,
            timeout: config.timeout ?? 20000,
            logging: config.logging ?? false,
            logger: config.logger ?? console.log,
            headers: {
                ...config.headers,
                'x-irys-js-sdk-version': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$irys$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].VERSION
            },
            withCredentials: config.withCredentials ?? false,
            retry: {
                retries: 3,
                maxTimeout: 5_000
            }
        };
    }
    async get(path, config) {
        try {
            return await this.request(path, {
                ...config,
                method: 'GET'
            });
        } catch (error) {
            if (error.response?.status) return error.response;
            throw error;
        }
    }
    async post(path, body, config) {
        try {
            return await this.request(path, {
                data: body,
                ...config,
                method: 'POST'
            });
        } catch (error) {
            if (error.response?.status) return error.response;
            throw error;
        }
    }
    get instance() {
        if (this._instance) return this._instance;
        const instance = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].create({
            baseURL: this.config.url.toString(),
            timeout: this.config.timeout,
            maxContentLength: 1024 * 1024 * 512,
            headers: this.config.headers,
            withCredentials: this.config.withCredentials
        });
        if (this.config.withCredentials) {
            instance.interceptors.request.use(this.requestInterceptor.bind(this));
            instance.interceptors.response.use(this.responseInterceptor.bind(this));
        }
        if (this.config.logging) {
            instance.interceptors.request.use((request)=>{
                this.config.logger(`Requesting: ${request.baseURL}/${request.url}`);
                return request;
            });
            instance.interceptors.response.use((response)=>{
                this.config.logger(`Response: ${response.config.url} - ${response.status}`);
                return response;
            });
        }
        return this._instance = instance;
    }
    async request(path, config) {
        const instance = this.instance;
        const url = config?.url ?? new URL(path, this.config.url).toString();
        // return AsyncRetry((_) => instance({ ...config, url }), {
        //   ...this.config.retry,
        //   ...config?.retry,
        // });
        return instance({
            ...config,
            url
        });
    }
}
const __TURBOPACK__default__export__ = Api;
 // /**
 //  * *** To be removed when browsers catch up with the whatwg standard. ***
 //  * [Symbol.AsyncIterator] is needed to use `for-await` on the returned ReadableStream (web stream).
 //  * Feature is available in nodejs, and should be available in browsers eventually.
 //  */
 // export const addAsyncIterator = (body: ReadableStream): ReadableStream => {
 //   const bodyWithIter = body as ReadableStream<Uint8Array> & AsyncIterable<Uint8Array>;
 //   if (typeof bodyWithIter[Symbol.asyncIterator] === "undefined") {
 //     bodyWithIter[Symbol.asyncIterator] = webIiterator<Uint8Array>(body);
 //     return bodyWithIter;
 //   }
 //   return body;
 // };
 // const webIiterator = function <T>(stream: ReadableStream): () => AsyncGenerator<Awaited<T>, void> {
 //   return async function* iteratorGenerator<T>() {
 //     const reader = stream.getReader(); // lock
 //     try {
 //       while (true) {
 //         const { done, value } = await reader.read();
 //         if (done) return;
 //         yield value as T;
 //       }
 //     } finally {
 //       reader.releaseLock(); // unlock
 //     }
 //   };
 // };
 //# sourceMappingURL=api.js.map
}),
"[project]/node_modules/@irys/upload-core/dist/esm/approval.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Approval": ()=>Approval,
    "UploadApprovalMetaTags": ()=>UploadApprovalMetaTags,
    "UploadApprovalTags": ()=>UploadApprovalTags
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/utils.js [app-route] (ecmascript)");
;
class Approval {
    irys;
    constructor(irys){
        this.irys = irys;
    }
    async getApprovals({ payingAddresses, tokens = [
        this.irys.token
    ], approvedAddresses = [
        this.irys.address
    ] }) {
        return this.queryApproval.payingAddresses(payingAddresses).tokens(tokens).approvedAddresses(approvedAddresses);
    }
    async getCreatedApprovals({ payingAddresses = [
        this.irys.address
    ], tokens = [
        this.irys.token
    ], approvedAddresses }) {
        return this.queryApproval.payingAddresses(payingAddresses).tokens(tokens).approvedAddresses(approvedAddresses);
    }
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    get queryApproval() {
        return this.irys.query().search('irys:paymentApprovals');
    }
    async getApproval({ payingAddress = this.irys.address, token = this.irys.token, approvedAddress }) {
        const res = await this.irys.api.get('/account/approval', {
            params: {
                payingAddress,
                token,
                approvedAddress
            }
        });
        if (res.status === 404) return {
            amount: '0'
        };
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].checkAndThrow(res);
        return res.data;
    }
    async getApprovedBalanceFrom(payingAddress) {
        if (!payingAddress) throw new Error('Paying address is required');
        return await this.getApproval({
            payingAddress,
            approvedAddress: this.irys.address,
            token: this.irys.token
        });
    }
    async createApproval({ approvedAddress, amount, expiresInSeconds }) {
        const tags = [
            {
                name: UploadApprovalTags.APPROVE_PAYMENT,
                value: approvedAddress
            },
            {
                name: UploadApprovalMetaTags.AMOUNT,
                value: amount.toString()
            }
        ];
        if (expiresInSeconds) tags.push({
            name: UploadApprovalMetaTags.EXPIRE_SECONDS,
            value: expiresInSeconds.toString()
        });
        return await this.irys.upload('', {
            tags
        });
    }
    async revokeApproval({ approvedAddress }) {
        const tags = [
            {
                name: UploadApprovalTags.DELETE_APPROVAL,
                value: approvedAddress
            }
        ];
        return await this.irys.upload('', {
            tags
        });
    }
}
var UploadApprovalTags;
(function(UploadApprovalTags) {
    UploadApprovalTags["APPROVE_PAYMENT"] = "x-irys-approve-payment";
    UploadApprovalTags["DELETE_APPROVAL"] = "x-irys-delete-payment-approval";
})(UploadApprovalTags || (UploadApprovalTags = {}));
var UploadApprovalMetaTags;
(function(UploadApprovalMetaTags) {
    UploadApprovalMetaTags["AMOUNT"] = "x-amount";
    UploadApprovalMetaTags["EXPIRE_SECONDS"] = "x-expire-seconds";
})(UploadApprovalMetaTags || (UploadApprovalMetaTags = {})); //# sourceMappingURL=approval.js.map
}),
"[project]/node_modules/@irys/upload-core/dist/esm/types.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "UploadHeaders": ()=>UploadHeaders
});
var UploadHeaders;
(function(UploadHeaders) {
    UploadHeaders["PAID_BY"] = "x-irys-paid-by";
})(UploadHeaders || (UploadHeaders = {})); //# sourceMappingURL=types.js.map
}),
"[project]/node_modules/@irys/upload-core/dist/esm/s2ai.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "STATES": ()=>STATES,
    "default": ()=>StreamToAsyncIterator
});
const NOT_READABLE = Symbol('not readable');
const READABLE = Symbol('readable');
const ENDED = Symbol('ended');
const ERRORED = Symbol('errored');
const STATES = {
    notReadable: NOT_READABLE,
    readable: READABLE,
    ended: ENDED,
    errored: ERRORED
};
class StreamToAsyncIterator {
    /** The underlying readable stream */ _stream;
    /** Contains stream's error when stream has error'ed out */ _error;
    /** The current state of the iterator (not readable, readable, ended, errored) */ _state = STATES.notReadable;
    _size;
    /** The rejections of promises to call when stream errors out */ _rejections = new Set();
    get closed() {
        return this._state === STATES.ended;
    }
    constructor(stream, { size } = {}){
        this._stream = stream;
        this._size = size;
        const bindMethods = [
            '_handleStreamEnd',
            '_handleStreamError'
        ];
        for (const method of bindMethods){
            Object.defineProperty(this, method, {
                configurable: true,
                writable: true,
                value: this[method].bind(this)
            });
        }
        // eslint-disable-next-line @typescript-eslint/unbound-method
        stream.once('error', this._handleStreamError);
        // eslint-disable-next-line @typescript-eslint/unbound-method
        stream.once('end', this._handleStreamEnd);
        stream.on('readable', ()=>{
            this._state = STATES.readable;
        });
    }
    [Symbol.asyncIterator]() {
        return this;
    }
    /**
     * Returns the next iteration of data. Rejects if the stream errored out.
     */ async next() {
        switch(this._state){
            case STATES.notReadable:
                {
                    let untilReadable;
                    let untilEnd;
                    try {
                        untilReadable = this._untilReadable();
                        untilEnd = this._untilEnd();
                        await Promise.race([
                            untilReadable.promise,
                            untilEnd.promise
                        ]);
                    } finally{
                        // need to clean up any hanging event listeners
                        if (untilReadable != null) {
                            untilReadable.close();
                        }
                        if (untilEnd != null) {
                            untilEnd.close();
                        }
                    }
                    return this.next();
                }
            case STATES.ended:
                {
                    this.close();
                    return {
                        done: true,
                        value: undefined
                    };
                }
            case STATES.errored:
                {
                    this.close();
                    throw this._error;
                }
            case STATES.readable:
                {
                    // stream.read returns null if not readable or when stream has ended
                    // todo: Could add a way to ensure data-type/shape of reads to make this type safe
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                    const data = this._size ? this._stream.read(this._size) : this._stream.read();
                    if (data !== null) {
                        return {
                            done: false,
                            value: data
                        };
                    } else {
                        // we're no longer readable, need to find out what state we're in
                        this._state = STATES.notReadable;
                        // need to let event loop run to fill stream buffer
                        await new Promise((r)=>setTimeout((r)=>r(true), 0, r));
                        return this.next();
                    }
                }
        }
    }
    /**
     * Waits until the stream is readable. Rejects if the stream errored out.
     * @returns Promise when stream is readable
     */ _untilReadable() {
        // let is used here instead of const because the exact reference is
        // required to remove it, this is why it is not a curried function that
        // accepts resolve & reject as parameters.
        let handleReadable = undefined;
        const promise = new Promise((resolve, reject)=>{
            handleReadable = ()=>{
                this._state = STATES.readable;
                this._rejections.delete(reject);
                resolve();
            };
            if (this._state === STATES.readable) handleReadable; // race condition guard
            this._stream.once('readable', handleReadable);
            this._rejections.add(reject);
        });
        const cleanup = ()=>{
            if (handleReadable != null) {
                this._stream.removeListener('readable', handleReadable);
            }
        };
        return {
            close: cleanup,
            promise
        };
    }
    /**
     * Waits until the stream is ended. Rejects if the stream errored out.
     * @returns Promise when stream is finished
     */ _untilEnd() {
        let handleEnd = undefined;
        const promise = new Promise((resolve, reject)=>{
            handleEnd = ()=>{
                this._state = STATES.ended;
                this._rejections.delete(reject);
                resolve();
            };
            this._stream.once('end', handleEnd);
            this._rejections.add(reject);
        });
        const cleanup = ()=>{
            if (handleEnd != null) {
                this._stream.removeListener('end', handleEnd);
            }
        };
        return {
            close: cleanup,
            promise
        };
    }
    return() {
        this._state = STATES.ended;
        return this.next();
    }
    throw(err) {
        this._error = err;
        this._state = STATES.errored;
        return this.next();
    }
    /**
     * Destroy the stream
     * @param err An optional error to pass to the stream for an error event
     */ close(err) {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        this._stream.removeListener('end', this._handleStreamEnd);
        // eslint-disable-next-line @typescript-eslint/unbound-method
        this._stream.removeListener('error', this._handleStreamError);
        this._state = STATES.ended;
        this._stream.destroy(err);
    }
    _handleStreamError(err) {
        this._error = err;
        this._state = STATES.errored;
        for (const reject of this._rejections){
            reject(err);
        }
    }
    _handleStreamEnd() {
        this._state = STATES.ended;
    }
    get state() {
        return this._state;
    }
} // export const addAsyncIterator = (body: ReadableStream) => {
 //   const bodyWithIter = body as ReadableStream<Uint8Array> & AsyncIterable<Uint8Array>;
 //   if (typeof bodyWithIter[Symbol.asyncIterator] === "undefined") {
 //     bodyWithIter[Symbol.asyncIterator] = webIiterator<Uint8Array>(body);
 //     return bodyWithIter;
 //   }
 //   return body;
 // };
 // export const webIiterator = function <T>(stream: ReadableStream) {
 //   return async function* iteratorGenerator<T>() {
 //     const reader = stream.getReader(); //lock
 //     try {
 //       const { done, value } = await reader.read();
 //       if (done) return;
 //       yield value as T;
 //     } finally {
 //       reader.releaseLock(); //unlock
 //     }
 //   };
 // };
 //# sourceMappingURL=s2ai.js.map
}),
"[project]/node_modules/@irys/upload-core/dist/esm/chunkingUploader.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ChunkingUploader": ()=>ChunkingUploader
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$events__$5b$external$5d$__$28$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/events [external] (events, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/utils.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$async$2d$retry$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/async-retry/lib/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$s2ai$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/s2ai.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
class ChunkingUploader extends __TURBOPACK__imported__module__$5b$externals$5d2f$events__$5b$external$5d$__$28$events$2c$__cjs$29$__["EventEmitter"] {
    tokenConfig;
    api;
    uploadID;
    token;
    chunkSize;
    batchSize;
    paused = false;
    isResume = false;
    uploadOptions;
    bundles;
    constructor(tokenConfig, api){
        super({
            captureRejections: true
        });
        this.tokenConfig = tokenConfig;
        this.bundles = this.tokenConfig.irys.bundles;
        this.api = api;
        this.token = this.tokenConfig.name;
        this.chunkSize = 25_000_000;
        this.batchSize = 5;
        this.uploadID = '';
    }
    setResumeData(uploadID) {
        if (uploadID) {
            this.uploadID = uploadID;
            this.isResume = true;
        }
        return this;
    }
    /**
     * Note: Will return undefined unless an upload has been started.
     * @returns
     */ getResumeData() {
        return this.uploadID;
    }
    setChunkSize(size) {
        if (size < 1) {
            throw new Error('Invalid chunk size (must be >=1)');
        }
        this.chunkSize = size;
        return this;
    }
    setBatchSize(size) {
        if (size < 1) {
            throw new Error('Invalid batch size (must be >=1)');
        }
        this.batchSize = size;
        return this;
    }
    pause() {
        this.emit('pause');
        this.paused = true;
    }
    resume() {
        this.paused = false;
        this.emit('resume');
    }
    async uploadTransaction(data, opts) {
        this.uploadOptions = opts;
        if (this.bundles.DataItem.isDataItem(data)) {
            return this.runUpload(data.getRaw());
        } else {
            return this.runUpload(data);
        }
    }
    async uploadData(dataStream, options) {
        this.uploadOptions = options?.upload;
        return this.runUpload(dataStream, {
            ...options
        });
    }
    async runUpload(dataStream, transactionOpts) {
        let id = this.uploadID;
        const isTransaction = transactionOpts === undefined;
        const headers = {
            'x-chunking-version': '2'
        };
        let getres;
        if (!id) {
            getres = await this.api.get(`/chunks/${this.token}/-1/-1`, {
                headers
            });
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].checkAndThrow(getres, 'Getting upload token');
            this.uploadID = id = getres.data.id;
        } else {
            getres = await this.api.get(`/chunks/${this.token}/${id}/-1`, {
                headers
            });
            if (getres.status === 404) throw new Error(`Upload ID not found - your upload has probably expired.`);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].checkAndThrow(getres, 'Getting upload info');
            if (this.chunkSize != +getres.data.size) {
                throw new Error(`Chunk size not equal to that of a previous upload (${+getres.data.size}).`);
            }
        }
        const { max, min } = getres.data;
        if (this.chunkSize < +min || this.chunkSize > +max) {
            throw new Error(`Chunk size out of allowed range: ${min} - ${max}`);
        }
        let totalUploaded = 0;
        const promiseFactory = (d, o, c)=>{
            return new Promise((r)=>{
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$async$2d$retry$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(async (bail)=>{
                    await this.api.post(`/chunks/${this.token}/${id}/${o}`, d, {
                        headers: {
                            'Content-Type': 'application/octet-stream',
                            ...headers
                        },
                        maxBodyLength: Infinity,
                        maxContentLength: Infinity
                    }).then((re)=>{
                        if (re?.status >= 300) {
                            const e = {
                                res: re,
                                id: c,
                                offset: o,
                                size: d.length
                            };
                            this.emit('chunkError', e);
                            if (re?.status === 402) {
                                const retryAfterHeader = finishUpload?.headers?.['retry-after'];
                                const errorMsg = '402 error: ' + finishUpload.data + (retryAfterHeader ? ` - retry after ${retryAfterHeader}s` : '');
                                bail(new Error(errorMsg));
                            }
                            throw e;
                        }
                        this.emit('chunkUpload', {
                            id: c,
                            offset: o,
                            size: d.length,
                            totalUploaded: totalUploaded += d.length
                        });
                        r({
                            o,
                            d: re
                        });
                    });
                }), {
                    retries: 3,
                    minTimeout: 1000,
                    maxTimeout: 10_000
                };
            });
        };
        const present = getres.data.chunks ?? [];
        const stream = new __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["PassThrough"]();
        let cache = Buffer.alloc(0);
        let ended = false;
        let hasData = true;
        stream.on('end', ()=>ended = true);
        stream.on('error', (e)=>{
            throw new Error(`Error processing readable: ${e}`);
        });
        // custom as we need to read any number of bytes.
        const readBytes = async (size)=>{
            while(!ended){
                if (cache.length >= size) {
                    data = Buffer.from(cache.slice(0, size)); // force a copy
                    cache = cache.slice(size);
                    return data;
                }
                // eslint-disable-next-line no-var
                var data = stream.read(size);
                if (data === null) {
                    // wait for stream refill (perferred over setImmeadiate due to multi env support)
                    await new Promise((r)=>setTimeout((r)=>r(true), 0, r));
                    continue;
                }
                if (data.length === size) return data;
                cache = Buffer.concat([
                    cache,
                    data
                ]);
            }
            // flush
            while(cache.length >= size){
                data = Buffer.from(cache.slice(0, size)); // force a copy
                cache = cache.slice(size);
                return data;
            }
            hasData = false;
            return cache;
        };
        let tx;
        let txHeaderLength;
        // doesn't matter if we randomise ID (anchor) between resumes, as the tx header/signing info is always uploaded last.
        if (!isTransaction) {
            tx = this.bundles.createData('', this.tokenConfig.getSigner(), {
                ...transactionOpts,
                anchor: transactionOpts?.anchor ?? __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].randomBytes(32).toString('base64').slice(0, 32)
            });
            const raw = tx.getRaw();
            txHeaderLength = raw.length;
            stream.write(raw);
            totalUploaded -= raw.length;
        }
        if (Buffer.isBuffer(dataStream)) {
            stream.write(dataStream);
            stream.end();
        } else if ('pipe' in dataStream) {
            dataStream.pipe(stream);
        } else {
            throw new Error('Input data is not a buffer or a compatible stream (no .pipe method)');
        }
        let offset = 0;
        const processing = new Set();
        let chunkID = 0;
        let heldChunk;
        let teeStream;
        let deephash;
        if (!isTransaction) {
            teeStream = new __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["PassThrough"]();
            const txLength = tx.getRaw().length;
            if (this.chunkSize < txHeaderLength) throw new Error(`Configured chunk size is too small for transaction header! (${this.chunkSize} < ${txHeaderLength})`);
            heldChunk = await readBytes(this.chunkSize);
            chunkID++;
            offset += heldChunk.length;
            teeStream.write(heldChunk.slice(txLength));
            const sigComponents = [
                this.bundles.stringToBuffer('dataitem'),
                this.bundles.stringToBuffer('1'),
                this.bundles.stringToBuffer(tx.signatureType.toString()),
                tx.rawOwner,
                tx.rawTarget,
                tx.rawAnchor,
                tx.rawTags,
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$s2ai$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](teeStream)
            ];
            // do *not* await, this needs to process in parallel to the upload process.
            deephash = this.bundles.deepHash(sigComponents);
        }
        let nextPresent = present.pop();
        // Consume data while there's data to read.
        while(hasData){
            if (this.paused) {
                await new Promise((r)=>this.on('resume', ()=>r(undefined)));
            }
            // do not upload data that's already present
            if (nextPresent) {
                const delta = +nextPresent[0] - offset;
                if (delta <= this.chunkSize) {
                    const bytesToSkip = nextPresent[1];
                    const data = await readBytes(bytesToSkip);
                    if (!isTransaction) teeStream.write(data);
                    offset += bytesToSkip;
                    nextPresent = present.pop();
                    chunkID++;
                    totalUploaded += bytesToSkip;
                    continue;
                }
            }
            const chunk = await readBytes(this.chunkSize);
            if (!isTransaction) teeStream.write(chunk);
            while(processing.size >= this.batchSize){
                // get & then remove resolved promise from processing set
                const [p] = await Promise.race(processing);
                processing.delete(p);
            }
            // @ts-expect-error self-referencing promise
            const promise = (async ()=>await promiseFactory(chunk, offset, ++chunkID))().then((value)=>[
                    promise,
                    value
                ]);
            processing.add(promise);
            offset += chunk.length;
        }
        if (teeStream) teeStream.end();
        await Promise.all(processing);
        if (!isTransaction) {
            const hash = await deephash;
            const sigBytes = Buffer.from(await this.tokenConfig.getSigner().sign(hash));
            heldChunk.set(sigBytes, 2); // tx will be the first part of the held chunk.
            await promiseFactory(heldChunk, 0, 0);
        }
        const finalHeaders = {
            'Content-Type': 'application/octet-stream',
            ...headers
        };
        if (transactionOpts?.upload?.paidBy) finalHeaders[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UploadHeaders"].PAID_BY] = transactionOpts.upload.paidBy;
        // potential improvement: write chunks into a file at offsets, instead of individual chunks + doing a concatenating copy
        const finishUpload = await this.api.post(`/chunks/${this.token}/${id}/-1`, null, {
            headers: finalHeaders,
            timeout: this.api.config?.timeout ?? 40_000 * 10
        });
        if (finishUpload.status === 402) {
            const retryAfterHeader = finishUpload?.headers?.['retry-after'];
            const errorMsg = '402 error: ' + finishUpload.data + (retryAfterHeader ? ` - retry after ${retryAfterHeader}s` : '');
            throw new Error(errorMsg);
        }
        // this will throw if the dataItem reconstruction fails
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].checkAndThrow(finishUpload, 'Finalising upload', [
            201
        ]);
        // Recover ID
        if (finishUpload.status === 201) {
            throw new Error(finishUpload.data);
        }
        finishUpload.data.verify = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].verifyReceipt.bind({}, this.bundles, finishUpload.data.data);
        this.emit('done', finishUpload);
        return finishUpload;
    }
    get completionPromise() {
        return new Promise((r)=>this.on('done', r));
    }
} //# sourceMappingURL=chunkingUploader.js.map
}),
"[project]/node_modules/@irys/upload-core/dist/esm/fund.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Fund": ()=>Fund,
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$async$2d$retry$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/async-retry/lib/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bignumber.js/bignumber.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/utils.js [app-route] (ecmascript)");
;
;
;
class Fund {
    utils;
    constructor(utils){
        this.utils = utils;
    }
    /**
     * Function to Fund (send funds to) a Irys node - inherits instance token and node
     * @param amount - amount in base units to send
     * @param multiplier - network tx fee multiplier - only works for specific currencies
     * @returns  - funding receipt
     */ async fund(amount, multiplier = 1.0) {
        amount = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](amount);
        if (!amount.isInteger()) {
            throw new Error('must use an integer for funding amount');
        }
        const c = this.utils.tokenConfig;
        const to = await this.utils.getBundlerAddress(this.utils.token);
        let fee = c.needsFee ? await c.getFee(amount, to, multiplier) : undefined;
        // if fee is defined, is a bigNumber, and getFee doesn't accept the multiplier arg, apply multiplier here.
        // tokens should now handle multipliers within getFee, this is a temporary transitionary measure.
        if (fee && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].isBigNumber(fee) && c.getFee.length < 3) fee = fee.multipliedBy(multiplier).integerValue();
        const tx = await c.createTx(amount, to, fee);
        const sendTxRes = await c.sendTx(tx.tx);
        tx.txId ??= sendTxRes;
        if (!tx.txId) throw new Error(`Undefined transaction ID`);
        // Utils.checkAndThrow(sendTxRes, `Sending transaction to the ${this.utils.token} network`);
        let confirmError = await this.utils.confirmationPoll(tx.txId);
        const bres = await this.submitTransaction(tx.txId).catch((e)=>{
            confirmError = e;
            return undefined;
        });
        if (!bres) {
            throw new Error(`failed to post funding tx - ${tx.txId} - keep this id! \n ${confirmError ? ` - ${confirmError?.message ?? confirmError}` : ''}`);
        }
        return {
            reward: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].isBigNumber(fee) ? fee.toString() : JSON.stringify(fee),
            target: to,
            quantity: amount.toString(),
            id: tx.txId
        };
    }
    async submitTransaction(transactionId) {
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$async$2d$retry$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(async ()=>{
            const bres = await this.utils.api.post(`/account/balance/${this.utils.token}`, {
                tx_id: transactionId
            });
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].checkAndThrow(bres, `Posting transaction ${transactionId} information to the bundler`, [
                202
            ]);
            return bres;
        }, {
            retries: 5,
            maxTimeout: 1000,
            minTimeout: 100,
            randomize: true
        });
    }
    async submitFundTransaction(transactionId) {
        return this.submitTransaction(transactionId);
    }
}
const __TURBOPACK__default__export__ = Fund;
 //# sourceMappingURL=fund.js.map
}),
"[project]/node_modules/@irys/upload-core/dist/esm/transactions.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Transaction": ()=>Transaction
});
class Transaction {
    irys;
    constructor(irys){
        this.irys = irys;
    }
    async getById(id) {
        const res = (await this.query({
            ids: [
                id
            ],
            limit: 1
        })).at(0);
        if (!res) throw new Error(`Unable to locate tx with id ${id}`);
        return res;
    }
    async getByOwner(owner) {
        const res = (await this.query({
            owners: [
                owner
            ],
            limit: 1
        })).at(0);
        if (!res) throw new Error(`Unable to locate tx with owner ${owner}`);
        return res;
    }
    async getByTag(name, value) {
        const res = (await this.query({
            tags: [
                {
                    name,
                    values: [
                        value
                    ]
                }
            ],
            limit: 1
        })).at(0);
        if (!res) throw new Error(`Unable to locate tx with tag ${name}:${value}`);
        return res;
    }
    async query(parameters) {
        // full bundler node GQL query
        const query = `
    query ($ids: [String!], $after: String, $currency: String, $owners: [String!], $limit: Int, $order: SortOrder, $hasTags: Boolean, $tags: [TagFilter!]) {
      transactions(ids: $ids, after: $after, currency: $currency, owners: $owners, limit: $limit, order: $order, hasTags: $hasTags, tags: $tags) {
        edges {
          cursor
          node {
            address
            currency
            id
            receipt {
              deadlineHeight
              signature
              timestamp
              version
            }
            signature
            tags {
              name
              value
            }
            timestamp
          }
        }
        pageInfo {
          endCursor
          hasNextPage
        }
      }
    }
    `;
        const txs = [];
        let endCursor = null;
        do {
            const gqlRes = await this.irys.api.post('/graphql', {
                query,
                variables: {
                    ...parameters,
                    after: endCursor ?? parameters.after
                }
            }, undefined);
            endCursor = gqlRes.data.data.transactions?.pageInfo?.hasNextPage ? gqlRes.data.data.transactions.pageInfo.endCursor : null;
            txs.push(...gqlRes.data.data.transactions.edges.map((t)=>t.node));
        }while (endCursor)
        return txs;
    }
} //# sourceMappingURL=transactions.js.map
}),
"[project]/node_modules/@irys/upload-core/dist/esm/upload.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/* eslint-disable no-case-declarations */ __turbopack_context__.s({
    "CHUNKING_THRESHOLD": ()=>CHUNKING_THRESHOLD,
    "Uploader": ()=>Uploader,
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supercharge$2f$promise$2d$pool$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supercharge/promise-pool/dist/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/bundles/build/node/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$signing$2f$chains$2f$ArweaveSigner$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__ArweaveSigner$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/bundles/build/node/esm/src/signing/chains/ArweaveSigner.js [app-route] (ecmascript) <export default as ArweaveSigner>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64url$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/base64url/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$chunkingUploader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/chunkingUploader.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$async$2d$retry$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/async-retry/lib/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/utils.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
const CHUNKING_THRESHOLD = 50_000_000;
class Uploader {
    api;
    token;
    tokenConfig;
    utils;
    contentTypeOverride;
    forceUseChunking;
    bundles;
    irysTransaction;
    constructor(api, utils, token, tokenConfig, irysTransaction){
        this.api = api;
        this.token = token;
        this.tokenConfig = tokenConfig;
        this.bundles = this.tokenConfig.irys.bundles;
        this.utils = utils;
        this.irysTransaction = irysTransaction;
    }
    async uploadTransaction(transaction, opts) {
        let res;
        const isDataItem = this.bundles.DataItem.isDataItem(transaction);
        if (this.forceUseChunking || isDataItem && transaction.getRaw().length >= CHUNKING_THRESHOLD || !isDataItem) {
            res = await this.chunkedUploader.uploadTransaction(isDataItem ? transaction.getRaw() : transaction, opts);
        } else {
            const { url, timeout, headers: confHeaders } = this.api.getConfig();
            const headers = {
                'Content-Type': 'application/octet-stream',
                ...confHeaders
            };
            if (opts?.paidBy) headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UploadHeaders"].PAID_BY] = opts.paidBy;
            res = await this.api.post(new URL(`/tx/${this.token}`, url).toString(), transaction.getRaw(), {
                headers: headers,
                timeout,
                maxBodyLength: Infinity
            });
            if (res.status === 201) {
                throw new Error(res.data);
            }
        }
        switch(res.status){
            case 402:
                const retryAfterHeader = res?.headers?.['retry-after'];
                const errorMsg = '402 error: ' + res.data + (retryAfterHeader ? ` - retry after ${retryAfterHeader}s` : '');
                throw new Error(errorMsg);
            default:
                if (res.status >= 400) {
                    throw new Error(`whilst uploading Irys transaction: ${res.status} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["httpErrData"])(res)}`);
                }
        }
        res.data.verify = async ()=>this.utils.verifyReceipt(res.data);
        return res;
    }
    async uploadData(data, opts) {
        if (typeof data === 'string') {
            data = Buffer.from(data);
        }
        if (Buffer.isBuffer(data)) {
            if (data.length <= CHUNKING_THRESHOLD) {
                const dataItem = this.bundles.createData(data, this.tokenConfig.getSigner(), {
                    ...opts,
                    anchor: opts?.anchor ?? (0, __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["randomBytes"])(32).toString('base64').slice(0, 32)
                });
                await dataItem.sign(this.tokenConfig.getSigner());
                return (await this.uploadTransaction(dataItem, {
                    ...opts?.upload
                })).data;
            }
        }
        return (await this.chunkedUploader.uploadData(data, opts)).data;
    }
    // concurrently uploads transactions
    async concurrentUploader(data, opts) {
        const errors = [];
        const logFn = opts?.logFunction ? opts?.logFunction : async (_)=>{
            return;
        };
        const concurrency = opts?.concurrency ?? 5;
        const results = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supercharge$2f$promise$2d$pool$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PromisePool"].for(data).withConcurrency(concurrency >= 1 ? concurrency : 5).handleError(async (error, _, pool)=>{
            errors.push(error);
            if (error.message.includes('402 error')) {
                pool.stop();
                throw error;
            }
        }).process(async (item, i, pool)=>{
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$async$2d$retry$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(async (bail)=>{
                try {
                    const res = await this.processItem(item, opts?.itemOptions);
                    if (i % concurrency == 0) {
                        await logFn(`Processed ${i} Items`);
                    }
                    if (opts?.resultProcessor) {
                        return await opts.resultProcessor({
                            item,
                            res,
                            i
                        }, pool);
                    } else {
                        return {
                            item,
                            res,
                            i
                        };
                    }
                } catch (e) {
                    if (e?.message.includes('402 error')) {
                        bail(e);
                    }
                    throw e;
                }
            }, {
                retries: 3,
                minTimeout: 1000,
                maxTimeout: 10_000
            });
        });
        return {
            errors,
            results: results.results
        };
    }
    async processItem(data, opts) {
        if (this.bundles.DataItem.isDataItem(data)) {
            return this.uploadTransaction(data, {
                ...opts?.upload
            });
        }
        return this.uploadData(data, opts);
    }
    /**
     * geneates a folder/path manifest JSON object
     * @param config.items mapping of logical paths to item IDs
     * @param config.indexFile optional logical path of the index file for the manifest
     * @returns
     */ async generateFolder(config) {
        const { items, indexFile } = config;
        const manifest = {
            manifest: 'irys/paths',
            version: '0.1.0',
            paths: {}
        };
        if (indexFile) {
            if (!items.has(indexFile)) {
                throw new Error(`Unable to access item: ${indexFile}`);
            }
            manifest.index = {
                path: indexFile
            };
        }
        for (const [k, v] of items.entries()){
            // @ts-expect-error constant index type
            manifest.paths[k] = {
                id: v
            };
        }
        return manifest;
    }
    get chunkedUploader() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$chunkingUploader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ChunkingUploader"](this.tokenConfig, this.api);
    }
    set useChunking(state) {
        if (typeof state === 'boolean') {
            this.forceUseChunking = state;
        }
    }
    set contentType(type) {
        // const fullType = mime.contentType(type)
        // if(!fullType){
        //     throw new Error("Invali")
        // }
        this.contentTypeOverride = type;
    }
    async uploadBundle(transactions, opts) {
        const { tx, txs, throwawayKey, throwawayKeyAddress } = await this.createBundle(transactions, opts);
        const res = await this.uploadTransaction(tx, opts);
        return {
            ...res,
            txs,
            throwawayKey,
            throwawayKeyAddress
        };
    }
    async createBundle(transactions, opts) {
        const throwawayKey = opts?.throwawayKey ?? await this.bundles.getCryptoDriver().generateJWK();
        const ephemeralSigner = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$signing$2f$chains$2f$ArweaveSigner$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__ArweaveSigner$3e$__["ArweaveSigner"](throwawayKey);
        const txs = transactions.map((tx)=>this.bundles.DataItem.isDataItem(tx) ? tx : this.bundles.createData(tx, ephemeralSigner));
        const bundle = await this.bundles.bundleAndSignData(txs, ephemeralSigner);
        // upload bundle with bundle specific tags, use actual signer for this.
        const tx = this.bundles.createData(bundle.getRaw(), this.tokenConfig.getSigner(), {
            ...opts?.bundleOpts,
            tags: [
                {
                    name: 'Bundle-Format',
                    value: 'binary'
                },
                {
                    name: 'Bundle-Version',
                    value: '2.0.0'
                },
                ...opts?.bundleOpts?.tags ?? []
            ]
        });
        const throwawayKeyAddress = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64url$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(Buffer.from(await this.bundles.getCryptoDriver().hash(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64url$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].toBuffer((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64url$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(ephemeralSigner.publicKey)))));
        await tx.sign(this.tokenConfig.getSigner());
        return {
            tx,
            throwawayKey,
            throwawayKeyAddress,
            txs
        };
    }
}
const __TURBOPACK__default__export__ = Uploader;
 //# sourceMappingURL=upload.js.map
}),
"[project]/node_modules/@irys/upload-core/dist/esm/index.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/api.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$approval$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/approval.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$chunkingUploader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/chunkingUploader.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$fund$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/fund.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$irys$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/irys.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/transaction.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$transactions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/transactions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$upload$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/upload.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/utils.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$withdrawal$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/withdrawal.js [app-route] (ecmascript)"); //# sourceMappingURL=index.js.map
;
;
;
;
;
;
;
;
;
;
;
}),
"[project]/node_modules/@irys/upload-core/dist/esm/index.js [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/api.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$approval$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/approval.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$chunkingUploader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/chunkingUploader.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$fund$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/fund.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$irys$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/irys.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/transaction.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$transactions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/transactions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$upload$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/upload.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/utils.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$withdrawal$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/withdrawal.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/index.js [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/graphql.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "GraphQLQuery": ()=>GraphQLQuery
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/axios/lib/axios.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$async$2d$retry$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/async-retry/lib/index.js [app-route] (ecmascript)");
;
;
;
class GraphQLQuery {
    /* implements BuilderMethods<TVars, GraphQLQuery<TQuery, TVars, TReturn>> */ // query variables
    queryVars = {};
    // query fields
    queryFields;
    // query metadata
    queryInfo;
    // query string, payload sent to node
    _query;
    // url of the node to query
    gqlURL;
    // misc operational config
    config;
    // result tracker object, used to hold state for paging operations
    resultTracker = {
        numPages: 0,
        numResults: 0,
        done: false
    };
    constructor({ url, network, retryConfig, query, queryName, opts }){
        url = network ? this.parseNetwork(network) : url;
        if (!url) throw new Error("URL or network is required");
        this.gqlURL = new URL(url);
        this.config = {
            first: false,
            userProvided: false,
            numPages: Infinity,
            numResults: 1_000,
            retryOpts: {
                retries: 3,
                maxTimeout: 2_000,
                minTimeout: 500,
                ...retryConfig
            }
        };
        if (query === false) return this;
        if (!query) throw new Error(`Unable to find query with name ${queryName}`);
        this.queryInfo = {
            ...query
        };
        this.queryFields = query.query;
        if (!opts?.skipVariableSetters) {
            // generate dynamic variable setter builder methods
            for (const k of Object.keys(query.vars)){
                if (this[k]) throw new Error(`Field setter ${k} has a key conflict - disable with opts.skipVariableSetters OR change the field name and add to query.remapVars`);
                this[k] = (value)=>{
                    this.queryVars[k] = value;
                    return this;
                };
            }
        }
        return this;
    }
    parseNetwork(network) {
        switch(network){
            case "mainnet":
                return new URL("https://arweave.mainnet.irys.xyz/graphql");
            case "devnet":
                return new URL("https://arweave.devnet.irys.xyz/graphql");
            case "arweave":
                return new URL("https://arweave.net/graphql");
            default:
                return undefined;
        }
        return undefined;
    }
    /**
     * Builds a query from fields and variables, formatting it into a GQL compatible string.
     * stores built query under `this.query` (protected) - accessible via `.toQuery`
     * @returns `this` (chainable)
     */ buildQuery() {
        // @ts-expect-error overloading
        if (this.config.userProvided) return this; // don't build if it's a user provided query string
        // builds query, reducing `this.queryFields` to a structured string with correct formatting
        const toGQLString = (s)=>JSON.stringify(s, (_, v)=>{
                if (v instanceof Array) return v[0]; /* JSON.stringify(v); */ 
                if (typeof v === "object") return v;
                if (v === false) return undefined;
                return "";
            }).replaceAll(`:`, "").replaceAll(`"`, "").replaceAll(",", "\n          ");
        const nodeQuery = toGQLString(this.queryFields);
        // the hasNextPage field can vary
        const pageInfo = toGQLString({
            pageInfo: {
                [this.queryInfo.paging?.hasNextPage ?? "hasNextPage"]: undefined
            }
        }).slice(1, -1); // remove leading "{" and finishing "}"
        const enumValues = this.queryInfo.enumValues;
        // incorporates defaults from queryInfo
        const vars = {
            ...this.queryInfo.vars,
            ...this.queryVars
        };
        if (this.config.numResults && this.queryInfo.paging?.limiterName) {
            vars[this.queryInfo.paging?.limiterName] = Math.max(this.config.numResults, 1);
        }
        // remap keys - primarily done to prevent conflicts with builder methods.
        // {limit: "first"} -> remaps `limit` variable to `first` variable
        // {limit: (k,v) => ["first",v]} does the same thing
        for (const [k, v] of Object.entries(this.queryInfo.remapVars ?? {})){
            if (vars?.[k] === undefined) continue;
            if (typeof v === "function") {
                // provided mapper fn
                const m = v(k, vars[k], vars);
                if (!m) continue;
                const [nk, nv] = m;
                vars[nk] = nv;
                if (nk === k) continue; // don't null out key if it's the same key
            } else {
                vars[v] = vars[k];
            }
            vars[k] = undefined; // null keys are removed below
        }
        // reduces queryVars to inline vars, for convenience. (using separate means we have to annotate the GQL type)
        const qVars = JSON.stringify(vars, function(k, v) {
            // console.log(this, k, v);
            if (v === undefined) return v; // remove null keys
            if (v instanceof Array) return v; // don't break recursion
            if (typeof v === "object") return v; // ^
            if (typeof v === "number") return v; // numbers don't need string escaping
            // TODO: improve this so it's context aware and doesn't alter anything unintentional
            // can probably do by logging key names into array if value is an object, popping when object is a primitive
            if (enumValues?.includes(k)) return v; // exclude enum variants from quote addition
            return `'${v}'`; // this value needs to be quote padded
        }).replaceAll('"', "") // remove double quotes,
        .replaceAll("'", '"') // add needed double quotes
        .slice(1, -1); // remove leading "{" and finishing "}"
        if (!this?.queryInfo?.name) throw new Error(`Query name is undefined!`);
        // discriminate based on whether the query is pageable
        const query = this.queryInfo.paging ? `query {
      ${this.queryInfo.name}(
        ${qVars}
      ) {
        edges {
          cursor
          node ${nodeQuery}
        }
        ${pageInfo}
      }
    }` : `query {
    ${this.queryInfo.name}(
      ${qVars}
    ) 
    ${nodeQuery}
  }`;
        this._query = query;
        // @ts-expect-error types - DO NOT SET RETURN TYPE TO `this` - TS will assume this should be an async function as `this` implements promise methods
        return this;
    }
    /**
     * Primary query execution method - builds & runs the query, returning result nodes and updating cursor info in queryVars
     * @returns query result nodes
     */ async getPage() {
        if (this.resultTracker.done) return undefined;
        this.buildQuery();
        if (!this._query) throw new Error(`Unable to run undefined query`);
        let res;
        try {
            res = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$async$2d$retry$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(async (_)=>{
                const r = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this.gqlURL.toString(), {
                    method: "post",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    data: {
                        query: this._query
                    }
                });
                if (r.data.errors) throw r;
                return r;
            }, this.config.retryOpts);
        } catch (e) {
            throw new Error(`Error running query\n ${this._query} - ${e.message ? e.message + " -" : ""} (${JSON.stringify(e?.data?.errors.map((e)=>e.message) ?? e?.errors ?? e)}) `);
        }
        if (this.config.userProvided) return this.trimmer([
            res.data.data
        ].flat(20));
        const data = res.data.data[this.queryInfo.name];
        // if this is a pageable query if this is defined
        if (this.queryInfo.paging) {
            const nextCursor = data.pageInfo[this.queryInfo.paging.hasNextPage] ? data.edges.at(-1)[this.queryInfo.paging.cursor] : undefined;
            this.queryVars.after = nextCursor;
            return this.trimmer(data.edges.map((v)=>v.node));
        }
        return this.trimmer([
            data
        ].flat(20));
    }
    // tracks & controls output
    trimmer(res) {
        const numPages = ++this.resultTracker.numPages;
        const numResults = this.resultTracker.numResults += res.length;
        if (res.length === 0) {
            this.resultTracker.done = true;
            return res;
        }
        if (numPages >= this?.config?.numPages) this.resultTracker.done = true;
        if (numResults >= this?.config?.numResults) {
            this.resultTracker.done = true;
            const delta = this.config.numResults - (numResults - res.length);
            return res.slice(0, delta);
        }
        return res;
    }
    // return modifier functions
    /**
     * Get the first result from the query
     * @returns the first result from the query - gets at maximum one page
     */ async first() {
        const res = await this.getPage();
        return res?.at(0) ?? undefined;
    }
    /**
     * Limiter on the number of pages a given query should resolve to
     * @param numPages Maximum number of pages to return
     * @returns this (chainable)
     */ maxPages(numPages) {
        this.config.numPages = numPages;
        // @ts-expect-error types
        return this;
    }
    /**
     * Limiter on the maximum number of results a given query should resolve to
     * @param numResults Maximum number of results to return
     * @returns this (chainable)
     */ limit(numResults) {
        this.config.numResults = numResults;
        // @ts-expect-error types
        return this;
    }
    /**
     * Change the URL of the graphql endpoint to use
     * @param url: URL to use
     * @returns this (chainable)
     */ url(url) {
        this.gqlURL = new URL(url);
        // @ts-expect-error types
        return this;
    }
    /**
     * Change the network of the graphql endpoint to use
     * @param network: network to use
     * @returns this (chainable)
     */ network(network) {
        const parsed = this.parseNetwork(network);
        if (!parsed) throw new Error(`Invalid network: ${network}`);
        this.gqlURL = parsed;
        // @ts-expect-error types
        return this;
    }
    // return functions
    /**
     * Gets all results from the built query
     * @returns array of results
     */ async all() {
        const results = [];
        do {
            const page = await this.getPage();
            if (!page) break;
            // @ts-expect-error types
            results.push(...page);
        }while (this.queryVars.after)
        return results;
    }
    /**
     * Async generator, yields individual query result items
     */ async *generator() {
        do {
            const res = await this.getPage();
            if (!res) return;
            // @ts-expect-error constraints
            for (const r of res)yield r;
        }while (this.queryVars.after) // getPage sets after to undefined if there are no more pages
    }
    /**
     * Readable stream produced from `this.generator`
     * @returns a readable instance, with the "data" event yielding individual results
     */ stream() {
        return __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["Readable"].from(this.generator());
    }
    /**
     * Provide a custom query string to resolve
     * @param query Query string to use
     * @returns result of the query - this method does not support paging or extraction
     */ query(query) {
        this._query = query;
        this.config.userProvided = true;
        // @ts-expect-error overloading
        return this;
    }
    // TODO issue: this allows for additional (top level only?!) fields that aren't part of TQuery - for now we perform JS level shape checks and throw.
    /**
     * Set the fields you want the query to return
     * @param fields - Object structured like a graphql query body, truthy values including, falsy excluding
     * @param skipFieldCheck - whether to skip JS level fields object shape validation
     * @returns `this` (chainable)
     */ fields(fields, skipFieldCheck = false) {
        // validate provided fields against default fields
        // default/allowed fields is under `this.queryFields`
        // user selected fields are under `fields`
        // path, allowed, user provided - it's flat so we don't need super precise comparision
        const recursiveValidate = (p, a, b)=>{
            for (const k of Object.keys(b)){
                let ak = a[k];
                if (Array.isArray(ak)) ak = ak[0];
                const bk = b[k];
                if (ak === undefined) throw new Error(`Illegal field ${p}${k}`);
                if (typeof bk === "object") recursiveValidate(p + k + ".", ak, bk);
            }
        };
        if (!skipFieldCheck) recursiveValidate("", this.queryFields, fields);
        this.queryFields = fields;
        // @ts-expect-error TODO: fix this
        return this;
    }
    /**
     * Sets variables/filters using an object
     * @param variables variable object to set
     * @returns this (chainable)
     */ variables(variables) {
        this.queryVars = {
            ...this.queryVars,
            ...variables
        };
        // @ts-expect-error - dynamic builder props
        return this;
    }
    /**
     * Builds the current query and returns a ready to POST query string
     * @returns string form of the current query
     */ toQuery() {
        this.buildQuery();
        return this._query;
    }
    // instance generic type accessors
    /**
     * Dummy method to access the internal `TReturn` generic type
     * @returns "tReturn"
     */ tReturn() {
        return "tReturn";
    }
    /**
     * Dummy method to access the internal `TQuery` generic type
     * @returns "tQuery"
     */ tQuery() {
        return "tQuery";
    }
    /**
     * Dummy method to access the internal `TVars` generic type
     * @returns "tVars"
     */ tVars() {
        return "tVars";
    }
    // Promise contract functions, so users can `await` a GraphQLQuery instance to resolve the built query.
    // very cool, thanks Knex.
    /**
     * Resolves `this` by getting all results for the query (including paging)
     * @param onFulfilled - optional onFulfilled callback
     * @returns - all results for built query
     */ async then(onFulfilled, onRejected) {
        const res = this.all();
        return res.then(onFulfilled, onRejected);
    }
    async catch(onReject) {
        return this.then().catch(onReject);
    }
    async finally(onFinally) {
        return this.then().finally(onFinally);
    }
} // this was definitely not over engineered 
 //# sourceMappingURL=graphql.js.map
}),
"[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/arweave/block.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "arweaveBlockQuery": ()=>arweaveBlockQuery,
    "block": ()=>block,
    "blockVars": ()=>blockVars
});
const block = {
    id: "",
    timestamp: 0,
    height: "",
    previous: ""
};
const blockVars = {
    id: undefined
};
const arweaveBlockQuery = {
    name: "block",
    query: block,
    vars: blockVars
}; //# sourceMappingURL=block.js.map
}),
"[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/arweave/blocks.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "arweaveBlocksQuery": ()=>arweaveBlocksQuery,
    "blocksVars": ()=>blocksVars
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$arweave$2f$block$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/arweave/block.js [app-route] (ecmascript)");
;
const blocksVars = {
    ids: undefined,
    // height: undefined,
    minHeight: undefined,
    maxHeight: undefined,
    pageSize: 10,
    after: undefined,
    sort: "DESC"
};
const arweaveBlocksQuery = {
    name: "blocks",
    query: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$arweave$2f$block$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["block"],
    vars: blocksVars,
    enumValues: [
        "sort"
    ],
    remapVars: {
        pageSize: "first",
        // replace ASC/DESC to HEIGHT prefixed versions
        sort: (k, v)=>[
                k,
                v === "ASC" ? "HEIGHT_ASC" : "HEIGHT_DESC"
            ],
        minHeight: (_k, v, vars)=>{
            vars.height = {
                ...vars.height,
                min: v
            };
            vars.minHeight = undefined;
        },
        maxHeight: (_k, v, vars)=>{
            vars.height = {
                ...vars.height,
                max: v
            };
            vars.maxHeight = undefined;
        }
    },
    paging: {
        hasNextPage: "hasNextPage",
        cursor: "cursor",
        limiterName: "pageSize"
    }
}; //# sourceMappingURL=blocks.js.map
}),
"[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/arweave/transaction.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// derive type from minimal object, use this object to validate structure in code.
__turbopack_context__.s({
    "arweaveTransactionQuery": ()=>arweaveTransactionQuery,
    "transaction": ()=>transaction,
    "transactionVars": ()=>transactionVars
});
const transaction = {
    id: "",
    anchor: "",
    signature: "",
    recipient: "",
    owner: {
        address: "",
        key: ""
    },
    fee: {
        winston: "",
        ar: ""
    },
    quantity: {
        winston: "",
        ar: ""
    },
    data: {
        size: "",
        type: ""
    },
    tags: [
        {
            name: "",
            value: ""
        }
    ],
    block: {
        id: "",
        timestamp: 0,
        height: 0,
        previous: ""
    },
    bundledIn: {
        id: ""
    }
};
const transactionVars = {
    id: undefined
};
const arweaveTransactionQuery = {
    name: "transaction",
    query: transaction,
    vars: transactionVars
}; //# sourceMappingURL=transaction.js.map
}),
"[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/arweave/transactions.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "arweaveTransactionsQuery": ()=>arweaveTransactionsQuery,
    "transactionsVars": ()=>transactionsVars
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$arweave$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/arweave/transaction.js [app-route] (ecmascript)");
;
const transactionsVars = {
    ids: undefined,
    from: undefined,
    to: undefined,
    tags: undefined,
    bundledIn: undefined,
    // block: undefined,
    minHeight: undefined,
    maxHeight: undefined,
    pageSize: 10,
    after: undefined,
    sort: "DESC"
};
const arweaveTransactionsQuery = {
    name: "transactions",
    query: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$arweave$2f$transaction$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["transaction"],
    enumValues: [
        "sort"
    ],
    vars: transactionsVars,
    remapVars: {
        pageSize: "first",
        from: "owners",
        to: "recipients",
        // replace ASC/DESC to HEIGHT prefixed versions
        sort: (k, v)=>[
                k,
                v === "ASC" ? "HEIGHT_ASC" : "HEIGHT_DESC"
            ],
        minHeight: (_k, v, vars)=>{
            vars.block = {
                ...vars.block,
                min: v
            };
            vars.minHeight = undefined;
        },
        maxHeight: (_k, v, vars)=>{
            vars.block = {
                ...vars.block,
                max: v
            };
            vars.maxHeight = undefined;
        }
    },
    paging: {
        hasNextPage: "hasNextPage",
        cursor: "cursor",
        limiterName: "pageSize"
    }
}; //# sourceMappingURL=transactions.js.map
}),
"[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/irys/paymentApprovals.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// derive type from minimal object, use this object to validate structure in code.
__turbopack_context__.s({
    "irysPaymentApprovalsQuery": ()=>irysPaymentApprovalsQuery,
    "paymentApprovalVars": ()=>paymentApprovalVars,
    "paymentApprovals": ()=>paymentApprovals
});
const paymentApprovals = {
    amount: "",
    payingAddress: "",
    approvedAddress: "",
    expiresBy: 0,
    timestamp: 0,
    token: ""
};
const paymentApprovalVars = {
    tokens: undefined,
    payingAddresses: undefined,
    approvedAddresses: undefined,
    pageSize: 100,
    order: "ASC",
    after: undefined
};
const irysPaymentApprovalsQuery = {
    name: "paymentApprovals",
    query: paymentApprovals,
    enumValues: [
        "order"
    ],
    vars: paymentApprovalVars,
    remapVars: {
        pageSize: "limit"
    },
    paging: {
        hasNextPage: "hasNextPage",
        cursor: "cursor",
        limiterName: "pageSize"
    }
}; //# sourceMappingURL=paymentApprovals.js.map
}),
"[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/irys/transactions.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// derive type from minimal object, use this object to validate structure in code.
__turbopack_context__.s({
    "irysTransactionsQuery": ()=>irysTransactionsQuery,
    "transactionVars": ()=>transactionVars,
    "transactions": ()=>transactions
});
const transactions = {
    id: "",
    receipt: {
        deadlineHeight: 0,
        signature: "",
        timestamp: 0,
        version: ""
    },
    tags: [
        {
            name: "",
            value: ""
        }
    ],
    address: "",
    token: "",
    signature: "",
    timestamp: 0
};
const transactionVars = {
    ids: undefined,
    after: undefined,
    token: undefined,
    from: undefined,
    pageSize: 100,
    sort: "ASC",
    // hasTags: undefined,
    tags: undefined,
    fromTimestamp: undefined,
    toTimestamp: undefined
};
const irysTransactionsQuery = {
    name: "transactions",
    query: transactions,
    enumValues: [
        "order"
    ],
    vars: transactionVars,
    remapVars: {
        pageSize: "first",
        sort: "order",
        from: "owners",
        fromTimestamp: (_k, v, vars)=>{
            const ts = new Date(v).getTime();
            if (isNaN(ts)) throw new Error("invalid from timestamp");
            vars.timestamp = {
                ...vars.timestamp,
                from: ts
            };
            vars.fromTimestamp = undefined;
        },
        toTimestamp: (_k, v, vars)=>{
            const ts = new Date(v).getTime();
            if (isNaN(ts)) throw new Error("invalid to timestamp");
            vars.timestamp = {
                ...vars.timestamp,
                to: ts
            };
            vars.toTimestamp = undefined;
        }
    },
    paging: {
        hasNextPage: "hasNextPage",
        cursor: "cursor",
        limiterName: "pageSize"
    }
}; //# sourceMappingURL=transactions.js.map
}),
"[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/index.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "queries": ()=>queries
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$arweave$2f$blocks$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/arweave/blocks.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$arweave$2f$transactions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/arweave/transactions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$irys$2f$paymentApprovals$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/irys/paymentApprovals.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$irys$2f$transactions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/irys/transactions.js [app-route] (ecmascript)");
;
;
;
;
const queries = {
    "irys:transactions": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$irys$2f$transactions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["irysTransactionsQuery"],
    "arweave:transactions": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$arweave$2f$transactions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["arweaveTransactionsQuery"],
    "arweave:blocks": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$arweave$2f$blocks$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["arweaveBlocksQuery"],
    "irys:paymentApprovals": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$irys$2f$paymentApprovals$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["irysPaymentApprovalsQuery"]
};
;
;
;
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/index.js [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$arweave$2f$blocks$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/arweave/blocks.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$arweave$2f$transactions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/arweave/transactions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$irys$2f$paymentApprovals$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/irys/paymentApprovals.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$irys$2f$transactions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/irys/transactions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/index.js [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/query.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Query": ()=>Query,
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$graphql$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/graphql.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/index.js [app-route] (ecmascript) <locals>");
;
;
class Query {
    opts;
    constructor(opts = {
        network: "mainnet"
    }){
        this.opts = opts;
    }
    search(queryName, opts) {
        // const queryInstance =
        const query = opts?.query ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["queries"][queryName];
        const queryInstance = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$graphql$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GraphQLQuery"]({
            ...this.opts,
            query,
            queryName
        });
        // @ts-expect-error overloading
        return queryInstance;
    }
}
const __TURBOPACK__default__export__ = Query;
 //# sourceMappingURL=query.js.map
}),
"[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/types.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
;
 //# sourceMappingURL=types.js.map
}),
"[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/index.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$query$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/query.js [app-route] (ecmascript)");
// for TS type portability
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$graphql$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/graphql.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/index.js [app-route] (ecmascript) <module evaluation>"); //# sourceMappingURL=index.js.map
;
;
;
;
;
}),
"[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/index.js [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$query$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/query.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$graphql$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/graphql.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$queries$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/queries/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/index.js [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/query.js [app-route] (ecmascript) <export Query as default>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$query$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Query"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$node_modules$2f40$irys$2f$query$2f$build$2f$esm$2f$query$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/node_modules/@irys/query/build/esm/query.js [app-route] (ecmascript)");
}),
"[project]/node_modules/@irys/bundles/node_modules/base-x/src/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
// @ts-ignore
var _Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-route] (ecmascript)").Buffer;
function base(ALPHABET) {
    if (ALPHABET.length >= 255) {
        throw new TypeError('Alphabet too long');
    }
    var BASE_MAP = new Uint8Array(256);
    for(var j = 0; j < BASE_MAP.length; j++){
        BASE_MAP[j] = 255;
    }
    for(var i = 0; i < ALPHABET.length; i++){
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + ' is ambiguous');
        }
        BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
    ;
    var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
    ;
    function encode(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
            source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
            throw new TypeError('Expected Buffer');
        }
        if (source.length === 0) {
            return '';
        }
        // Skip & count leading zeroes.
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while(pbegin !== pend && source[pbegin] === 0){
            pbegin++;
            zeroes++;
        }
        // Allocate enough space in big-endian base58 representation.
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        // Process the bytes.
        while(pbegin !== pend){
            var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
            var i = 0;
            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){
                carry += 256 * b58[it1] >>> 0;
                b58[it1] = carry % BASE >>> 0;
                carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
                throw new Error('Non-zero carry');
            }
            length = i;
            pbegin++;
        }
        // Skip leading zeroes in base58 result.
        var it2 = size - length;
        while(it2 !== size && b58[it2] === 0){
            it2++;
        }
        // Translate the result into a string.
        var str = LEADER.repeat(zeroes);
        for(; it2 < size; ++it2){
            str += ALPHABET.charAt(b58[it2]);
        }
        return str;
    }
    function decodeUnsafe(source) {
        if (typeof source !== 'string') {
            throw new TypeError('Expected String');
        }
        if (source.length === 0) {
            return _Buffer.alloc(0);
        }
        var psz = 0;
        // Skip and count leading '1's.
        var zeroes = 0;
        var length = 0;
        while(source[psz] === LEADER){
            zeroes++;
            psz++;
        }
        // Allocate enough space in big-endian base256 representation.
        var size = (source.length - psz) * FACTOR + 1 >>> 0 // log(58) / log(256), rounded up.
        ;
        var b256 = new Uint8Array(size);
        // Process the characters.
        while(psz < source.length){
            // Find code of next character
            var charCode = source.charCodeAt(psz);
            // Base map can not be indexed using char code
            if (charCode > 255) {
                return;
            }
            // Decode character
            var carry = BASE_MAP[charCode];
            // Invalid character
            if (carry === 255) {
                return;
            }
            var i = 0;
            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){
                carry += BASE * b256[it3] >>> 0;
                b256[it3] = carry % 256 >>> 0;
                carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
                throw new Error('Non-zero carry');
            }
            length = i;
            psz++;
        }
        // Skip leading zeroes in b256.
        var it4 = size - length;
        while(it4 !== size && b256[it4] === 0){
            it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
        vch.fill(0x00, 0, zeroes);
        var j = zeroes;
        while(it4 !== size){
            vch[j++] = b256[it4++];
        }
        return vch;
    }
    function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
            return buffer;
        }
        throw new Error('Non-base' + BASE + ' character');
    }
    return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
    };
}
module.exports = base;
}}),
"[project]/node_modules/@irys/bundles/node_modules/bs58/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
var basex = __turbopack_context__.r("[project]/node_modules/@irys/bundles/node_modules/base-x/src/index.js [app-route] (ecmascript)");
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
module.exports = basex(ALPHABET);
}}),
"[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/utils/is_object.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "is_object": ()=>is_object
});
const is_object = function(obj) {
    return typeof obj === "object" && obj !== null && !Array.isArray(obj);
};
;
}),
"[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/CsvError.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "CsvError": ()=>CsvError
});
class CsvError extends Error {
    constructor(code, message, options, ...contexts){
        if (Array.isArray(message)) message = message.join(" ").trim();
        super(message);
        if (Error.captureStackTrace !== undefined) {
            Error.captureStackTrace(this, CsvError);
        }
        this.code = code;
        for (const context of contexts){
            for(const key in context){
                const value = context[key];
                this[key] = Buffer.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value));
            }
        }
    }
}
;
}),
"[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/normalize_columns_array.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "normalize_columns_array": ()=>normalize_columns_array
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/CsvError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$utils$2f$is_object$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/utils/is_object.js [app-route] (ecmascript)");
;
;
const normalize_columns_array = function(columns) {
    const normalizedColumns = [];
    for(let i = 0, l = columns.length; i < l; i++){
        const column = columns[i];
        if (column === undefined || column === null || column === false) {
            normalizedColumns[i] = {
                disabled: true
            };
        } else if (typeof column === "string") {
            normalizedColumns[i] = {
                name: column
            };
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$utils$2f$is_object$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["is_object"])(column)) {
            if (typeof column.name !== "string") {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_OPTION_COLUMNS_MISSING_NAME", [
                    "Option columns missing name:",
                    `property "name" is required at position ${i}`,
                    "when column is an object literal"
                ]);
            }
            normalizedColumns[i] = column;
        } else {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_COLUMN_DEFINITION", [
                "Invalid column definition:",
                "expect a string or a literal object,",
                `got ${JSON.stringify(column)} at position ${i}`
            ]);
        }
    }
    return normalizedColumns;
};
;
}),
"[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/utils/ResizeableBuffer.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
class ResizeableBuffer {
    constructor(size = 100){
        this.size = size;
        this.length = 0;
        this.buf = Buffer.allocUnsafe(size);
    }
    prepend(val) {
        if (Buffer.isBuffer(val)) {
            const length = this.length + val.length;
            if (length >= this.size) {
                this.resize();
                if (length >= this.size) {
                    throw Error("INVALID_BUFFER_STATE");
                }
            }
            const buf = this.buf;
            this.buf = Buffer.allocUnsafe(this.size);
            val.copy(this.buf, 0);
            buf.copy(this.buf, val.length);
            this.length += val.length;
        } else {
            const length = this.length++;
            if (length === this.size) {
                this.resize();
            }
            const buf = this.clone();
            this.buf[0] = val;
            buf.copy(this.buf, 1, 0, length);
        }
    }
    append(val) {
        const length = this.length++;
        if (length === this.size) {
            this.resize();
        }
        this.buf[length] = val;
    }
    clone() {
        return Buffer.from(this.buf.slice(0, this.length));
    }
    resize() {
        const length = this.length;
        this.size = this.size * 2;
        const buf = Buffer.allocUnsafe(this.size);
        this.buf.copy(buf, 0, 0, length);
        this.buf = buf;
    }
    toString(encoding) {
        if (encoding) {
            return this.buf.slice(0, this.length).toString(encoding);
        } else {
            return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));
        }
    }
    toJSON() {
        return this.toString("utf8");
    }
    reset() {
        this.length = 0;
    }
}
const __TURBOPACK__default__export__ = ResizeableBuffer;
}),
"[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/init_state.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "init_state": ()=>init_state
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$utils$2f$ResizeableBuffer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/utils/ResizeableBuffer.js [app-route] (ecmascript)");
;
// white space characters
// https://en.wikipedia.org/wiki/Whitespace_character
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types
// \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff
const np = 12;
const cr = 13; // `\r`, carriage return, 0x0D in hexadcimal, 13 in decimal
const nl = 10; // `\n`, newline, 0x0A in hexadecimal, 10 in decimal
const space = 32;
const tab = 9;
const init_state = function(options) {
    return {
        bomSkipped: false,
        bufBytesStart: 0,
        castField: options.cast_function,
        commenting: false,
        // Current error encountered by a record
        error: undefined,
        enabled: options.from_line === 1,
        escaping: false,
        escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,
        // columns can be `false`, `true`, `Array`
        expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : undefined,
        field: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$utils$2f$ResizeableBuffer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](20),
        firstLineToHeaders: options.cast_first_line_to_header,
        needMoreDataSize: Math.max(// Skip if the remaining buffer smaller than comment
        options.comment !== null ? options.comment.length : 0, // Skip if the remaining buffer can be delimiter
        ...options.delimiter.map((delimiter)=>delimiter.length), // Skip if the remaining buffer can be escape sequence
        options.quote !== null ? options.quote.length : 0),
        previousBuf: undefined,
        quoting: false,
        stop: false,
        rawBuffer: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$utils$2f$ResizeableBuffer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](100),
        record: [],
        recordHasError: false,
        record_length: 0,
        recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 0 : Math.max(...options.record_delimiter.map((v)=>v.length)),
        trimChars: [
            Buffer.from(" ", options.encoding)[0],
            Buffer.from("\t", options.encoding)[0]
        ],
        wasQuoting: false,
        wasRowDelimiter: false,
        timchars: [
            Buffer.from(Buffer.from([
                cr
            ], "utf8").toString(), options.encoding),
            Buffer.from(Buffer.from([
                nl
            ], "utf8").toString(), options.encoding),
            Buffer.from(Buffer.from([
                np
            ], "utf8").toString(), options.encoding),
            Buffer.from(Buffer.from([
                space
            ], "utf8").toString(), options.encoding),
            Buffer.from(Buffer.from([
                tab
            ], "utf8").toString(), options.encoding)
        ]
    };
};
;
}),
"[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/utils/underscore.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "underscore": ()=>underscore
});
const underscore = function(str) {
    return str.replace(/([A-Z])/g, function(_, match) {
        return "_" + match.toLowerCase();
    });
};
;
}),
"[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/normalize_options.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "normalize_options": ()=>normalize_options
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$normalize_columns_array$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/normalize_columns_array.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/CsvError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$utils$2f$underscore$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/utils/underscore.js [app-route] (ecmascript)");
;
;
;
const normalize_options = function(opts) {
    const options = {};
    // Merge with user options
    for(const opt in opts){
        options[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$utils$2f$underscore$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["underscore"])(opt)] = opts[opt];
    }
    // Normalize option `encoding`
    // Note: defined first because other options depends on it
    // to convert chars/strings into buffers.
    if (options.encoding === undefined || options.encoding === true) {
        options.encoding = "utf8";
    } else if (options.encoding === null || options.encoding === false) {
        options.encoding = null;
    } else if (typeof options.encoding !== "string" && options.encoding !== null) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_OPTION_ENCODING", [
            "Invalid option encoding:",
            "encoding must be a string or null to return a buffer,",
            `got ${JSON.stringify(options.encoding)}`
        ], options);
    }
    // Normalize option `bom`
    if (options.bom === undefined || options.bom === null || options.bom === false) {
        options.bom = false;
    } else if (options.bom !== true) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_OPTION_BOM", [
            "Invalid option bom:",
            "bom must be true,",
            `got ${JSON.stringify(options.bom)}`
        ], options);
    }
    // Normalize option `cast`
    options.cast_function = null;
    if (options.cast === undefined || options.cast === null || options.cast === false || options.cast === "") {
        options.cast = undefined;
    } else if (typeof options.cast === "function") {
        options.cast_function = options.cast;
        options.cast = true;
    } else if (options.cast !== true) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_OPTION_CAST", [
            "Invalid option cast:",
            "cast must be true or a function,",
            `got ${JSON.stringify(options.cast)}`
        ], options);
    }
    // Normalize option `cast_date`
    if (options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === "") {
        options.cast_date = false;
    } else if (options.cast_date === true) {
        options.cast_date = function(value) {
            const date = Date.parse(value);
            return !isNaN(date) ? new Date(date) : value;
        };
    } else if (typeof options.cast_date !== "function") {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_OPTION_CAST_DATE", [
            "Invalid option cast_date:",
            "cast_date must be true or a function,",
            `got ${JSON.stringify(options.cast_date)}`
        ], options);
    }
    // Normalize option `columns`
    options.cast_first_line_to_header = null;
    if (options.columns === true) {
        // Fields in the first line are converted as-is to columns
        options.cast_first_line_to_header = undefined;
    } else if (typeof options.columns === "function") {
        options.cast_first_line_to_header = options.columns;
        options.columns = true;
    } else if (Array.isArray(options.columns)) {
        options.columns = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$normalize_columns_array$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalize_columns_array"])(options.columns);
    } else if (options.columns === undefined || options.columns === null || options.columns === false) {
        options.columns = false;
    } else {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_OPTION_COLUMNS", [
            "Invalid option columns:",
            "expect an array, a function or true,",
            `got ${JSON.stringify(options.columns)}`
        ], options);
    }
    // Normalize option `group_columns_by_name`
    if (options.group_columns_by_name === undefined || options.group_columns_by_name === null || options.group_columns_by_name === false) {
        options.group_columns_by_name = false;
    } else if (options.group_columns_by_name !== true) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME", [
            "Invalid option group_columns_by_name:",
            "expect an boolean,",
            `got ${JSON.stringify(options.group_columns_by_name)}`
        ], options);
    } else if (options.columns === false) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME", [
            "Invalid option group_columns_by_name:",
            "the `columns` mode must be activated."
        ], options);
    }
    // Normalize option `comment`
    if (options.comment === undefined || options.comment === null || options.comment === false || options.comment === "") {
        options.comment = null;
    } else {
        if (typeof options.comment === "string") {
            options.comment = Buffer.from(options.comment, options.encoding);
        }
        if (!Buffer.isBuffer(options.comment)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_OPTION_COMMENT", [
                "Invalid option comment:",
                "comment must be a buffer or a string,",
                `got ${JSON.stringify(options.comment)}`
            ], options);
        }
    }
    // Normalize option `comment_no_infix`
    if (options.comment_no_infix === undefined || options.comment_no_infix === null || options.comment_no_infix === false) {
        options.comment_no_infix = false;
    } else if (options.comment_no_infix !== true) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_OPTION_COMMENT", [
            "Invalid option comment_no_infix:",
            "value must be a boolean,",
            `got ${JSON.stringify(options.comment_no_infix)}`
        ], options);
    }
    // Normalize option `delimiter`
    const delimiter_json = JSON.stringify(options.delimiter);
    if (!Array.isArray(options.delimiter)) options.delimiter = [
        options.delimiter
    ];
    if (options.delimiter.length === 0) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_OPTION_DELIMITER", [
            "Invalid option delimiter:",
            "delimiter must be a non empty string or buffer or array of string|buffer,",
            `got ${delimiter_json}`
        ], options);
    }
    options.delimiter = options.delimiter.map(function(delimiter) {
        if (delimiter === undefined || delimiter === null || delimiter === false) {
            return Buffer.from(",", options.encoding);
        }
        if (typeof delimiter === "string") {
            delimiter = Buffer.from(delimiter, options.encoding);
        }
        if (!Buffer.isBuffer(delimiter) || delimiter.length === 0) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_OPTION_DELIMITER", [
                "Invalid option delimiter:",
                "delimiter must be a non empty string or buffer or array of string|buffer,",
                `got ${delimiter_json}`
            ], options);
        }
        return delimiter;
    });
    // Normalize option `escape`
    if (options.escape === undefined || options.escape === true) {
        options.escape = Buffer.from('"', options.encoding);
    } else if (typeof options.escape === "string") {
        options.escape = Buffer.from(options.escape, options.encoding);
    } else if (options.escape === null || options.escape === false) {
        options.escape = null;
    }
    if (options.escape !== null) {
        if (!Buffer.isBuffer(options.escape)) {
            throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`);
        }
    }
    // Normalize option `from`
    if (options.from === undefined || options.from === null) {
        options.from = 1;
    } else {
        if (typeof options.from === "string" && /\d+/.test(options.from)) {
            options.from = parseInt(options.from);
        }
        if (Number.isInteger(options.from)) {
            if (options.from < 0) {
                throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`);
            }
        } else {
            throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`);
        }
    }
    // Normalize option `from_line`
    if (options.from_line === undefined || options.from_line === null) {
        options.from_line = 1;
    } else {
        if (typeof options.from_line === "string" && /\d+/.test(options.from_line)) {
            options.from_line = parseInt(options.from_line);
        }
        if (Number.isInteger(options.from_line)) {
            if (options.from_line <= 0) {
                throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`);
            }
        } else {
            throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`);
        }
    }
    // Normalize options `ignore_last_delimiters`
    if (options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null) {
        options.ignore_last_delimiters = false;
    } else if (typeof options.ignore_last_delimiters === "number") {
        options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);
        if (options.ignore_last_delimiters === 0) {
            options.ignore_last_delimiters = false;
        }
    } else if (typeof options.ignore_last_delimiters !== "boolean") {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS", [
            "Invalid option `ignore_last_delimiters`:",
            "the value must be a boolean value or an integer,",
            `got ${JSON.stringify(options.ignore_last_delimiters)}`
        ], options);
    }
    if (options.ignore_last_delimiters === true && options.columns === false) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS", [
            "The option `ignore_last_delimiters`",
            "requires the activation of the `columns` option"
        ], options);
    }
    // Normalize option `info`
    if (options.info === undefined || options.info === null || options.info === false) {
        options.info = false;
    } else if (options.info !== true) {
        throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`);
    }
    // Normalize option `max_record_size`
    if (options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false) {
        options.max_record_size = 0;
    } else if (Number.isInteger(options.max_record_size) && options.max_record_size >= 0) {
    // Great, nothing to do
    } else if (typeof options.max_record_size === "string" && /\d+/.test(options.max_record_size)) {
        options.max_record_size = parseInt(options.max_record_size);
    } else {
        throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`);
    }
    // Normalize option `objname`
    if (options.objname === undefined || options.objname === null || options.objname === false) {
        options.objname = undefined;
    } else if (Buffer.isBuffer(options.objname)) {
        if (options.objname.length === 0) {
            throw new Error(`Invalid Option: objname must be a non empty buffer`);
        }
        if (options.encoding === null) {
        // Don't call `toString`, leave objname as a buffer
        } else {
            options.objname = options.objname.toString(options.encoding);
        }
    } else if (typeof options.objname === "string") {
        if (options.objname.length === 0) {
            throw new Error(`Invalid Option: objname must be a non empty string`);
        }
    // Great, nothing to do
    } else if (typeof options.objname === "number") {
    // if(options.objname.length === 0){
    //   throw new Error(`Invalid Option: objname must be a non empty string`);
    // }
    // Great, nothing to do
    } else {
        throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`);
    }
    if (options.objname !== undefined) {
        if (typeof options.objname === "number") {
            if (options.columns !== false) {
                throw Error("Invalid Option: objname index cannot be combined with columns or be defined as a field");
            }
        } else {
            // A string or a buffer
            if (options.columns === false) {
                throw Error("Invalid Option: objname field must be combined with columns or be defined as an index");
            }
        }
    }
    // Normalize option `on_record`
    if (options.on_record === undefined || options.on_record === null) {
        options.on_record = undefined;
    } else if (typeof options.on_record !== "function") {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_OPTION_ON_RECORD", [
            "Invalid option `on_record`:",
            "expect a function,",
            `got ${JSON.stringify(options.on_record)}`
        ], options);
    }
    // Normalize option `on_skip`
    // options.on_skip ??= (err, chunk) => {
    //   this.emit('skip', err, chunk);
    // };
    if (options.on_skip !== undefined && options.on_skip !== null && typeof options.on_skip !== "function") {
        throw new Error(`Invalid Option: on_skip must be a function, got ${JSON.stringify(options.on_skip)}`);
    }
    // Normalize option `quote`
    if (options.quote === null || options.quote === false || options.quote === "") {
        options.quote = null;
    } else {
        if (options.quote === undefined || options.quote === true) {
            options.quote = Buffer.from('"', options.encoding);
        } else if (typeof options.quote === "string") {
            options.quote = Buffer.from(options.quote, options.encoding);
        }
        if (!Buffer.isBuffer(options.quote)) {
            throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`);
        }
    }
    // Normalize option `raw`
    if (options.raw === undefined || options.raw === null || options.raw === false) {
        options.raw = false;
    } else if (options.raw !== true) {
        throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`);
    }
    // Normalize option `record_delimiter`
    if (options.record_delimiter === undefined) {
        options.record_delimiter = [];
    } else if (typeof options.record_delimiter === "string" || Buffer.isBuffer(options.record_delimiter)) {
        if (options.record_delimiter.length === 0) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_OPTION_RECORD_DELIMITER", [
                "Invalid option `record_delimiter`:",
                "value must be a non empty string or buffer,",
                `got ${JSON.stringify(options.record_delimiter)}`
            ], options);
        }
        options.record_delimiter = [
            options.record_delimiter
        ];
    } else if (!Array.isArray(options.record_delimiter)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_OPTION_RECORD_DELIMITER", [
            "Invalid option `record_delimiter`:",
            "value must be a string, a buffer or array of string|buffer,",
            `got ${JSON.stringify(options.record_delimiter)}`
        ], options);
    }
    options.record_delimiter = options.record_delimiter.map(function(rd, i) {
        if (typeof rd !== "string" && !Buffer.isBuffer(rd)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_OPTION_RECORD_DELIMITER", [
                "Invalid option `record_delimiter`:",
                "value must be a string, a buffer or array of string|buffer",
                `at index ${i},`,
                `got ${JSON.stringify(rd)}`
            ], options);
        } else if (rd.length === 0) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_OPTION_RECORD_DELIMITER", [
                "Invalid option `record_delimiter`:",
                "value must be a non empty string or buffer",
                `at index ${i},`,
                `got ${JSON.stringify(rd)}`
            ], options);
        }
        if (typeof rd === "string") {
            rd = Buffer.from(rd, options.encoding);
        }
        return rd;
    });
    // Normalize option `relax_column_count`
    if (typeof options.relax_column_count === "boolean") {
    // Great, nothing to do
    } else if (options.relax_column_count === undefined || options.relax_column_count === null) {
        options.relax_column_count = false;
    } else {
        throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`);
    }
    if (typeof options.relax_column_count_less === "boolean") {
    // Great, nothing to do
    } else if (options.relax_column_count_less === undefined || options.relax_column_count_less === null) {
        options.relax_column_count_less = false;
    } else {
        throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`);
    }
    if (typeof options.relax_column_count_more === "boolean") {
    // Great, nothing to do
    } else if (options.relax_column_count_more === undefined || options.relax_column_count_more === null) {
        options.relax_column_count_more = false;
    } else {
        throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`);
    }
    // Normalize option `relax_quotes`
    if (typeof options.relax_quotes === "boolean") {
    // Great, nothing to do
    } else if (options.relax_quotes === undefined || options.relax_quotes === null) {
        options.relax_quotes = false;
    } else {
        throw new Error(`Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(options.relax_quotes)}`);
    }
    // Normalize option `skip_empty_lines`
    if (typeof options.skip_empty_lines === "boolean") {
    // Great, nothing to do
    } else if (options.skip_empty_lines === undefined || options.skip_empty_lines === null) {
        options.skip_empty_lines = false;
    } else {
        throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`);
    }
    // Normalize option `skip_records_with_empty_values`
    if (typeof options.skip_records_with_empty_values === "boolean") {
    // Great, nothing to do
    } else if (options.skip_records_with_empty_values === undefined || options.skip_records_with_empty_values === null) {
        options.skip_records_with_empty_values = false;
    } else {
        throw new Error(`Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_records_with_empty_values)}`);
    }
    // Normalize option `skip_records_with_error`
    if (typeof options.skip_records_with_error === "boolean") {
    // Great, nothing to do
    } else if (options.skip_records_with_error === undefined || options.skip_records_with_error === null) {
        options.skip_records_with_error = false;
    } else {
        throw new Error(`Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(options.skip_records_with_error)}`);
    }
    // Normalize option `rtrim`
    if (options.rtrim === undefined || options.rtrim === null || options.rtrim === false) {
        options.rtrim = false;
    } else if (options.rtrim !== true) {
        throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`);
    }
    // Normalize option `ltrim`
    if (options.ltrim === undefined || options.ltrim === null || options.ltrim === false) {
        options.ltrim = false;
    } else if (options.ltrim !== true) {
        throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`);
    }
    // Normalize option `trim`
    if (options.trim === undefined || options.trim === null || options.trim === false) {
        options.trim = false;
    } else if (options.trim !== true) {
        throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`);
    }
    // Normalize options `trim`, `ltrim` and `rtrim`
    if (options.trim === true && opts.ltrim !== false) {
        options.ltrim = true;
    } else if (options.ltrim !== true) {
        options.ltrim = false;
    }
    if (options.trim === true && opts.rtrim !== false) {
        options.rtrim = true;
    } else if (options.rtrim !== true) {
        options.rtrim = false;
    }
    // Normalize option `to`
    if (options.to === undefined || options.to === null) {
        options.to = -1;
    } else {
        if (typeof options.to === "string" && /\d+/.test(options.to)) {
            options.to = parseInt(options.to);
        }
        if (Number.isInteger(options.to)) {
            if (options.to <= 0) {
                throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`);
            }
        } else {
            throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`);
        }
    }
    // Normalize option `to_line`
    if (options.to_line === undefined || options.to_line === null) {
        options.to_line = -1;
    } else {
        if (typeof options.to_line === "string" && /\d+/.test(options.to_line)) {
            options.to_line = parseInt(options.to_line);
        }
        if (Number.isInteger(options.to_line)) {
            if (options.to_line <= 0) {
                throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`);
            }
        } else {
            throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`);
        }
    }
    return options;
};
;
}),
"[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/index.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "transform": ()=>transform
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$normalize_columns_array$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/normalize_columns_array.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$init_state$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/init_state.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$normalize_options$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/normalize_options.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/CsvError.js [app-route] (ecmascript)");
;
;
;
;
const isRecordEmpty = function(record) {
    return record.every((field)=>field == null || field.toString && field.toString().trim() === "");
};
const cr = 13; // `\r`, carriage return, 0x0D in hexadcimal, 13 in decimal
const nl = 10; // `\n`, newline, 0x0A in hexadecimal, 10 in decimal
const boms = {
    // Note, the following are equals:
    // Buffer.from("\ufeff")
    // Buffer.from([239, 187, 191])
    // Buffer.from('EFBBBF', 'hex')
    utf8: Buffer.from([
        239,
        187,
        191
    ]),
    // Note, the following are equals:
    // Buffer.from "\ufeff", 'utf16le
    // Buffer.from([255, 254])
    utf16le: Buffer.from([
        255,
        254
    ])
};
const transform = function(original_options = {}) {
    const info = {
        bytes: 0,
        comment_lines: 0,
        empty_lines: 0,
        invalid_field_length: 0,
        lines: 1,
        records: 0
    };
    const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$normalize_options$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalize_options"])(original_options);
    return {
        info: info,
        original_options: original_options,
        options: options,
        state: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$init_state$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["init_state"])(options),
        __needMoreData: function(i, bufLen, end) {
            if (end) return false;
            const { encoding, escape, quote } = this.options;
            const { quoting, needMoreDataSize, recordDelimiterMaxLength } = this.state;
            const numOfCharLeft = bufLen - i - 1;
            const requiredLength = Math.max(needMoreDataSize, // Skip if the remaining buffer smaller than record delimiter
            // If "record_delimiter" is yet to be discovered:
            // 1. It is equals to `[]` and "recordDelimiterMaxLength" equals `0`
            // 2. We set the length to windows line ending in the current encoding
            // Note, that encoding is known from user or bom discovery at that point
            // recordDelimiterMaxLength,
            recordDelimiterMaxLength === 0 ? Buffer.from("\r\n", encoding).length : recordDelimiterMaxLength, // Skip if remaining buffer can be an escaped quote
            quoting ? (escape === null ? 0 : escape.length) + quote.length : 0, // Skip if remaining buffer can be record delimiter following the closing quote
            quoting ? quote.length + recordDelimiterMaxLength : 0);
            return numOfCharLeft < requiredLength;
        },
        // Central parser implementation
        parse: function(nextBuf, end, push, close) {
            const { bom, comment_no_infix, encoding, from_line, ltrim, max_record_size, raw, relax_quotes, rtrim, skip_empty_lines, to, to_line } = this.options;
            let { comment, escape, quote, record_delimiter } = this.options;
            const { bomSkipped, previousBuf, rawBuffer, escapeIsQuote } = this.state;
            let buf;
            if (previousBuf === undefined) {
                if (nextBuf === undefined) {
                    // Handle empty string
                    close();
                    return;
                } else {
                    buf = nextBuf;
                }
            } else if (previousBuf !== undefined && nextBuf === undefined) {
                buf = previousBuf;
            } else {
                buf = Buffer.concat([
                    previousBuf,
                    nextBuf
                ]);
            }
            // Handle UTF BOM
            if (bomSkipped === false) {
                if (bom === false) {
                    this.state.bomSkipped = true;
                } else if (buf.length < 3) {
                    // No enough data
                    if (end === false) {
                        // Wait for more data
                        this.state.previousBuf = buf;
                        return;
                    }
                } else {
                    for(const encoding in boms){
                        if (boms[encoding].compare(buf, 0, boms[encoding].length) === 0) {
                            // Skip BOM
                            const bomLength = boms[encoding].length;
                            this.state.bufBytesStart += bomLength;
                            buf = buf.slice(bomLength);
                            // Renormalize original options with the new encoding
                            this.options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$normalize_options$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalize_options"])({
                                ...this.original_options,
                                encoding: encoding
                            });
                            // Options will re-evaluate the Buffer with the new encoding
                            ({ comment, escape, quote } = this.options);
                            break;
                        }
                    }
                    this.state.bomSkipped = true;
                }
            }
            const bufLen = buf.length;
            let pos;
            for(pos = 0; pos < bufLen; pos++){
                // Ensure we get enough space to look ahead
                // There should be a way to move this out of the loop
                if (this.__needMoreData(pos, bufLen, end)) {
                    break;
                }
                if (this.state.wasRowDelimiter === true) {
                    this.info.lines++;
                    this.state.wasRowDelimiter = false;
                }
                if (to_line !== -1 && this.info.lines > to_line) {
                    this.state.stop = true;
                    close();
                    return;
                }
                // Auto discovery of record_delimiter, unix, mac and windows supported
                if (this.state.quoting === false && record_delimiter.length === 0) {
                    const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);
                    if (record_delimiterCount) {
                        record_delimiter = this.options.record_delimiter;
                    }
                }
                const chr = buf[pos];
                if (raw === true) {
                    rawBuffer.append(chr);
                }
                if ((chr === cr || chr === nl) && this.state.wasRowDelimiter === false) {
                    this.state.wasRowDelimiter = true;
                }
                // Previous char was a valid escape char
                // treat the current char as a regular char
                if (this.state.escaping === true) {
                    this.state.escaping = false;
                } else {
                    // Escape is only active inside quoted fields
                    // We are quoting, the char is an escape chr and there is a chr to escape
                    // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){
                    if (escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen) {
                        if (escapeIsQuote) {
                            if (this.__isQuote(buf, pos + escape.length)) {
                                this.state.escaping = true;
                                pos += escape.length - 1;
                                continue;
                            }
                        } else {
                            this.state.escaping = true;
                            pos += escape.length - 1;
                            continue;
                        }
                    }
                    // Not currently escaping and chr is a quote
                    // TODO: need to compare bytes instead of single char
                    if (this.state.commenting === false && this.__isQuote(buf, pos)) {
                        if (this.state.quoting === true) {
                            const nextChr = buf[pos + quote.length];
                            const isNextChrTrimable = rtrim && this.__isCharTrimable(buf, pos + quote.length);
                            const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + quote.length, nextChr);
                            const isNextChrDelimiter = this.__isDelimiter(buf, pos + quote.length, nextChr);
                            const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length) : this.__isRecordDelimiter(nextChr, buf, pos + quote.length);
                            // Escape a quote
                            // Treat next char as a regular character
                            if (escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)) {
                                pos += escape.length - 1;
                            } else if (!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable) {
                                this.state.quoting = false;
                                this.state.wasQuoting = true;
                                pos += quote.length - 1;
                                continue;
                            } else if (relax_quotes === false) {
                                const err = this.__error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_CLOSING_QUOTE", [
                                    "Invalid Closing Quote:",
                                    `got "${String.fromCharCode(nextChr)}"`,
                                    `at line ${this.info.lines}`,
                                    "instead of delimiter, record delimiter, trimable character",
                                    "(if activated) or comment"
                                ], this.options, this.__infoField()));
                                if (err !== undefined) return err;
                            } else {
                                this.state.quoting = false;
                                this.state.wasQuoting = true;
                                this.state.field.prepend(quote);
                                pos += quote.length - 1;
                            }
                        } else {
                            if (this.state.field.length !== 0) {
                                // In relax_quotes mode, treat opening quote preceded by chrs as regular
                                if (relax_quotes === false) {
                                    const info = this.__infoField();
                                    const bom = Object.keys(boms).map((b)=>boms[b].equals(this.state.field.toString()) ? b : false).filter(Boolean)[0];
                                    const err = this.__error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("INVALID_OPENING_QUOTE", [
                                        "Invalid Opening Quote:",
                                        `a quote is found on field ${JSON.stringify(info.column)} at line ${info.lines}, value is ${JSON.stringify(this.state.field.toString(encoding))}`,
                                        bom ? `(${bom} bom)` : undefined
                                    ], this.options, info, {
                                        field: this.state.field
                                    }));
                                    if (err !== undefined) return err;
                                }
                            } else {
                                this.state.quoting = true;
                                pos += quote.length - 1;
                                continue;
                            }
                        }
                    }
                    if (this.state.quoting === false) {
                        const recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);
                        if (recordDelimiterLength !== 0) {
                            // Do not emit comments which take a full line
                            const skipCommentLine = this.state.commenting && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0;
                            if (skipCommentLine) {
                                this.info.comment_lines++;
                            // Skip full comment line
                            } else {
                                // Activate records emition if above from_line
                                if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {
                                    this.state.enabled = true;
                                    this.__resetField();
                                    this.__resetRecord();
                                    pos += recordDelimiterLength - 1;
                                    continue;
                                }
                                // Skip if line is empty and skip_empty_lines activated
                                if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {
                                    this.info.empty_lines++;
                                    pos += recordDelimiterLength - 1;
                                    continue;
                                }
                                this.info.bytes = this.state.bufBytesStart + pos;
                                const errField = this.__onField();
                                if (errField !== undefined) return errField;
                                this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;
                                const errRecord = this.__onRecord(push);
                                if (errRecord !== undefined) return errRecord;
                                if (to !== -1 && this.info.records >= to) {
                                    this.state.stop = true;
                                    close();
                                    return;
                                }
                            }
                            this.state.commenting = false;
                            pos += recordDelimiterLength - 1;
                            continue;
                        }
                        if (this.state.commenting) {
                            continue;
                        }
                        if (comment !== null && (comment_no_infix === false || this.state.record.length === 0 && this.state.field.length === 0)) {
                            const commentCount = this.__compareBytes(comment, buf, pos, chr);
                            if (commentCount !== 0) {
                                this.state.commenting = true;
                                continue;
                            }
                        }
                        const delimiterLength = this.__isDelimiter(buf, pos, chr);
                        if (delimiterLength !== 0) {
                            this.info.bytes = this.state.bufBytesStart + pos;
                            const errField = this.__onField();
                            if (errField !== undefined) return errField;
                            pos += delimiterLength - 1;
                            continue;
                        }
                    }
                }
                if (this.state.commenting === false) {
                    if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {
                        return this.__error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_MAX_RECORD_SIZE", [
                            "Max Record Size:",
                            "record exceed the maximum number of tolerated bytes",
                            `of ${max_record_size}`,
                            `at line ${this.info.lines}`
                        ], this.options, this.__infoField()));
                    }
                }
                const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(buf, pos);
                // rtrim in non quoting is handle in __onField
                const rappend = rtrim === false || this.state.wasQuoting === false;
                if (lappend === true && rappend === true) {
                    this.state.field.append(chr);
                } else if (rtrim === true && !this.__isCharTrimable(buf, pos)) {
                    return this.__error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE", [
                        "Invalid Closing Quote:",
                        "found non trimable byte after quote",
                        `at line ${this.info.lines}`
                    ], this.options, this.__infoField()));
                } else {
                    if (lappend === false) {
                        pos += this.__isCharTrimable(buf, pos) - 1;
                    }
                    continue;
                }
            }
            if (end === true) {
                // Ensure we are not ending in a quoting state
                if (this.state.quoting === true) {
                    const err = this.__error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_QUOTE_NOT_CLOSED", [
                        "Quote Not Closed:",
                        `the parsing is finished with an opening quote at line ${this.info.lines}`
                    ], this.options, this.__infoField()));
                    if (err !== undefined) return err;
                } else {
                    // Skip last line if it has no characters
                    if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {
                        this.info.bytes = this.state.bufBytesStart + pos;
                        const errField = this.__onField();
                        if (errField !== undefined) return errField;
                        const errRecord = this.__onRecord(push);
                        if (errRecord !== undefined) return errRecord;
                    } else if (this.state.wasRowDelimiter === true) {
                        this.info.empty_lines++;
                    } else if (this.state.commenting === true) {
                        this.info.comment_lines++;
                    }
                }
            } else {
                this.state.bufBytesStart += pos;
                this.state.previousBuf = buf.slice(pos);
            }
            if (this.state.wasRowDelimiter === true) {
                this.info.lines++;
                this.state.wasRowDelimiter = false;
            }
        },
        __onRecord: function(push) {
            const { columns, group_columns_by_name, encoding, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_records_with_empty_values } = this.options;
            const { enabled, record } = this.state;
            if (enabled === false) {
                return this.__resetRecord();
            }
            // Convert the first line into column names
            const recordLength = record.length;
            if (columns === true) {
                if (skip_records_with_empty_values === true && isRecordEmpty(record)) {
                    this.__resetRecord();
                    return;
                }
                return this.__firstLineToColumns(record);
            }
            if (columns === false && this.info.records === 0) {
                this.state.expectedRecordLength = recordLength;
            }
            if (recordLength !== this.state.expectedRecordLength) {
                const err = columns === false ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_RECORD_INCONSISTENT_FIELDS_LENGTH", [
                    "Invalid Record Length:",
                    `expect ${this.state.expectedRecordLength},`,
                    `got ${recordLength} on line ${this.info.lines}`
                ], this.options, this.__infoField(), {
                    record: record
                }) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_RECORD_INCONSISTENT_COLUMNS", [
                    "Invalid Record Length:",
                    `columns length is ${columns.length},`,
                    `got ${recordLength} on line ${this.info.lines}`
                ], this.options, this.__infoField(), {
                    record: record
                });
                if (relax_column_count === true || relax_column_count_less === true && recordLength < this.state.expectedRecordLength || relax_column_count_more === true && recordLength > this.state.expectedRecordLength) {
                    this.info.invalid_field_length++;
                    this.state.error = err;
                // Error is undefined with skip_records_with_error
                } else {
                    const finalErr = this.__error(err);
                    if (finalErr) return finalErr;
                }
            }
            if (skip_records_with_empty_values === true && isRecordEmpty(record)) {
                this.__resetRecord();
                return;
            }
            if (this.state.recordHasError === true) {
                this.__resetRecord();
                this.state.recordHasError = false;
                return;
            }
            this.info.records++;
            if (from === 1 || this.info.records >= from) {
                const { objname } = this.options;
                // With columns, records are object
                if (columns !== false) {
                    const obj = {};
                    // Transform record array to an object
                    for(let i = 0, l = record.length; i < l; i++){
                        if (columns[i] === undefined || columns[i].disabled) continue;
                        // Turn duplicate columns into an array
                        if (group_columns_by_name === true && obj[columns[i].name] !== undefined) {
                            if (Array.isArray(obj[columns[i].name])) {
                                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);
                            } else {
                                obj[columns[i].name] = [
                                    obj[columns[i].name],
                                    record[i]
                                ];
                            }
                        } else {
                            obj[columns[i].name] = record[i];
                        }
                    }
                    // Without objname (default)
                    if (raw === true || info === true) {
                        const extRecord = Object.assign({
                            record: obj
                        }, raw === true ? {
                            raw: this.state.rawBuffer.toString(encoding)
                        } : {}, info === true ? {
                            info: this.__infoRecord()
                        } : {});
                        const err = this.__push(objname === undefined ? extRecord : [
                            obj[objname],
                            extRecord
                        ], push);
                        if (err) {
                            return err;
                        }
                    } else {
                        const err = this.__push(objname === undefined ? obj : [
                            obj[objname],
                            obj
                        ], push);
                        if (err) {
                            return err;
                        }
                    }
                // Without columns, records are array
                } else {
                    if (raw === true || info === true) {
                        const extRecord = Object.assign({
                            record: record
                        }, raw === true ? {
                            raw: this.state.rawBuffer.toString(encoding)
                        } : {}, info === true ? {
                            info: this.__infoRecord()
                        } : {});
                        const err = this.__push(objname === undefined ? extRecord : [
                            record[objname],
                            extRecord
                        ], push);
                        if (err) {
                            return err;
                        }
                    } else {
                        const err = this.__push(objname === undefined ? record : [
                            record[objname],
                            record
                        ], push);
                        if (err) {
                            return err;
                        }
                    }
                }
            }
            this.__resetRecord();
        },
        __firstLineToColumns: function(record) {
            const { firstLineToHeaders } = this.state;
            try {
                const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);
                if (!Array.isArray(headers)) {
                    return this.__error(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_COLUMN_MAPPING", [
                        "Invalid Column Mapping:",
                        "expect an array from column function,",
                        `got ${JSON.stringify(headers)}`
                    ], this.options, this.__infoField(), {
                        headers: headers
                    }));
                }
                const normalizedHeaders = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$normalize_columns_array$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalize_columns_array"])(headers);
                this.state.expectedRecordLength = normalizedHeaders.length;
                this.options.columns = normalizedHeaders;
                this.__resetRecord();
                return;
            } catch (err) {
                return err;
            }
        },
        __resetRecord: function() {
            if (this.options.raw === true) {
                this.state.rawBuffer.reset();
            }
            this.state.error = undefined;
            this.state.record = [];
            this.state.record_length = 0;
        },
        __onField: function() {
            const { cast, encoding, rtrim, max_record_size } = this.options;
            const { enabled, wasQuoting } = this.state;
            // Short circuit for the from_line options
            if (enabled === false) {
                return this.__resetField();
            }
            let field = this.state.field.toString(encoding);
            if (rtrim === true && wasQuoting === false) {
                field = field.trimRight();
            }
            if (cast === true) {
                const [err, f] = this.__cast(field);
                if (err !== undefined) return err;
                field = f;
            }
            this.state.record.push(field);
            // Increment record length if record size must not exceed a limit
            if (max_record_size !== 0 && typeof field === "string") {
                this.state.record_length += field.length;
            }
            this.__resetField();
        },
        __resetField: function() {
            this.state.field.reset();
            this.state.wasQuoting = false;
        },
        __push: function(record, push) {
            const { on_record } = this.options;
            if (on_record !== undefined) {
                const info = this.__infoRecord();
                try {
                    record = on_record.call(null, record, info);
                } catch (err) {
                    return err;
                }
                if (record === undefined || record === null) {
                    return;
                }
            }
            push(record);
        },
        // Return a tuple with the error and the casted value
        __cast: function(field) {
            const { columns, relax_column_count } = this.options;
            const isColumns = Array.isArray(columns);
            // Dont loose time calling cast
            // because the final record is an object
            // and this field can't be associated to a key present in columns
            if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {
                return [
                    undefined,
                    undefined
                ];
            }
            if (this.state.castField !== null) {
                try {
                    const info = this.__infoField();
                    return [
                        undefined,
                        this.state.castField.call(null, field, info)
                    ];
                } catch (err) {
                    return [
                        err
                    ];
                }
            }
            if (this.__isFloat(field)) {
                return [
                    undefined,
                    parseFloat(field)
                ];
            } else if (this.options.cast_date !== false) {
                const info = this.__infoField();
                return [
                    undefined,
                    this.options.cast_date.call(null, field, info)
                ];
            }
            return [
                undefined,
                field
            ];
        },
        // Helper to test if a character is a space or a line delimiter
        __isCharTrimable: function(buf, pos) {
            const isTrim = (buf, pos)=>{
                const { timchars } = this.state;
                loop1: for(let i = 0; i < timchars.length; i++){
                    const timchar = timchars[i];
                    for(let j = 0; j < timchar.length; j++){
                        if (timchar[j] !== buf[pos + j]) continue loop1;
                    }
                    return timchar.length;
                }
                return 0;
            };
            return isTrim(buf, pos);
        },
        // Keep it in case we implement the `cast_int` option
        // __isInt(value){
        //   // return Number.isInteger(parseInt(value))
        //   // return !isNaN( parseInt( obj ) );
        //   return /^(\-|\+)?[1-9][0-9]*$/.test(value)
        // }
        __isFloat: function(value) {
            return value - parseFloat(value) + 1 >= 0; // Borrowed from jquery
        },
        __compareBytes: function(sourceBuf, targetBuf, targetPos, firstByte) {
            if (sourceBuf[0] !== firstByte) return 0;
            const sourceLength = sourceBuf.length;
            for(let i = 1; i < sourceLength; i++){
                if (sourceBuf[i] !== targetBuf[targetPos + i]) return 0;
            }
            return sourceLength;
        },
        __isDelimiter: function(buf, pos, chr) {
            const { delimiter, ignore_last_delimiters } = this.options;
            if (ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1) {
                return 0;
            } else if (ignore_last_delimiters !== false && typeof ignore_last_delimiters === "number" && this.state.record.length === ignore_last_delimiters - 1) {
                return 0;
            }
            loop1: for(let i = 0; i < delimiter.length; i++){
                const del = delimiter[i];
                if (del[0] === chr) {
                    for(let j = 1; j < del.length; j++){
                        if (del[j] !== buf[pos + j]) continue loop1;
                    }
                    return del.length;
                }
            }
            return 0;
        },
        __isRecordDelimiter: function(chr, buf, pos) {
            const { record_delimiter } = this.options;
            const recordDelimiterLength = record_delimiter.length;
            loop1: for(let i = 0; i < recordDelimiterLength; i++){
                const rd = record_delimiter[i];
                const rdLength = rd.length;
                if (rd[0] !== chr) {
                    continue;
                }
                for(let j = 1; j < rdLength; j++){
                    if (rd[j] !== buf[pos + j]) {
                        continue loop1;
                    }
                }
                return rd.length;
            }
            return 0;
        },
        __isEscape: function(buf, pos, chr) {
            const { escape } = this.options;
            if (escape === null) return false;
            const l = escape.length;
            if (escape[0] === chr) {
                for(let i = 0; i < l; i++){
                    if (escape[i] !== buf[pos + i]) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        },
        __isQuote: function(buf, pos) {
            const { quote } = this.options;
            if (quote === null) return false;
            const l = quote.length;
            for(let i = 0; i < l; i++){
                if (quote[i] !== buf[pos + i]) {
                    return false;
                }
            }
            return true;
        },
        __autoDiscoverRecordDelimiter: function(buf, pos) {
            const { encoding } = this.options;
            // Note, we don't need to cache this information in state,
            // It is only called on the first line until we find out a suitable
            // record delimiter.
            const rds = [
                // Important, the windows line ending must be before mac os 9
                Buffer.from("\r\n", encoding),
                Buffer.from("\n", encoding),
                Buffer.from("\r", encoding)
            ];
            loop: for(let i = 0; i < rds.length; i++){
                const l = rds[i].length;
                for(let j = 0; j < l; j++){
                    if (rds[i][j] !== buf[pos + j]) {
                        continue loop;
                    }
                }
                this.options.record_delimiter.push(rds[i]);
                this.state.recordDelimiterMaxLength = rds[i].length;
                return rds[i].length;
            }
            return 0;
        },
        __error: function(msg) {
            const { encoding, raw, skip_records_with_error } = this.options;
            const err = typeof msg === "string" ? new Error(msg) : msg;
            if (skip_records_with_error) {
                this.state.recordHasError = true;
                if (this.options.on_skip !== undefined) {
                    this.options.on_skip(err, raw ? this.state.rawBuffer.toString(encoding) : undefined);
                }
                // this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);
                return undefined;
            } else {
                return err;
            }
        },
        __infoDataSet: function() {
            return {
                ...this.info,
                columns: this.options.columns
            };
        },
        __infoRecord: function() {
            const { columns, raw, encoding } = this.options;
            return {
                ...this.__infoDataSet(),
                error: this.state.error,
                header: columns === true,
                index: this.state.record.length,
                raw: raw ? this.state.rawBuffer.toString(encoding) : undefined
            };
        },
        __infoField: function() {
            const { columns } = this.options;
            const isColumns = Array.isArray(columns);
            return {
                ...this.__infoRecord(),
                column: isColumns === true ? columns.length > this.state.record.length ? columns[this.state.record.length].name : null : this.state.record.length,
                quoting: this.state.wasQuoting
            };
        }
    };
};
;
}),
"[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/index.js [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$normalize_columns_array$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/normalize_columns_array.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$init_state$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/init_state.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$normalize_options$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/normalize_options.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/CsvError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/index.js [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/index.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

/*
CSV Parse

Please look at the [project documentation](https://csv.js.org/parse/) for
additional information.
*/ __turbopack_context__.s({
    "Parser": ()=>Parser,
    "parse": ()=>parse
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$utils$2f$is_object$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/utils/is_object.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/CsvError.js [app-route] (ecmascript)");
;
;
;
;
class Parser extends __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["Transform"] {
    constructor(opts = {}){
        super({
            ...{
                readableObjectMode: true
            },
            ...opts,
            encoding: null
        });
        this.api = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["transform"])({
            on_skip: (err, chunk)=>{
                this.emit("skip", err, chunk);
            },
            ...opts
        });
        // Backward compatibility
        this.state = this.api.state;
        this.options = this.api.options;
        this.info = this.api.info;
    }
    // Implementation of `Transform._transform`
    _transform(buf, _, callback) {
        if (this.state.stop === true) {
            return;
        }
        const err = this.api.parse(buf, false, (record)=>{
            this.push(record);
        }, ()=>{
            this.push(null);
            this.end();
            // Fix #333 and break #410
            //   ko: api.stream.iterator.coffee
            //   ko with v21.4.0, ok with node v20.5.1: api.stream.finished # aborted (with generate())
            //   ko: api.stream.finished # aborted (with Readable)
            // this.destroy()
            // Fix #410 and partially break #333
            //   ok: api.stream.iterator.coffee
            //   ok: api.stream.finished # aborted (with generate())
            //   broken: api.stream.finished # aborted (with Readable)
            this.on("end", this.destroy);
        });
        if (err !== undefined) {
            this.state.stop = true;
        }
        callback(err);
    }
    // Implementation of `Transform._flush`
    _flush(callback) {
        if (this.state.stop === true) {
            return;
        }
        const err = this.api.parse(undefined, true, (record)=>{
            this.push(record);
        }, ()=>{
            this.push(null);
            this.on("end", this.destroy);
        });
        callback(err);
    }
}
const parse = function() {
    let data, options, callback;
    for(const i in arguments){
        const argument = arguments[i];
        const type = typeof argument;
        if (data === undefined && (typeof argument === "string" || Buffer.isBuffer(argument))) {
            data = argument;
        } else if (options === undefined && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$utils$2f$is_object$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["is_object"])(argument)) {
            options = argument;
        } else if (callback === undefined && type === "function") {
            callback = argument;
        } else {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_ARGUMENT", [
                "Invalid argument:",
                `got ${JSON.stringify(argument)} at index ${i}`
            ], options || {});
        }
    }
    const parser = new Parser(options);
    if (callback) {
        const records = options === undefined || options.objname === undefined ? [] : {};
        parser.on("readable", function() {
            let record;
            while((record = this.read()) !== null){
                if (options === undefined || options.objname === undefined) {
                    records.push(record);
                } else {
                    records[record[0]] = record[1];
                }
            }
        });
        parser.on("error", function(err) {
            callback(err, undefined, parser.api.__infoDataSet());
        });
        parser.on("end", function() {
            callback(undefined, records, parser.api.__infoDataSet());
        });
    }
    if (data !== undefined) {
        const writer = function() {
            parser.write(data);
            parser.end();
        };
        // Support Deno, Rollup doesnt provide a shim for setImmediate
        if (typeof setImmediate === "function") {
            setImmediate(writer);
        } else {
            setTimeout(writer, 0);
        }
    }
    return parser;
};
;
}),
"[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/index.js [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$utils$2f$is_object$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/utils/is_object.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/api/CsvError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/index.js [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/api/CsvError.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "CsvError": ()=>CsvError
});
class CsvError extends Error {
    constructor(code, message, ...contexts){
        if (Array.isArray(message)) message = message.join(" ");
        super(message);
        if (Error.captureStackTrace !== undefined) {
            Error.captureStackTrace(this, CsvError);
        }
        this.code = code;
        for (const context of contexts){
            for(const key in context){
                const value = context[key];
                this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));
            }
        }
    }
}
;
}),
"[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/utils/is_object.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "is_object": ()=>is_object
});
const is_object = function(obj) {
    return typeof obj === "object" && obj !== null && !Array.isArray(obj);
};
;
}),
"[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/utils/get.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// Lodash implementation of `get`
__turbopack_context__.s({
    "get": ()=>get
});
const charCodeOfDot = ".".charCodeAt(0);
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp(// Match anything that isn't a dot or bracket.
"[^.[\\]]+" + "|" + // Or match property names within brackets.
"\\[(?:" + // Match a non-string expression.
"([^\"'][^[]*)" + "|" + // Or match strings (supports escaping characters).
"([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2" + ")\\]" + "|" + // Or match "" as the space between consecutive dots or empty brackets.
"(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))", "g");
const reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
const reIsPlainProp = /^\w*$/;
const getTag = function(value) {
    // if (!value) value === undefined ? "[object Undefined]" : "[object Null]";
    return Object.prototype.toString.call(value);
};
const isSymbol = function(value) {
    const type = typeof value;
    return type === "symbol" || type === "object" && value && getTag(value) === "[object Symbol]";
};
const isKey = function(value, object) {
    if (Array.isArray(value)) {
        return false;
    }
    const type = typeof value;
    if (type === "number" || type === "symbol" || type === "boolean" || !value || isSymbol(value)) {
        return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
};
const stringToPath = function(string) {
    const result = [];
    if (string.charCodeAt(0) === charCodeOfDot) {
        result.push("");
    }
    string.replace(rePropName, function(match, expression, quote, subString) {
        let key = match;
        if (quote) {
            key = subString.replace(reEscapeChar, "$1");
        } else if (expression) {
            key = expression.trim();
        }
        result.push(key);
    });
    return result;
};
const castPath = function(value, object) {
    if (Array.isArray(value)) {
        return value;
    } else {
        return isKey(value, object) ? [
            value
        ] : stringToPath(value);
    }
};
const toKey = function(value) {
    if (typeof value === "string" || isSymbol(value)) return value;
    const result = `${value}`;
    // eslint-disable-next-line
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
};
const get = function(object, path) {
    path = castPath(path, object);
    let index = 0;
    const length = path.length;
    while(object != null && index < length){
        object = object[toKey(path[index++])];
    }
    return index && index === length ? object : undefined;
};
;
}),
"[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/api/normalize_columns.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "normalize_columns": ()=>normalize_columns
});
const normalize_columns = function(columns) {
    if (columns === undefined || columns === null) {
        return [
            undefined,
            undefined
        ];
    }
    if (typeof columns !== "object") {
        return [
            Error('Invalid option "columns": expect an array or an object')
        ];
    }
    if (!Array.isArray(columns)) {
        const newcolumns = [];
        for(const k in columns){
            newcolumns.push({
                key: k,
                header: columns[k]
            });
        }
        columns = newcolumns;
    } else {
        const newcolumns = [];
        for (const column of columns){
            if (typeof column === "string") {
                newcolumns.push({
                    key: column,
                    header: column
                });
            } else if (typeof column === "object" && column !== null && !Array.isArray(column)) {
                if (!column.key) {
                    return [
                        Error('Invalid column definition: property "key" is required')
                    ];
                }
                if (column.header === undefined) {
                    column.header = column.key;
                }
                newcolumns.push(column);
            } else {
                return [
                    Error("Invalid column definition: expect a string or an object")
                ];
            }
        }
        columns = newcolumns;
    }
    return [
        undefined,
        columns
    ];
};
;
}),
"[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/utils/underscore.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "underscore": ()=>underscore
});
const underscore = function(str) {
    return str.replace(/([A-Z])/g, function(_, match) {
        return "_" + match.toLowerCase();
    });
};
;
}),
"[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/api/normalize_options.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "normalize_options": ()=>normalize_options
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/api/CsvError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$normalize_columns$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/api/normalize_columns.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$utils$2f$underscore$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/utils/underscore.js [app-route] (ecmascript)");
;
;
;
const normalize_options = function(opts) {
    const options = {};
    // Merge with user options
    for(const opt in opts){
        options[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$utils$2f$underscore$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["underscore"])(opt)] = opts[opt];
    }
    // Normalize option `bom`
    if (options.bom === undefined || options.bom === null || options.bom === false) {
        options.bom = false;
    } else if (options.bom !== true) {
        return [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_OPTION_BOOLEAN_INVALID_TYPE", [
                "option `bom` is optional and must be a boolean value,",
                `got ${JSON.stringify(options.bom)}`
            ])
        ];
    }
    // Normalize option `delimiter`
    if (options.delimiter === undefined || options.delimiter === null) {
        options.delimiter = ",";
    } else if (Buffer.isBuffer(options.delimiter)) {
        options.delimiter = options.delimiter.toString();
    } else if (typeof options.delimiter !== "string") {
        return [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_OPTION_DELIMITER_INVALID_TYPE", [
                "option `delimiter` must be a buffer or a string,",
                `got ${JSON.stringify(options.delimiter)}`
            ])
        ];
    }
    // Normalize option `quote`
    if (options.quote === undefined || options.quote === null) {
        options.quote = '"';
    } else if (options.quote === true) {
        options.quote = '"';
    } else if (options.quote === false) {
        options.quote = "";
    } else if (Buffer.isBuffer(options.quote)) {
        options.quote = options.quote.toString();
    } else if (typeof options.quote !== "string") {
        return [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_OPTION_QUOTE_INVALID_TYPE", [
                "option `quote` must be a boolean, a buffer or a string,",
                `got ${JSON.stringify(options.quote)}`
            ])
        ];
    }
    // Normalize option `quoted`
    if (options.quoted === undefined || options.quoted === null) {
        options.quoted = false;
    } else {
    // todo
    }
    // Normalize option `escape_formulas`
    if (options.escape_formulas === undefined || options.escape_formulas === null) {
        options.escape_formulas = false;
    } else if (typeof options.escape_formulas !== "boolean") {
        return [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_OPTION_ESCAPE_FORMULAS_INVALID_TYPE", [
                "option `escape_formulas` must be a boolean,",
                `got ${JSON.stringify(options.escape_formulas)}`
            ])
        ];
    }
    // Normalize option `quoted_empty`
    if (options.quoted_empty === undefined || options.quoted_empty === null) {
        options.quoted_empty = undefined;
    } else {
    // todo
    }
    // Normalize option `quoted_match`
    if (options.quoted_match === undefined || options.quoted_match === null || options.quoted_match === false) {
        options.quoted_match = null;
    } else if (!Array.isArray(options.quoted_match)) {
        options.quoted_match = [
            options.quoted_match
        ];
    }
    if (options.quoted_match) {
        for (const quoted_match of options.quoted_match){
            const isString = typeof quoted_match === "string";
            const isRegExp = quoted_match instanceof RegExp;
            if (!isString && !isRegExp) {
                return [
                    Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`)
                ];
            }
        }
    }
    // Normalize option `quoted_string`
    if (options.quoted_string === undefined || options.quoted_string === null) {
        options.quoted_string = false;
    } else {
    // todo
    }
    // Normalize option `eof`
    if (options.eof === undefined || options.eof === null) {
        options.eof = true;
    } else {
    // todo
    }
    // Normalize option `escape`
    if (options.escape === undefined || options.escape === null) {
        options.escape = '"';
    } else if (Buffer.isBuffer(options.escape)) {
        options.escape = options.escape.toString();
    } else if (typeof options.escape !== "string") {
        return [
            Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`)
        ];
    }
    if (options.escape.length > 1) {
        return [
            Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`)
        ];
    }
    // Normalize option `header`
    if (options.header === undefined || options.header === null) {
        options.header = false;
    } else {
    // todo
    }
    // Normalize option `columns`
    const [errColumns, columns] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$normalize_columns$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalize_columns"])(options.columns);
    if (errColumns !== undefined) return [
        errColumns
    ];
    options.columns = columns;
    // Normalize option `quoted`
    if (options.quoted === undefined || options.quoted === null) {
        options.quoted = false;
    } else {
    // todo
    }
    // Normalize option `cast`
    if (options.cast === undefined || options.cast === null) {
        options.cast = {};
    } else {
    // todo
    }
    // Normalize option cast.bigint
    if (options.cast.bigint === undefined || options.cast.bigint === null) {
        // Cast boolean to string by default
        options.cast.bigint = (value)=>"" + value;
    }
    // Normalize option cast.boolean
    if (options.cast.boolean === undefined || options.cast.boolean === null) {
        // Cast boolean to string by default
        options.cast.boolean = (value)=>value ? "1" : "";
    }
    // Normalize option cast.date
    if (options.cast.date === undefined || options.cast.date === null) {
        // Cast date to timestamp string by default
        options.cast.date = (value)=>"" + value.getTime();
    }
    // Normalize option cast.number
    if (options.cast.number === undefined || options.cast.number === null) {
        // Cast number to string using native casting by default
        options.cast.number = (value)=>"" + value;
    }
    // Normalize option cast.object
    if (options.cast.object === undefined || options.cast.object === null) {
        // Stringify object as JSON by default
        options.cast.object = (value)=>JSON.stringify(value);
    }
    // Normalize option cast.string
    if (options.cast.string === undefined || options.cast.string === null) {
        // Leave string untouched
        options.cast.string = function(value) {
            return value;
        };
    }
    // Normalize option `on_record`
    if (options.on_record !== undefined && typeof options.on_record !== "function") {
        return [
            Error(`Invalid Option: "on_record" must be a function.`)
        ];
    }
    // Normalize option `record_delimiter`
    if (options.record_delimiter === undefined || options.record_delimiter === null) {
        options.record_delimiter = "\n";
    } else if (Buffer.isBuffer(options.record_delimiter)) {
        options.record_delimiter = options.record_delimiter.toString();
    } else if (typeof options.record_delimiter !== "string") {
        return [
            Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`)
        ];
    }
    switch(options.record_delimiter){
        case "unix":
            options.record_delimiter = "\n";
            break;
        case "mac":
            options.record_delimiter = "\r";
            break;
        case "windows":
            options.record_delimiter = "\r\n";
            break;
        case "ascii":
            options.record_delimiter = "\u001e";
            break;
        case "unicode":
            options.record_delimiter = "\u2028";
            break;
    }
    return [
        undefined,
        options
    ];
};
;
}),
"[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/api/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "stringifier": ()=>stringifier
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$utils$2f$get$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/utils/get.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$utils$2f$is_object$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/utils/is_object.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$normalize_columns$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/api/normalize_columns.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$normalize_options$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/api/normalize_options.js [app-route] (ecmascript)");
;
;
;
;
const bom_utf8 = Buffer.from([
    239,
    187,
    191
]);
const stringifier = function(options, state, info) {
    return {
        options: options,
        state: state,
        info: info,
        __transform: function(chunk, push) {
            // Chunk validation
            if (!Array.isArray(chunk) && typeof chunk !== "object") {
                return Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`);
            }
            // Detect columns from the first record
            if (this.info.records === 0) {
                if (Array.isArray(chunk)) {
                    if (this.options.header === true && this.options.columns === undefined) {
                        return Error("Undiscoverable Columns: header option requires column option or object records");
                    }
                } else if (this.options.columns === undefined) {
                    const [err, columns] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$normalize_columns$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalize_columns"])(Object.keys(chunk));
                    if (err) return;
                    this.options.columns = columns;
                }
            }
            // Emit the header
            if (this.info.records === 0) {
                this.bom(push);
                const err = this.headers(push);
                if (err) return err;
            }
            // Emit and stringify the record if an object or an array
            try {
                // this.emit('record', chunk, this.info.records);
                if (this.options.on_record) {
                    this.options.on_record(chunk, this.info.records);
                }
            } catch (err) {
                return err;
            }
            // Convert the record into a string
            let err, chunk_string;
            if (this.options.eof) {
                [err, chunk_string] = this.stringify(chunk);
                if (err) return err;
                if (chunk_string === undefined) {
                    return;
                } else {
                    chunk_string = chunk_string + this.options.record_delimiter;
                }
            } else {
                [err, chunk_string] = this.stringify(chunk);
                if (err) return err;
                if (chunk_string === undefined) {
                    return;
                } else {
                    if (this.options.header || this.info.records) {
                        chunk_string = this.options.record_delimiter + chunk_string;
                    }
                }
            }
            // Emit the csv
            this.info.records++;
            push(chunk_string);
        },
        stringify: function(chunk, chunkIsHeader = false) {
            if (typeof chunk !== "object") {
                return [
                    undefined,
                    chunk
                ];
            }
            const { columns } = this.options;
            const record = [];
            // Record is an array
            if (Array.isArray(chunk)) {
                // We are getting an array but the user has specified output columns. In
                // this case, we respect the columns indexes
                if (columns) {
                    chunk.splice(columns.length);
                }
                // Cast record elements
                for(let i = 0; i < chunk.length; i++){
                    const field = chunk[i];
                    const [err, value] = this.__cast(field, {
                        index: i,
                        column: i,
                        records: this.info.records,
                        header: chunkIsHeader
                    });
                    if (err) return [
                        err
                    ];
                    record[i] = [
                        value,
                        field
                    ];
                }
            // Record is a literal object
            // `columns` is always defined: it is either provided or discovered.
            } else {
                for(let i = 0; i < columns.length; i++){
                    const field = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$utils$2f$get$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["get"])(chunk, columns[i].key);
                    const [err, value] = this.__cast(field, {
                        index: i,
                        column: columns[i].key,
                        records: this.info.records,
                        header: chunkIsHeader
                    });
                    if (err) return [
                        err
                    ];
                    record[i] = [
                        value,
                        field
                    ];
                }
            }
            let csvrecord = "";
            for(let i = 0; i < record.length; i++){
                let options, err;
                let [value, field] = record[i];
                if (typeof value === "string") {
                    options = this.options;
                } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$utils$2f$is_object$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["is_object"])(value)) {
                    options = value;
                    value = options.value;
                    delete options.value;
                    if (typeof value !== "string" && value !== undefined && value !== null) {
                        if (err) return [
                            Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`)
                        ];
                    }
                    options = {
                        ...this.options,
                        ...options
                    };
                    [err, options] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$normalize_options$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalize_options"])(options);
                    if (err !== undefined) {
                        return [
                            err
                        ];
                    }
                } else if (value === undefined || value === null) {
                    options = this.options;
                } else {
                    return [
                        Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`)
                    ];
                }
                const { delimiter, escape, quote, quoted, quoted_empty, quoted_string, quoted_match, record_delimiter, escape_formulas } = options;
                if ("" === value && "" === field) {
                    let quotedMatch = quoted_match && quoted_match.filter((quoted_match)=>{
                        if (typeof quoted_match === "string") {
                            return value.indexOf(quoted_match) !== -1;
                        } else {
                            return quoted_match.test(value);
                        }
                    });
                    quotedMatch = quotedMatch && quotedMatch.length > 0;
                    const shouldQuote = quotedMatch || true === quoted_empty || true === quoted_string && false !== quoted_empty;
                    if (shouldQuote === true) {
                        value = quote + value + quote;
                    }
                    csvrecord += value;
                } else if (value) {
                    if (typeof value !== "string") {
                        return [
                            Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`)
                        ];
                    }
                    const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0;
                    const containsQuote = quote !== "" && value.indexOf(quote) >= 0;
                    const containsEscape = value.indexOf(escape) >= 0 && escape !== quote;
                    const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;
                    const quotedString = quoted_string && typeof field === "string";
                    let quotedMatch = quoted_match && quoted_match.filter((quoted_match)=>{
                        if (typeof quoted_match === "string") {
                            return value.indexOf(quoted_match) !== -1;
                        } else {
                            return quoted_match.test(value);
                        }
                    });
                    quotedMatch = quotedMatch && quotedMatch.length > 0;
                    // See https://github.com/adaltas/node-csv/pull/387
                    // More about CSV injection or formula injection, when websites embed
                    // untrusted input inside CSV files:
                    // https://owasp.org/www-community/attacks/CSV_Injection
                    // http://georgemauer.net/2017/10/07/csv-injection.html
                    // Apple Numbers unicode normalization is empirical from testing
                    if (escape_formulas) {
                        switch(value[0]){
                            case "=":
                            case "+":
                            case "-":
                            case "@":
                            case "\t":
                            case "\r":
                            case "\uFF1D":
                            case "\uFF0B":
                            case "\uFF0D":
                            case "\uFF20":
                                value = `'${value}`;
                                break;
                        }
                    }
                    const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch;
                    if (shouldQuote === true && containsEscape === true) {
                        const regexp = escape === "\\" ? new RegExp(escape + escape, "g") : new RegExp(escape, "g");
                        value = value.replace(regexp, escape + escape);
                    }
                    if (containsQuote === true) {
                        const regexp = new RegExp(quote, "g");
                        value = value.replace(regexp, escape + quote);
                    }
                    if (shouldQuote === true) {
                        value = quote + value + quote;
                    }
                    csvrecord += value;
                } else if (quoted_empty === true || field === "" && quoted_string === true && quoted_empty !== false) {
                    csvrecord += quote + quote;
                }
                if (i !== record.length - 1) {
                    csvrecord += delimiter;
                }
            }
            return [
                undefined,
                csvrecord
            ];
        },
        bom: function(push) {
            if (this.options.bom !== true) {
                return;
            }
            push(bom_utf8);
        },
        headers: function(push) {
            if (this.options.header === false) {
                return;
            }
            if (this.options.columns === undefined) {
                return;
            }
            let err;
            let headers = this.options.columns.map((column)=>column.header);
            if (this.options.eof) {
                [err, headers] = this.stringify(headers, true);
                headers += this.options.record_delimiter;
            } else {
                [err, headers] = this.stringify(headers);
            }
            if (err) return err;
            push(headers);
        },
        __cast: function(value, context) {
            const type = typeof value;
            try {
                if (type === "string") {
                    // Fine for 99% of the cases
                    return [
                        undefined,
                        this.options.cast.string(value, context)
                    ];
                } else if (type === "bigint") {
                    return [
                        undefined,
                        this.options.cast.bigint(value, context)
                    ];
                } else if (type === "number") {
                    return [
                        undefined,
                        this.options.cast.number(value, context)
                    ];
                } else if (type === "boolean") {
                    return [
                        undefined,
                        this.options.cast.boolean(value, context)
                    ];
                } else if (value instanceof Date) {
                    return [
                        undefined,
                        this.options.cast.date(value, context)
                    ];
                } else if (type === "object" && value !== null) {
                    return [
                        undefined,
                        this.options.cast.object(value, context)
                    ];
                } else {
                    return [
                        undefined,
                        value,
                        value
                    ];
                }
            } catch (err) {
                return [
                    err
                ];
            }
        }
    };
};
;
}),
"[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/index.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

/*
CSV Stringify

Please look at the [project documentation](https://csv.js.org/stringify/) for
additional information.
*/ __turbopack_context__.s({
    "Stringifier": ()=>Stringifier,
    "stringify": ()=>stringify
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/api/CsvError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$utils$2f$is_object$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/utils/is_object.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/api/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$normalize_options$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/api/normalize_options.js [app-route] (ecmascript)");
;
;
;
;
;
class Stringifier extends __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["Transform"] {
    constructor(opts = {}){
        super({
            ...{
                writableObjectMode: true
            },
            ...opts
        });
        const [err, options] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$normalize_options$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalize_options"])(opts);
        if (err !== undefined) throw err;
        // Expose options
        this.options = options;
        // Internal state
        this.state = {
            stop: false
        };
        // Information
        this.info = {
            records: 0
        };
        this.api = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringifier"])(this.options, this.state, this.info);
        this.api.options.on_record = (...args)=>{
            this.emit("record", ...args);
        };
    }
    _transform(chunk, encoding, callback) {
        if (this.state.stop === true) {
            return;
        }
        const err = this.api.__transform(chunk, this.push.bind(this));
        if (err !== undefined) {
            this.state.stop = true;
        }
        callback(err);
    }
    _flush(callback) {
        if (this.state.stop === true) {
            // Note, Node.js 12 call flush even after an error, we must prevent
            // `callback` from being called in flush without any error.
            return;
        }
        if (this.info.records === 0) {
            this.api.bom(this.push.bind(this));
            const err = this.api.headers(this.push.bind(this));
            if (err) callback(err);
        }
        callback();
    }
}
const stringify = function() {
    let data, options, callback;
    for(const i in arguments){
        const argument = arguments[i];
        const type = typeof argument;
        if (data === undefined && Array.isArray(argument)) {
            data = argument;
        } else if (options === undefined && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$utils$2f$is_object$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["is_object"])(argument)) {
            options = argument;
        } else if (callback === undefined && type === "function") {
            callback = argument;
        } else {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CsvError"]("CSV_INVALID_ARGUMENT", [
                "Invalid argument:",
                `got ${JSON.stringify(argument)} at index ${i}`
            ]);
        }
    }
    const stringifier = new Stringifier(options);
    if (callback) {
        const chunks = [];
        stringifier.on("readable", function() {
            let chunk;
            while((chunk = this.read()) !== null){
                chunks.push(chunk);
            }
        });
        stringifier.on("error", function(err) {
            callback(err);
        });
        stringifier.on("end", function() {
            try {
                callback(undefined, chunks.join(""));
            } catch (err) {
                // This can happen if the `chunks` is extremely long; it may throw
                // "Cannot create a string longer than 0x1fffffe8 characters"
                // See [#386](https://github.com/adaltas/node-csv/pull/386)
                callback(err);
                return;
            }
        });
    }
    if (data !== undefined) {
        const writer = function() {
            for (const record of data){
                stringifier.write(record);
            }
            stringifier.end();
        };
        // Support Deno, Rollup doesnt provide a shim for setImmediate
        if (typeof setImmediate === "function") {
            setImmediate(writer);
        } else {
            setTimeout(writer, 0);
        }
    }
    return stringifier;
};
;
}),
"[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/index.js [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$CsvError$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/api/CsvError.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$utils$2f$is_object$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/utils/is_object.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/api/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$api$2f$normalize_options$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/api/normalize_options.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/index.js [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@irys/upload/dist/esm/upload.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "NodeUploader": ()=>NodeUploader,
    "checkPath": ()=>checkPath,
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$upload$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/upload.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mime$2d$types$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mime-types/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inquirer$2f$lib$2f$inquirer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/inquirer/lib/inquirer.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-parse/lib/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/node_modules/csv-stringify/lib/index.js [app-route] (ecmascript) <locals>");
;
;
;
;
;
;
;
;
const checkPath = async (path)=>{
    return __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["promises"].stat(path).then((_)=>true).catch((_)=>false);
};
class NodeUploader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$upload$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Uploader"] {
    constructor(api, utils, token, tokenConfig, irysTx){
        super(api, utils, token, tokenConfig, irysTx);
    }
    /**
     * Uploads a file to the bundler
     * @param path to the file to be uploaded
     * @returns the response from the bundler
     */ async uploadFile(path, opts) {
        if (!await __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["promises"].stat(path).then((_)=>true).catch((_)=>false)) {
            throw new Error(`Unable to access path: ${path}`);
        }
        // don't add Content-type tag if it already exists
        const hasContentTypeTag = opts?.tags && opts.tags.some((t)=>t.name.toLowerCase() === 'content-type');
        const mimeType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mime$2d$types$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].contentType(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mime$2d$types$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].lookup(path) || 'application/octet-stream');
        (opts ??= {}).tags = hasContentTypeTag || mimeType === false ? opts.tags ?? [] : [
            {
                name: 'Content-Type',
                value: this.contentTypeOverride ?? mimeType
            },
            ...opts?.tags ?? []
        ];
        const data = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["createReadStream"])(path);
        return await this.uploadData(data, opts);
    }
    async *walk(dir) {
        for await (const d of (await __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["promises"].opendir(dir))){
            const entry = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["join"])(dir, d.name);
            if (d.isDirectory()) yield* await this.walk(entry);
            else if (d.isFile()) yield entry;
        }
    }
    /**
     * Preprocessor for folder uploads, ensures the rest of the system has a correct operating environment.
     * @param path - path to the folder to be uploaded
     * @param indexFile - path to the index file (i.e index.html)
     * @param batchSize - number of items to upload concurrently
     * @param interactivePreflight - whether to interactively prompt the user for confirmation of upload (CLI ONLY)
     * @param keepDeleted - Whether to keep previously uploaded (but now deleted) files in the manifest
     * @param logFunction - for handling logging from the uploader for UX
     * @returns
     */ // eslint-disable-next-line @typescript-eslint/ban-types
    async uploadFolder(path, { batchSize = 10, keepDeleted = true, indexFile, interactivePreflight, logFunction, manifestTags, itemOptions } = {
        batchSize: 10,
        keepDeleted: true
    }) {
        path = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["resolve"])(path);
        const alreadyProcessed = new Map();
        const receiptTxs = new Map();
        if (!await checkPath(path)) {
            throw new Error(`Unable to access path: ${path}`);
        }
        // fallback to console.log if no logging function is given and interactive preflight is on.
        if (!logFunction && interactivePreflight) {
            logFunction = async (log)=>{
                console.log(log);
            };
        } else if (!logFunction) {
            // blackhole logs
            logFunction = async (_)=>{
                return;
            };
        }
        // manifest with folder name placed in parent directory of said folder - keeps contamination down.
        const manifestPath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["join"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["join"])(path, `${__TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["sep"]}..`), `${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["basename"])(path)}-manifest.csv`);
        const csvHeader = 'path,id,receipt\n';
        if (await checkPath(manifestPath)) {
            const rstrm = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["createReadStream"])(manifestPath);
            // check if empty
            if ((await __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["promises"].stat(manifestPath)).size === 0) {
                await __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["promises"].writeFile(manifestPath, csvHeader);
            }
            // validate header
            await new Promise((res)=>{
                (0, __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["createReadStream"])(manifestPath).once('data', async (d)=>{
                    const fl = d.toString().split('\n')[0];
                    if (`${fl}\n` !== csvHeader) {
                        await __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["promises"].writeFile(manifestPath, csvHeader);
                    }
                    res(d);
                });
            });
            const csvStream = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["Readable"].from(rstrm.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parse"])({
                delimiter: ',',
                columns: true
            })));
            for await (const record of csvStream){
                record;
                if (record.path && record.id) {
                    alreadyProcessed.set(record.path, record.id);
                    receiptTxs.set(record.path, JSON.parse(record.receipt));
                }
            }
        } else {
            await __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["promises"].writeFile(manifestPath, csvHeader);
        }
        const files = [];
        let total = 0;
        let i = 0;
        for await (const f of this.walk(path)){
            const relPath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["relative"])(path, f);
            if (!alreadyProcessed.has(relPath)) {
                files.push(f);
                total += (await __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["promises"].stat(f)).size;
            } else {
                alreadyProcessed.delete(relPath);
            }
            if (++i % batchSize == 0) {
                logFunction(`Checked ${i} files...`);
            }
        }
        if (!keepDeleted) {
            alreadyProcessed.clear();
        }
        // pass as param otherwise it thinks logFunction can be undef
        const uploadManifest = async (logFunction)=>{
            // generate JSON
            await logFunction('Generating JSON manifest...');
            const jsonManifestPath = await this.generateManifestFromCsv(path, alreadyProcessed, indexFile);
            // upload the manifest
            await logFunction('Uploading JSON manifest...');
            const tags = [
                {
                    name: 'Type',
                    value: 'manifest'
                },
                {
                    name: 'Content-Type',
                    value: 'application/x.irys-manifest+json'
                },
                ...manifestTags ?? []
            ];
            const mres = await this.uploadData((0, __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["createReadStream"])(jsonManifestPath), {
                tags
            }).catch((e)=>{
                throw new Error(`Failed to upload manifest: ${e.message}`);
            });
            await logFunction('Done!');
            if (mres?.id) {
                await __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["promises"].writeFile((0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["join"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["join"])(path, `${__TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["sep"]}..`), `${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["basename"])(path)}-id.txt`), JSON.stringify(mres));
            } else {
                throw new Error(`Unable to get upload ID! ${JSON.stringify(mres)}`);
            }
            return mres;
        };
        // TODO: add logic to detect changes (MD5/other hash)
        if (files.length == 0 && alreadyProcessed.size === 0) {
            logFunction('No items to process');
            // return the txID of the upload
            const idpath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["join"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["join"])(path, `${__TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["sep"]}..`), `${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["basename"])(path)}-id.txt`);
            if (await checkPath(idpath)) {
                return JSON.parse(await __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["promises"].readFile(idpath, 'utf-8'));
            }
            // assume manifest wasn't uploaded
            return await uploadManifest(logFunction);
        }
        // const zprice = (await this.utils.getPrice(this.currency, 0)).multipliedBy(files.length);
        // const price = (await this.utils.getPrice(this.currency, total)).plus(zprice).toFixed(0);
        const price = await this.utils.estimateFolderPrice({
            fileCount: files.length,
            totalBytes: total
        });
        if (interactivePreflight) {
            if (!await confirmation(`Authorize upload?\nTotal amount of data: ${total} bytes over ${files.length} files - cost: ${price} ${this.tokenConfig.base[0]} (${this.utils.fromAtomic(price).toFixed()} ${this.token})\n Y / N`)) {
                throw new Error('Confirmation failed');
            }
        }
        const stringifier = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$stringify$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["stringify"])({
            header: false,
            columns: {
                path: 'path',
                id: 'id',
                receipt: 'receipt'
            }
        });
        const wstrm = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["createWriteStream"])(manifestPath, {
            flags: 'a+'
        });
        stringifier.pipe(wstrm);
        const processor = async (data)=>{
            if (data?.res?.id) {
                const receipt = data.res.signature ? {
                    id: data.res.id,
                    block: data.res.block,
                    deadlineHeight: data.res.deadlineHeight,
                    public: data.res.public,
                    signature: data.res.signature,
                    timestamp: data.res.timestamp,
                    validatorSignatures: data.res.validatorSignatures,
                    version: data.res.version
                } : {};
                receiptTxs.set((0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["relative"])(path, data.item), receipt);
                stringifier.write([
                    (0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["relative"])(path, data.item),
                    data.res.id,
                    JSON.stringify(receipt)
                ]);
            }
        };
        const processingResults = await this.concurrentUploader(files, {
            concurrency: batchSize,
            resultProcessor: processor,
            logFunction,
            itemOptions
        });
        if (processingResults.errors.length > 0) {
            await logFunction(`${processingResults.errors.length} Errors detected, skipping manifest upload...`);
            const ewstrm = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["createWriteStream"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["join"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["join"])(path, `${__TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["sep"]}..`), `${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["basename"])(path)}-errors.txt`), {
                flags: 'a+'
            });
            ewstrm.write(`Errors from upload at ${new Date().toString()}:\n`);
            processingResults.errors.forEach((e)=>ewstrm.write(`${e?.stack ?? JSON.stringify(e)}\n`));
            await new Promise((res)=>ewstrm.close(res));
            throw new Error(`${processingResults.errors.length} Errors detected - check ${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["basename"])(path)}-errors.txt for more information.`);
        }
        await logFunction(`Finished processing ${files.length} Items`);
        await new Promise((r)=>wstrm.close(r));
        return await uploadManifest(logFunction);
    }
    /**
     * processes an item to convert it into a DataItem, and then uploads it.
     * @param item can be a string value, a path to a file, a Buffer of data or a DataItem
     * @returns A dataItem
     */ async processItem(item, opts) {
        if (this.bundles.DataItem.isDataItem(item)) {
            return this.uploadTransaction(item, {
                ...opts?.upload
            });
        }
        let tags = [];
        if (typeof item === 'string') {
            if (await checkPath(item)) {
                const mimeType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mime$2d$types$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].contentType(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mime$2d$types$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].lookup(item) || 'application/octet-stream');
                if (mimeType) tags = [
                    {
                        name: 'Content-Type',
                        value: this.contentTypeOverride ?? mimeType
                    }
                ];
                // returnVal = item;
                item = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["createReadStream"])(item);
            } else {
                item = Buffer.from(item);
                if (this.contentTypeOverride) {
                    tags = [
                        {
                            name: 'Content-Type',
                            value: this.contentTypeOverride
                        }
                    ];
                }
            }
        }
        return this.uploadData(item, {
            ...opts,
            tags: [
                ...tags,
                ...opts?.tags ?? []
            ]
        });
    }
    /**
     * Stream-based CSV parser and JSON assembler
     * @param path base path of the upload
     * @param indexFile optional path to an index file
     * @returns the path to the generated manifest
     */ async generateManifestFromCsv(path, nowRemoved, indexFile) {
        const csvstrm = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$node_modules$2f$csv$2d$parse$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parse"])({
            delimiter: ',',
            columns: true
        });
        const csvPath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["join"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["join"])(path, `${__TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["sep"]}..`), `${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["basename"])(path)}-manifest.csv`);
        const manifestPath = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["join"])((0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["join"])(path, `${__TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["sep"]}..`), `${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["basename"])(path)}-manifest.json`);
        const wstrm = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["createWriteStream"])(manifestPath, {
            flags: 'w+'
        });
        (0, __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["createReadStream"])(csvPath).pipe(csvstrm); // pipe csv
        /* eslint-disable quotes */ // "header"
        wstrm.write(`{\n"manifest": "irys/paths",\n"version": "0.1.0",\n"paths": {\n`);
        const csvs = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["Readable"].from(csvstrm);
        let firstValue = true;
        for await (const d of csvs){
            if (nowRemoved?.has(d.path)) {
                nowRemoved.delete(d.path);
                continue;
            }
            const prefix = firstValue ? '' : ',\n';
            wstrm.write(`${prefix}"${d.path.replaceAll('\\', '/')}":{"id":"${d.id}"}`);
            firstValue = false;
        }
        // "trailer"
        wstrm.write(`\n}`);
        // add index
        if (indexFile) {
            wstrm.write(`,\n"index":{"path":"${indexFile.replaceAll('\\', '/')}"}`);
        }
        wstrm.write(`\n}`);
        await new Promise((r)=>wstrm.close(r));
        return manifestPath;
    }
}
async function confirmation(message) {
    const answers = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$inquirer$2f$lib$2f$inquirer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].prompt([
        {
            type: 'input',
            name: 'confirmation',
            message
        }
    ]);
    return answers.confirmation.toLowerCase() == 'y';
}
const __TURBOPACK__default__export__ = NodeUploader;
 //# sourceMappingURL=upload.js.map
}),
"[project]/node_modules/@irys/upload/dist/esm/utils.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/bundles/build/node/esm/index.js [app-route] (ecmascript) <module evaluation>");
;
;
 //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@irys/upload/dist/esm/utils.js [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/bundles/build/node/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/dist/esm/utils.js [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@irys/upload/dist/esm/utils.js [app-route] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Arweave": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$node$2f$arweave$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__Arweave$3e$__["Arweave"],
    "DataItem": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$DataItem$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DataItem"],
    "bundleAndSignData": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$ar$2d$data$2d$bundle$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["bundleAndSignData"],
    "createData": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$ar$2d$data$2d$create$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createData"],
    "deepHash": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$deepHash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["deepHash"],
    "getCryptoDriver": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$nodeUtils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getCryptoDriver"],
    "stringToBuffer": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringToBuffer"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$ar$2d$data$2d$create$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/bundles/build/node/esm/src/ar-data-create.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$DataItem$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/bundles/build/node/esm/src/DataItem.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$deepHash$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/bundles/build/node/esm/src/deepHash.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$common$2f$lib$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/common/lib/utils.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$nodeUtils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/bundles/build/node/esm/src/nodeUtils.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$ar$2d$data$2d$bundle$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/bundles/build/node/esm/src/ar-data-bundle.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$arweave$2f$build$2f$esm$2f$node$2f$arweave$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__Arweave$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/arweave/build/esm/node/arweave.js [app-route] (ecmascript) <export default as Arweave>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/dist/esm/utils.js [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@irys/upload/dist/esm/utils.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Arweave": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$exports$3e$__["Arweave"],
    "DataItem": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$exports$3e$__["DataItem"],
    "bundleAndSignData": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$exports$3e$__["bundleAndSignData"],
    "createData": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$exports$3e$__["createData"],
    "deepHash": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$exports$3e$__["deepHash"],
    "getCryptoDriver": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$exports$3e$__["getCryptoDriver"],
    "stringToBuffer": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$exports$3e$__["stringToBuffer"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/dist/esm/utils.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/dist/esm/utils.js [app-route] (ecmascript) <exports>");
}),
"[project]/node_modules/@irys/upload/dist/esm/base.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "BaseNodeIrys": ()=>BaseNodeIrys,
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$hack$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/hack.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$irys$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/irys.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/api.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$fund$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/fund.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$transactions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/transactions.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/utils.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$approval$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/approval.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$upload$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/dist/esm/upload.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/dist/esm/utils.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/dist/esm/utils.js [app-route] (ecmascript)");
;
;
;
;
class BaseNodeIrys extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$irys$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Irys"] {
    getTokenConfig;
    /**
     * Constructs a new Irys instance, as well as supporting subclasses
     * @param url - URL to the bundler
     * @param key - private key (in whatever form required)
     */ constructor({ url, config, getTokenConfig }){
        super({
            url,
            bundles: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__
        });
        this.debug = config?.debug ?? false;
        this.api = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Api"]({
            url: this.url,
            timeout: config?.timeout ?? 100000,
            headers: config?.headers
        });
        this.getTokenConfig = getTokenConfig;
    }
    async build({ wallet, config }) {
        this.tokenConfig = await this.getTokenConfig(this);
        if (this.url.host.includes('devnet.irys.xyz') && !config?.providerUrl) throw new Error(`Using ${this.url.host} requires a dev/testnet RPC to be configured! see https://docs.irys.xyz/build/d/networks#connecting-to-devnet`);
        this.token = this.tokenConfig.name;
        this.address = this.tokenConfig.address;
        this.utils = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Utils"](this.api, this.token, this.tokenConfig);
        this.funder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$fund$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Fund"](this.utils);
        this.uploader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$upload$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](this.api, this.utils, this.token, this.tokenConfig, this.IrysTransaction);
        this.transactions = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$transactions$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Transaction"](this);
        this.approval = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$approval$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Approval"](this);
        this._readyPromise = this.tokenConfig.ready ? this.tokenConfig.ready() : new Promise((r)=>r());
    }
    /**
     * Upload a file at the specified path to the bundler
     * @param path path to the file to upload
     * @returns bundler response
     */ async uploadFile(path, opts) {
        return this.uploader.uploadFile(path, opts);
    }
    /**
     * @param path - path to the folder to be uploaded
     * @param indexFile - path to the index file (i.e index.html)
     * @param batchSize - number of items to upload concurrently
     * @param interactivePreflight - whether to interactively prompt the user for confirmation of upload (CLI ONLY)
     * @param keepDeleted - Whether to keep previously uploaded (but now deleted) files in the manifest
     * @param logFunction - for handling logging from the uploader for UX
     * @param manifestTags - For allowing the caller to pass tags that will be added to the manifest transaction.
     * @returns
     */ async uploadFolder(path, { batchSize = 10, keepDeleted = true, indexFile, interactivePreflight, logFunction, manifestTags, itemOptions } = {}) {
        return this.uploader.uploadFolder(path, {
            indexFile,
            batchSize,
            interactivePreflight,
            keepDeleted,
            logFunction,
            manifestTags,
            itemOptions
        });
    }
}
const __TURBOPACK__default__export__ = BaseNodeIrys;
 //# sourceMappingURL=base.js.map
}),
"[project]/node_modules/@irys/upload/dist/esm/builder.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Builder": ()=>Builder,
    "UploadBuilder": ()=>UploadBuilder
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$base$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/dist/esm/base.js [app-route] (ecmascript)");
;
class UploadBuilder {
    preAdapters;
    postAdapters;
    token;
    wallet;
    config;
    constructed;
    constructor(tokenClass){
        this.preAdapters = [];
        this.postAdapters = [];
        this.token = tokenClass;
        this.config = {
            url: 'mainnet',
            key: undefined,
            irysConfig: {}
        };
    }
    withWallet(wallet) {
        if (!wallet) throw new Error('Provided wallet is undefined');
        this.wallet = wallet;
        return this;
    }
    mainnet() {
        this.config.url = 'mainnet';
        return this;
    }
    devnet() {
        this.config.url = 'devnet';
        return this;
    }
    withRpc(rpcUrl) {
        this.config.irysConfig.providerUrl = rpcUrl;
        return this;
    }
    bundlerUrl(url) {
        this.config.url = new URL(url).toString();
        return this;
    }
    network(network) {
        this.config.url = network;
        return this;
    }
    withAdapter(adapter) {
        // this.adapters.push(adapter)
        if (adapter.phase != 'post') this.preAdapters.push(adapter);
        if (adapter.phase != 'pre') this.postAdapters.push(adapter);
        // @ts-expect-error type intersection issues
        if (adapter.load) adapter.load(this);
        return this;
    }
    async build() {
        const irys = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$base$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BaseNodeIrys"]({
            url: this.config.url,
            config: this.config.irysConfig,
            getTokenConfig: async (irys)=>{
                for (const preAdapter of this.preAdapters){
                    await preAdapter.adaptTokenPre(this, this.token);
                }
                this.constructed = new this.token({
                    irys,
                    wallet: this.wallet,
                    providerUrl: this.config.irysConfig.providerUrl,
                    opts: this.config.irysConfig.tokenOpts
                });
                for (const postAdapter of this.postAdapters){
                    await postAdapter.adaptTokenPost(this, this.constructed);
                }
                return this.constructed;
            }
        });
        await irys.build({
            wallet: this.wallet,
            config: this.config.irysConfig
        });
        await irys.ready();
        return irys;
    }
    // todo: add generics
    withTokenOptions(opts) {
        this.config.irysConfig.tokenOpts = opts;
        return this;
    }
    withIrysConfig(config) {
        this.config.irysConfig = {
            ...this.config.irysConfig,
            ...config
        };
        return this;
    }
    /**
     * Set the HTTP request timeout - useful if you have a slower connection
     * @param timeout - timeout in milliseconds
     * @returns this (builder)
     */ timeout(timeout) {
        this.config.irysConfig.timeout = timeout;
        return this;
    }
    // Promise contract functions, so users can `await` a builder instance to resolve the builder, instead of having to call build().
    // very cool, thanks Knex.
    async then(onFulfilled, onRejected) {
        const res = this.build();
        return res.then(onFulfilled, onRejected);
    }
    async catch(onReject) {
        return this.then().catch(onReject);
    }
    async finally(onFinally) {
        return this.then().finally(onFinally);
    }
}
const Builder = (tokenClass)=>{
    return new UploadBuilder(tokenClass);
}; //# sourceMappingURL=builder.js.map
}),
"[project]/node_modules/@irys/upload/dist/esm/index.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

// export { default } from "./irys";
// export { default as NodeIrys } from "./irys";
__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$builder$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/dist/esm/builder.js [app-route] (ecmascript)");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$builder$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Builder"];
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@irys/upload/dist/esm/index.js [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$builder$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/dist/esm/builder.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/dist/esm/index.js [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@irys/upload/dist/esm/builder.js [app-route] (ecmascript) <export Builder as Uploader>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Uploader": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$builder$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Builder"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$builder$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/dist/esm/builder.js [app-route] (ecmascript)");
}),
"[project]/node_modules/@irys/upload/dist/esm/tokens/base.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "BaseNodeToken": ()=>BaseNodeToken,
    "getRedstonePrice": ()=>getRedstonePrice
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/axios/lib/axios.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-core/dist/esm/utils.js [app-route] (ecmascript)");
;
;
class BaseNodeToken {
    base;
    wallet;
    _address;
    providerUrl;
    providerInstance;
    ticker;
    name;
    minConfirm = 5;
    isSlow = false;
    needsFee = true;
    opts;
    utils;
    irys;
    constructor(config){
        Object.assign(this, config);
        this.initializeAddress();
    // this._address = this.wallet ? this.ownerToAddress(this.getPublicKey()) : undefined;
    }
    // common methods
    get address() {
        return this._address;
    }
    async initializeAddress() {
        if (this.wallet) {
            this._address = await this.ownerToAddress(this.getPublicKey());
        }
    }
    async price() {
        return getRedstonePrice(this.ticker);
    }
}
async function getRedstonePrice(token) {
    const res = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].get(`https://api.redstone.finance/prices?symbol=${token}&provider=redstone&limit=1`);
    await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$core$2f$dist$2f$esm$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Utils"].checkAndThrow(res, 'Getting price data');
    return res.data[0].value;
} //# sourceMappingURL=base.js.map
}),
"[project]/node_modules/@irys/upload-ethereum/dist/esm/ethereum.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>BaseEthereumToken
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$providers$2f$lib$2e$esm$2f$json$2d$rpc$2d$provider$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$wallet$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/wallet/lib.esm/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bignumber.js/bignumber.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/bundles/build/node/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$signing$2f$chains$2f$ethereumSigner$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__EthereumSigner$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/bundles/build/node/esm/src/signing/chains/ethereumSigner.js [app-route] (ecmascript) <export default as EthereumSigner>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$signing$2f$keccak256$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/bundles/build/node/esm/src/signing/keccak256.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$tokens$2f$base$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/dist/esm/tokens/base.js [app-route] (ecmascript)");
;
;
;
;
;
;
const ethereumSigner = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$signing$2f$chains$2f$ethereumSigner$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__EthereumSigner$3e$__["EthereumSigner"];
class BaseEthereumToken extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$tokens$2f$base$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BaseNodeToken"] {
    constructor(config){
        super(config);
        this.base = [
            'wei',
            1e18
        ];
    }
    async getProvider() {
        if (!this.providerInstance) {
            this.providerInstance = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$providers$2f$lib$2e$esm$2f$json$2d$rpc$2d$provider$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JsonRpcProvider"]({
                url: this.providerUrl,
                skipFetchSetup: true,
                ...this?.opts?.providerOptions
            });
            await this.providerInstance.ready;
        }
        return this.providerInstance;
    }
    async getTx(txId) {
        const provider = await this.getProvider();
        const response = await provider.getTransaction(txId);
        if (!response) throw new Error(`Unable to fetch Tx ${txId}`);
        if (!response.to) throw new Error(`Unable to determine transaction ${txId} recipient`);
        return {
            from: response.from,
            to: response.to,
            blockHeight: response.blockNumber ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](response.blockNumber) : undefined,
            amount: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](response.value.toHexString(), 16),
            pending: response.blockNumber ? false : true,
            confirmed: response.confirmations >= this.minConfirm
        };
    }
    async ownerToAddress(owner) {
        return '0x' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$signing$2f$keccak256$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["keccak256"])(owner.slice(1)).slice(-20).toString('hex');
    }
    async sign(data) {
        const signer = this.getSigner();
        return signer.sign(data);
    }
    getSigner() {
        return new ethereumSigner(this.wallet);
    }
    verify(pub, data, signature) {
        return ethereumSigner.verify(pub, data, signature);
    }
    async getCurrentHeight() {
        const response = await (await this.getProvider()).send('eth_blockNumber', []);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](response, 16);
    }
    async getFee(amount, to) {
        const provider = await this.getProvider();
        const _amount = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](amount);
        const tx = {
            from: this.address,
            to,
            value: '0x' + _amount.toString(16)
        };
        const estimatedGas = await provider.estimateGas(tx);
        const gasPrice = await provider.getGasPrice();
        // const b = await provider.send("eth_maxPriorityFeePerGas", [])
        // console.log(b)
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](estimatedGas.mul(gasPrice).toString());
    }
    async sendTx(data) {
        return await (await this.getProvider()).sendTransaction(data).catch((e)=>{
            console.error(`Error occurred while sending a tx - ${e}`);
            throw e;
        });
    }
    async createTx(amount, to, fee) {
        const provider = await this.getProvider();
        const wallet = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$wallet$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Wallet"](this.wallet, provider);
        const _amount = '0x' + new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](amount).toString(16);
        let gasPrice = await provider.getGasPrice();
        const gasEstimate = fee ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BigNumber"].from(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](fee).dividedToIntegerBy(gasPrice.toString()).toFixed()) : undefined;
        // const estimatedGas = await provider.estimateGas({ from: this.address, to, value: _amount });
        // console.log({ gasPrice, estimatedGas })
        // if (fee) {
        //     gasPrice = ethers.BigNumber.from(Math.ceil(+fee / estimatedGas.toNumber()))
        // }
        if (this.name === 'matic') {
            gasPrice = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BigNumber"].from(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](gasPrice.toString()).multipliedBy(10).decimalPlaces(0).toString());
        }
        const tx = await wallet.populateTransaction({
            to,
            value: _amount,
            from: this.address,
            gasPrice,
            // gasLimit: estimatedGas,
            gasLimit: gasEstimate
        });
        // tx.gasLimit = ethers.BigNumber.from(+(tx.gasLimit.toString()) * 4)
        const signedTx = await wallet.signTransaction(tx);
        const txId = '0x' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$signing$2f$keccak256$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["keccak256"])(Buffer.from(signedTx.slice(2), 'hex')).toString('hex');
        // const c = await provider.call(tx);
        // console.log(c)
        return {
            txId,
            tx: signedTx
        };
    }
    getPublicKey() {
        return this.getSigner().publicKey;
    }
} //# sourceMappingURL=ethereum.js.map
}),
"[project]/node_modules/@irys/upload-ethereum/dist/esm/erc20.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "BaseERC20Token": ()=>BaseERC20Token,
    "default": ()=>__TURBOPACK__default__export__,
    "erc20abi": ()=>erc20abi
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bignumber.js/bignumber.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$contracts$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/contracts/lib.esm/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$wallet$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/wallet/lib.esm/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/bundles/build/node/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$signing$2f$keccak256$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/bundles/build/node/esm/src/signing/keccak256.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$tokens$2f$base$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload/dist/esm/tokens/base.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$ethereum$2f$dist$2f$esm$2f$ethereum$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-ethereum/dist/esm/ethereum.js [app-route] (ecmascript)");
;
;
;
;
;
;
class BaseERC20Token extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$ethereum$2f$dist$2f$esm$2f$ethereum$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"] {
    contractInstance;
    contractAddress;
    constructor(config){
        super(config);
        this.contractAddress = config.contractAddress;
    }
    async getContract() {
        if (!this.contractInstance) {
            this.contractInstance = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$contracts$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Contract"](this.contractAddress, erc20abi, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$wallet$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Wallet"](this.wallet, await this.getProvider()));
            this.base = [
                'wei',
                Math.pow(10, await this.contractInstance.decimals())
            ];
        }
        return this.contractInstance;
    }
    async getTx(txId) {
        const response = await (await super.getProvider()).getTransaction(txId);
        if (!response) throw new Error("Tx doesn't exist");
        if (response.data.length !== 138 || response.data.slice(2, 10) !== 'a9059cbb' // standard ERC20-ABI method ID for transfers
        ) {
            throw new Error("Tx isn't a ERC20 transfer");
        }
        const to = `0x${response.data.slice(34, 74)}`;
        const amount = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](response.data.slice(74), 16);
        return {
            from: response.from,
            to,
            blockHeight: response.blockNumber ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](response.blockNumber) : undefined,
            amount,
            pending: response.blockNumber ? false : true,
            confirmed: response.confirmations >= this.minConfirm
        };
    }
    async getFee(amount, to) {
        const _amount = '0x' + new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](amount).toString(16);
        const contract = await this.getContract();
        const provider = await this.getProvider();
        const gasPrice = await provider.getGasPrice();
        const gasLimit = await contract.estimateGas.transfer(to, _amount);
        const units = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](gasPrice.mul(gasLimit).toString()); // price in WEI
        return units;
    // below is cost in contract token units for the gas price
    // const [fiatGasPrice] = await this.getGas(); // get price of gas units
    // const value = fiatGasPrice.multipliedBy(units); // value of the fee
    // // convert value
    // const ctPrice = new BigNumber(await this.price()); // price for this token
    // const ctAmount = new BigNumber(value).dividedToIntegerBy(ctPrice);
    // // const b = ctAmount.multipliedBy(ctPrice)
    // // const c = value.dividedBy(this.base[1])
    // // console.log(b);
    // // console.log(c)
    // return ctAmount;
    }
    async createTx(amount, to, _fee) {
        const provider = await this.getProvider();
        const wallet = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$wallet$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Wallet"](this.wallet, provider);
        const contract = await this.getContract();
        const _amount = '0x' + new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](amount).toString(16);
        const tx = await contract.populateTransaction.transfer(to, _amount);
        // Needed *specifically* for ERC20
        tx.gasPrice = await provider.getGasPrice();
        tx.gasLimit = await contract.estimateGas.transfer(to, _amount);
        tx.chainId = (await provider.getNetwork()).chainId;
        if (!this.address) throw new Error('Address is undefined - you might be missing a wallet, or have not run Irys.ready()');
        tx.nonce = await provider.getTransactionCount(this.address);
        const signedTx = await wallet.signTransaction(tx);
        const txId = '0x' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$bundles$2f$build$2f$node$2f$esm$2f$src$2f$signing$2f$keccak256$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["keccak256"])(Buffer.from(signedTx.slice(2), 'hex')).toString('hex');
        return {
            txId,
            tx: signedTx
        };
    }
    // TODO: create a nicer solution than just overrides (larger issue: some currencies aren't on redstone)
    async getGas() {
        return [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2f$dist$2f$esm$2f$tokens$2f$base$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRedstonePrice"])('ETH')),
            1e18
        ];
    }
}
const __TURBOPACK__default__export__ = BaseERC20Token;
const erc20abi = [
    {
        constant: true,
        inputs: [],
        name: 'name',
        outputs: [
            {
                name: '',
                type: 'string'
            }
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function'
    },
    {
        constant: false,
        inputs: [
            {
                name: '_spender',
                type: 'address'
            },
            {
                name: '_value',
                type: 'uint256'
            }
        ],
        name: 'approve',
        outputs: [
            {
                name: '',
                type: 'bool'
            }
        ],
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function'
    },
    {
        constant: true,
        inputs: [],
        name: 'totalSupply',
        outputs: [
            {
                name: '',
                type: 'uint256'
            }
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function'
    },
    {
        constant: false,
        inputs: [
            {
                name: '_from',
                type: 'address'
            },
            {
                name: '_to',
                type: 'address'
            },
            {
                name: '_value',
                type: 'uint256'
            }
        ],
        name: 'transferFrom',
        outputs: [
            {
                name: '',
                type: 'bool'
            }
        ],
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function'
    },
    {
        constant: true,
        inputs: [],
        name: 'decimals',
        outputs: [
            {
                name: '',
                type: 'uint8'
            }
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function'
    },
    {
        constant: true,
        inputs: [
            {
                name: '_owner',
                type: 'address'
            }
        ],
        name: 'balanceOf',
        outputs: [
            {
                name: 'balance',
                type: 'uint256'
            }
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function'
    },
    {
        constant: true,
        inputs: [],
        name: 'symbol',
        outputs: [
            {
                name: '',
                type: 'string'
            }
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function'
    },
    {
        constant: false,
        inputs: [
            {
                name: '_to',
                type: 'address'
            },
            {
                name: '_value',
                type: 'uint256'
            }
        ],
        name: 'transfer',
        outputs: [
            {
                name: '',
                type: 'bool'
            }
        ],
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function'
    },
    {
        constant: true,
        inputs: [
            {
                name: '_owner',
                type: 'address'
            },
            {
                name: '_spender',
                type: 'address'
            }
        ],
        name: 'allowance',
        outputs: [
            {
                name: '',
                type: 'uint256'
            }
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function'
    },
    {
        payable: true,
        stateMutability: 'payable',
        type: 'fallback'
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: 'owner',
                type: 'address'
            },
            {
                indexed: true,
                name: 'spender',
                type: 'address'
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256'
            }
        ],
        name: 'Approval',
        type: 'event'
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: 'from',
                type: 'address'
            },
            {
                indexed: true,
                name: 'to',
                type: 'address'
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256'
            }
        ],
        name: 'Transfer',
        type: 'event'
    }
]; //# sourceMappingURL=erc20.js.map
}),
"[project]/node_modules/@irys/upload-ethereum/dist/esm/clients.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Arbitrum": ()=>Arbitrum,
    "Avalanche": ()=>Avalanche,
    "BNB": ()=>BNB,
    "BaseEth": ()=>BaseEth,
    "Bera": ()=>Bera,
    "Chainlink": ()=>Chainlink,
    "Ethereum": ()=>Ethereum,
    "EthereumToken": ()=>EthereumToken,
    "Iotex": ()=>Iotex,
    "LineaEth": ()=>LineaEth,
    "Matic": ()=>Matic,
    "ScrollEth": ()=>ScrollEth,
    "USDCEth": ()=>USDCEth,
    "USDCPolygon": ()=>USDCPolygon,
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$ethereum$2f$dist$2f$esm$2f$erc20$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-ethereum/dist/esm/erc20.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$ethereum$2f$dist$2f$esm$2f$ethereum$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-ethereum/dist/esm/ethereum.js [app-route] (ecmascript)");
;
;
class EthereumToken extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$ethereum$2f$dist$2f$esm$2f$ethereum$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"] {
    constructor(config){
        super({
            name: 'ethereum',
            ticker: 'ETH',
            ...config,
            providerUrl: config.providerUrl ?? 'https://cloudflare-eth.com/'
        });
    }
}
// todo: overhaul this
function getBoundEth({ name, ticker, providerUrl }) {
    return class EthereumToken extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$ethereum$2f$dist$2f$esm$2f$ethereum$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"] {
        constructor(config){
            super({
                name,
                ticker,
                ...config,
                providerUrl: config.providerUrl ?? providerUrl
            });
        }
    };
}
function getBoundERC20({ name, ticker, providerUrl, contractAddress }) {
    return class ERC20Token extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$ethereum$2f$dist$2f$esm$2f$erc20$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"] {
        constructor(config){
            super({
                name,
                ticker,
                ...config,
                providerUrl: config.providerUrl ?? providerUrl,
                contractAddress: config.opts?.contractAddress ?? contractAddress
            });
        }
    };
}
const Matic = getBoundEth({
    name: 'matic',
    ticker: 'MATIC',
    providerUrl: 'https://polygon-rpc.com/'
});
const BNB = getBoundEth({
    name: 'bnb',
    ticker: 'BNB',
    providerUrl: 'https://bsc-dataseed.binance.org/'
});
const Avalanche = getBoundEth({
    name: 'avalanche',
    ticker: 'AVAX',
    providerUrl: 'https://api.avax-test.network/ext/bc/C/rpc/'
});
const BaseEth = getBoundEth({
    name: 'base-eth',
    ticker: 'ETH',
    providerUrl: 'https://mainnet.base.org/'
});
const USDCEth = getBoundERC20({
    name: 'usdc-eth',
    ticker: 'USDC',
    providerUrl: 'https://cloudflare-eth.com/',
    contractAddress: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
});
const Arbitrum = getBoundEth({
    name: 'arbitrum',
    ticker: 'ETH',
    providerUrl: 'https://arb1.arbitrum.io/rpc/'
});
const Chainlink = getBoundERC20({
    name: 'chainlink',
    ticker: 'LINK',
    providerUrl: 'https://main-light.eth.linkpool.io/',
    contractAddress: '0x514910771AF9Ca656af840dff83E8264EcF986CA'
});
const USDCPolygon = getBoundERC20({
    name: 'usdc-polygon',
    ticker: 'USDC',
    providerUrl: 'https://polygon-rpc.com',
    contractAddress: '0x3c499c542cef5e3811e1192ce70d8cc03d5c3359'
});
const Bera = getBoundEth({
    name: 'bera',
    ticker: 'BERA',
    providerUrl: 'https://rpc.berachain.com/'
});
const ScrollEth = getBoundEth({
    name: 'scroll-eth',
    ticker: 'ETH',
    providerUrl: 'https://rpc.scroll.io'
});
const LineaEth = getBoundEth({
    name: 'linea-eth',
    ticker: 'ETH',
    providerUrl: 'https://rpc.linea.build'
});
const Iotex = getBoundEth({
    name: 'iotex',
    ticker: 'IOTX',
    providerUrl: 'https://babel-api.mainnet.iotex.io/'
});
const Ethereum = EthereumToken;
const __TURBOPACK__default__export__ = Ethereum;
 // export default EthereumBundlerIrys
 //# sourceMappingURL=clients.js.map
}),
"[project]/node_modules/@irys/upload-ethereum/dist/esm/index.js [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$ethereum$2f$dist$2f$esm$2f$clients$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-ethereum/dist/esm/clients.js [app-route] (ecmascript)");
;
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$ethereum$2f$dist$2f$esm$2f$clients$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Ethereum"];
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@irys/upload-ethereum/dist/esm/index.js [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$ethereum$2f$dist$2f$esm$2f$clients$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-ethereum/dist/esm/clients.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$irys$2f$upload$2d$ethereum$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@irys/upload-ethereum/dist/esm/index.js [app-route] (ecmascript) <locals>");
}),

};

//# sourceMappingURL=node_modules_%40irys_86409f14._.js.map
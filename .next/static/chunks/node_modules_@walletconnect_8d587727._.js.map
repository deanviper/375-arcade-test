{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/version.js","sourceRoot":"","sources":["../../errors/version.ts"],"sourcesContent":[],"names":[],"mappings":";;;AAAO,MAAM,OAAO,GAAG,QAAQ,CAAA","debugId":null}},
    {"offset": {"line": 13, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/base.js","sourceRoot":"","sources":["../../errors/base.ts"],"sourcesContent":[],"names":[],"mappings":";;;;AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,cAAc,CAAA;;AAOtC,IAAI,WAAW,GAAgB;IAC7B,UAAU,EAAE;YAAC,EACX,WAAW,EACX,QAAQ,GAAG,EAAE,EACb,QAAQ,EACY,EAAE,EAAE;eACxB,QAAQ,GACJ,2DAAG,WAAW,GAAI,iBAAiB,SAAG,QAAQ,EAE9C,CAAE,MADA,QAAQ,CAAC,CAAC,CAAC,IAAY,CAAE,CAAC,CAAC,IAAZ,QAAQ,IAAK,EAC9B,IACA,SAAS;;IACf,OAAO,EAAE,QAAe,CAAE,uMAAT,UAAO;CACzB,CAAA;AAEK,SAAU,cAAc,CAAC,MAAmB;IAChD,WAAW,GAAG,MAAM,CAAA;AACtB,CAAC;AAaK,MAAO,SAAU,SAAQ,KAAK;IA2ClC,IAAI,CAAC,EAAQ,EAAA;QACX,OAAO,IAAI,CAAC,IAAI,EAAE,EAAE,CAAC,CAAA;IACvB,CAAC;IApCD,YAAY,YAAoB,EAAE,OAA4B,CAAA,CAAE,CAAA;YAW9C,WAAW;QAV3B,MAAM,OAAO,GAAG,CAAC,GAAG,EAAE;gBAEhB,IAAI;YADR,IAAI,IAAI,CAAC,KAAK,YAAY,SAAS,EAAE,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,CAAA;YAC9D,wBAAS,KAAK,4DAAE,OAAO,EAAE,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,CAAA;YAClD,OAAO,IAAI,CAAC,OAAQ,CAAA;QACtB,CAAC,CAAC,EAAE,CAAA;QACJ,MAAM,QAAQ,GAAG,CAAC,GAAG,EAAE;YACrB,IAAI,IAAI,CAAC,KAAK,YAAY,SAAS,EACjC,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAA;YAC7C,OAAO,IAAI,CAAC,QAAQ,CAAA;QACtB,CAAC,CAAC,EAAE,CAAA;QACJ,MAAM,OAAO,0CAAe,UAAU,EAAE,oGAAC;YAAE,GAAG,IAAI;YAAE,QAAQ;QAAA,CAAE,CAAC,CAAA;QAE/D,MAAM,OAAO,GAAG;YACd,YAAY,IAAI,oBAAoB;YACpC,EAAE;eACE,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;mBAAG,IAAI,CAAC,YAAY;gBAAE,EAAE;aAAC,CAAC,CAAC,CAAC,EAAE,CAAC;eACpD,OAAO,CAAC,CAAC,CAAC,CAAC;gBAAA,SAAgB,CAAE,MAAT,OAAO;aAAG,CAAC,CAAC,CAAC,EAAE,CAAC;eACpC,OAAO,CAAC,CAAC,CAAC,CAAC;gBAAA,YAAmB,CAAE,MAAT,OAAO;aAAG,CAAC,CAAC,CAAC,EAAE,CAAC;eACvC,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;gBAAA,YAA+B,CAAE,MAArB,WAAW,CAAC,OAAO;aAAG,CAAC,CAAC,CAAC,EAAE,CAAC;SACpE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;QAEZ,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;YAAE,KAAK,EAAE,IAAI,CAAC,KAAK;QAAA,CAAE,CAAC,CAAC,CAAC,SAAS,CAAC,CAAA;QA9BhE,OAAA,cAAA,CAAA,IAAA,EAAA,WAAA;;;;;WAAe;QACf,OAAA,cAAA,CAAA,IAAA,EAAA,YAAA;;;;;WAA6B;QAC7B,OAAA,cAAA,CAAA,IAAA,EAAA,gBAAA;;;;;WAAmC;QACnC,OAAA,cAAA,CAAA,IAAA,EAAA,gBAAA;;;;;WAAoB;QACpB,OAAA,cAAA,CAAA,IAAA,EAAA,WAAA;;;;;WAAe;QAEN,OAAA,cAAA,CAAA,IAAA,EAAA,QAAA;;;;mBAAO,WAAW;WAAA;QA0BzB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAA;QACtB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAA;QACxB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,CAAA;;QACrC,IAAI,CAAC,IAAI,sBAAQ,IAAI,sCAAT,IAAI,SAAS,IAAI,CAAC,IAAI,CAAA;QAClC,IAAI,CAAC,YAAY,GAAG,YAAY,CAAA;QAChC,IAAI,CAAC,OAAO,oMAAG,UAAO,CAAA;IACxB,CAAC;CAOF;AAED,SAAS,IAAI,CACX,GAAY,EACZ,EAA4C;IAE5C,4CAAI,EAAE,CAAG,CAAD,EAAI,CAAC,EAAE,OAAO,GAAG,CAAA;IACzB,IACE,GAAG,IACH,OAAO,GAAG,KAAK,QAAQ,IACvB,OAAO,IAAI,GAAG,IACd,GAAG,CAAC,KAAK,KAAK,SAAS,EAEvB,OAAO,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE,CAAC,CAAA;IAC5B,OAAO,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAA;AACxB,CAAC","debugId":null}},
    {"offset": {"line": 123, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/address.js","sourceRoot":"","sources":["../../errors/address.ts"],"sourcesContent":[],"names":[],"mappings":";;;AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,WAAW,CAAA;;AAK/B,MAAO,mBAAoB,uMAAQ,YAAS;IAChD,YAAY,EAAE,OAAO,EAAuB,CAAA;QAC1C,KAAK,CAAC,YAAmB,OAAP,OAAO,EAAA,cAAe,IAAE;YACxC,YAAY,EAAE;gBACZ,gEAAgE;gBAChE,gDAAgD;aACjD;YACD,IAAI,EAAE,qBAAqB;SAC5B,CAAC,CAAA;IACJ,CAAC;CACF","debugId":null}},
    {"offset": {"line": 143, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/isHex.js","sourceRoot":"","sources":["../../../utils/data/isHex.ts"],"sourcesContent":[],"names":[],"mappings":";;;AAKM,SAAU,KAAK,CACnB,KAAc;UACZ,MAAM,GAAG,IAAI,EAAA,GAAf,iEAAsD,CAAA,CAAE;IAExD,IAAI,CAAC,KAAK,EAAE,OAAO,KAAK,CAAA;IACxB,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,OAAO,KAAK,CAAA;IAC3C,OAAO,MAAM,CAAC,CAAC,CAAC,kBAAkB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA;AACzE,CAAC","debugId":null}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/data.js","sourceRoot":"","sources":["../../errors/data.ts"],"sourcesContent":[],"names":[],"mappings":";;;;;AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,WAAW,CAAA;;AAK/B,MAAO,2BAA4B,uMAAQ,YAAS;IACxD,YAAY,EACV,MAAM,EACN,QAAQ,EACR,IAAI,EACwD,CAAA;QAC5D,KAAK,CACH,SAEe,MAAM,CADnB,QAAQ,KAAK,OAAO,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,QACtC,EAAA,+BAAqB,8BAAiC,OAAJ,IAAI,EAAA,GAAI,IAC1D;YAAE,IAAI,EAAE,6BAA6B;QAAA,CAAE,CACxC,CAAA;IACH,CAAC;CACF;AAKK,MAAO,2BAA4B,sMAAQ,aAAS;IACxD,YAAY,EACV,IAAI,EACJ,UAAU,EACV,IAAI,EAKL,CAAA;QACC,KAAK,CACH,UAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,EAEL,IAAI,GAFI,IAAI,CACnC,KAAK,CAAC,CAAC,CAAC,CACR,WAAW,EAAE,EAAA,WAAyC,UAAU,GAArC,4BAAqC,GAAI,gBAAJ,OACnE;YAAE,IAAI,EAAE,6BAA6B;QAAA,CAAE,CACxC,CAAA;IACH,CAAC;CACF;AAKK,MAAO,uBAAwB,uMAAQ,YAAS;IACpD,YAAY,EACV,IAAI,EACJ,UAAU,EACV,IAAI,EAKL,CAAA;QACC,KAAK,CACH,UAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,SAAG,IAAI,CACnC,KAAK,CAAC,CAAC,CAAC,CACR,WAAW,EAAE,EAAA,8BAAsB,UAAU,EAAA,YAAI,IAAI,EAAA,yBAAiB,IAAI,EAAA,KAAQ,OAAJ,IAAI,EAAA,OAAQ,IAC7F;YAAE,IAAI,EAAE,yBAAyB;QAAA,CAAE,CACpC,CAAA;IACH,CAAC;CACF","debugId":null}},
    {"offset": {"line": 188, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/pad.js","sourceRoot":"","sources":["../../../utils/data/pad.ts"],"sourcesContent":[],"names":[],"mappings":";;;;;AAAA,OAAO,EACL,2BAA2B,GAE5B,MAAM,sBAAsB,CAAA;;AAcvB,SAAU,GAAG,CACjB,UAAiB;UACf,GAAG,EAAE,IAAI,GAAG,EAAE,EAAA,GAAhB,iEAAiC,CAAA,CAAE;IAEnC,IAAI,OAAO,UAAU,KAAK,QAAQ,EAChC,OAAO,MAAM,CAAC,UAAU,EAAE;QAAE,GAAG;QAAE,IAAI;IAAA,CAAE,CAAyB,CAAA;IAClE,OAAO,QAAQ,CAAC,UAAU,EAAE;QAAE,GAAG;QAAE,IAAI;IAAA,CAAE,CAAyB,CAAA;AACpE,CAAC;AAIK,SAAU,MAAM,CAAC,IAAS;UAAI,GAAG,EAAE,IAAI,GAAG,EAAE,EAAA,GAAhB,iEAAiC,CAAA,CAAE;IACnE,IAAI,IAAI,KAAK,IAAI,EAAE,OAAO,IAAI,CAAA;IAC9B,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAA;IAClC,IAAI,GAAG,CAAC,MAAM,GAAG,IAAI,GAAG,CAAC,EACvB,MAAM,kMAAI,8BAA2B,CAAC;QACpC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC;QAC/B,UAAU,EAAE,IAAI;QAChB,IAAI,EAAE,KAAK;KACZ,CAAC,CAAA;IAEJ,OAAO,KAGN,CAAS,CAAA,KAHE,GAAG,CAAC,GAAG,KAAK,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,UAAU,CAAC,CACtD,IAAI,GAAG,CAAC,EACR,GAAG,CACJ;AACH,CAAC;AAIK,SAAU,QAAQ,CACtB,KAAgB;UACd,GAAG,EAAE,IAAI,GAAG,EAAE,EAAA,GAAhB,iEAAiC,CAAA,CAAE;IAEnC,IAAI,IAAI,KAAK,IAAI,EAAE,OAAO,KAAK,CAAA;IAC/B,IAAI,KAAK,CAAC,MAAM,GAAG,IAAI,EACrB,MAAM,kMAAI,8BAA2B,CAAC;QACpC,IAAI,EAAE,KAAK,CAAC,MAAM;QAClB,UAAU,EAAE,IAAI;QAChB,IAAI,EAAE,OAAO;KACd,CAAC,CAAA;IACJ,MAAM,WAAW,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,CAAA;IACxC,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,CAAE,CAAC;QAC9B,MAAM,MAAM,GAAG,GAAG,KAAK,OAAO,CAAA;QAC9B,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,GACpC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC,CAAA;IAC5C,CAAC;IACD,OAAO,WAAW,CAAA;AACpB,CAAC","debugId":null}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/encoding.js","sourceRoot":"","sources":["../../errors/encoding.ts"],"sourcesContent":[],"names":[],"mappings":";;;;;;;AAEA,OAAO,EAAE,SAAS,EAAE,MAAM,WAAW,CAAA;;AAK/B,MAAO,sBAAuB,uMAAQ,YAAS;IACnD,YAAY,EACV,GAAG,EACH,GAAG,EACH,MAAM,EACN,IAAI,EACJ,KAAK,EAON,CAAA;QACC,KAAK,CACH,kBAAW,KAAK,EAAA,4BACd,IAAI,CAAC,CAAC,CAAC,UAAG,IAAI,GAAG,CAAC,EAAA,SAAsC,OAA9B,MAAM,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,UAAU,EAAA,EAAG,CAAC,CAAC,GAAC,EAChE,EAAA,kBAA8D,CAAE,MAA/C,GAAG,CAAC,CAAC,CAAC,IAAc,GAAG,IAAb,GAAG,EAAA,QAAU,YAAA,EAAG,CAAC,CAAC,GAAC,UAAa,OAAH,GAAG,EAAA,EAAG,KAC9D;YAAE,IAAI,EAAE,wBAAwB;QAAA,CAAE,CACnC,CAAA;IACH,CAAC;CACF;AAKK,MAAO,wBAAyB,uMAAQ,YAAS;IACrD,YAAY,KAAgB,CAAA;QAC1B,KAAK,CACH,gBAAqB,OAAL,KAAK,EAAA,+FAAgG,IACrH;YACE,IAAI,EAAE,0BAA0B;SACjC,CACF,CAAA;IACH,CAAC;CACF;AAKK,MAAO,sBAAuB,uMAAQ,YAAS;IACnD,YAAY,GAAQ,CAAA;QAClB,KAAK,CACH,cAAiB,OAAH,GAAG,EAAA,+EAAgF,IACjG;YAAE,IAAI,EAAE,wBAAwB;QAAA,CAAE,CACnC,CAAA;IACH,CAAC;CACF;AAKK,MAAO,oBAAqB,sMAAQ,aAAS;IACjD,YAAY,KAAU,CAAA;QACpB,KAAK,CACH,qBAAc,KAAK,EAAA,wBAAmC,OAAZ,KAAK,CAAC,MAAM,EAAA,8BAA+B,IACrF;YAAE,IAAI,EAAE,sBAAsB;QAAA,CAAE,CACjC,CAAA;IACH,CAAC;CACF;AAKK,MAAO,iBAAkB,uMAAQ,YAAS;IAC9C,YAAY,EAAE,SAAS,EAAE,OAAO,EAA0C,CAAA;QACxE,KAAK,CACH,6BAAsB,OAAO,EAAA,wBAAgC,OAAT,SAAS,EAAA,QAAS,IACtE;YAAE,IAAI,EAAE,mBAAmB;QAAA,CAAE,CAC9B,CAAA;IACH,CAAC;CACF","debugId":null}},
    {"offset": {"line": 284, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/size.js","sourceRoot":"","sources":["../../../utils/data/size.ts"],"sourcesContent":[],"names":[],"mappings":";;;AAGA,OAAO,EAAuB,KAAK,EAAE,MAAM,YAAY,CAAA;;AAUjD,SAAU,IAAI,CAAC,KAAsB;IACzC,8MAAI,QAAA,AAAK,EAAC,KAAK,EAAE;QAAE,MAAM,EAAE,KAAK;IAAA,CAAE,CAAC,EAAE,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAA;IAC7E,OAAO,KAAK,CAAC,MAAM,CAAA;AACrB,CAAC","debugId":null}},
    {"offset": {"line": 299, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/trim.js","sourceRoot":"","sources":["../../../utils/data/trim.ts"],"sourcesContent":[],"names":[],"mappings":";;;AAYM,SAAU,IAAI,CAClB,UAAiB;UACf,GAAG,GAAG,MAAM,EAAA,GAAd,iEAAgC,CAAA,CAAE;IAElC,IAAI,IAAI,GACN,OAAO,UAAU,KAAK,QAAQ,CAAC,CAAC,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,UAAU,CAAA;IAE5E,IAAI,WAAW,GAAG,CAAC,CAAA;IACnB,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC;QACzC,IAAI,IAAI,CAAC,GAAG,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ,EAAE,KAAK,GAAG,EACnE,WAAW,EAAE,CAAA;aACV,MAAK;IACZ,CAAC;IACD,IAAI,GACF,GAAG,KAAK,MAAM,GACV,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,GACvB,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,GAAG,WAAW,CAAC,CAAA;IAE9C,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE,CAAC;QACnC,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,IAAI,GAAG,KAAK,OAAO,EAAE,IAAI,GAAG,GAAO,OAAJ,IAAI,EAAA,EAAG,CAAA;QAC3D,OAAO,KAEP,CAA2B,CAAA,KADzB,IAAI,CAAC,MAAM,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAQ,CAAE,CAAC,CAAC,IAAR,IAAI,IAAK,IACvC;IACF,CAAC;IACD,OAAO,IAA6B,CAAA;AACtC,CAAC","debugId":null}},
    {"offset": {"line": 321, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/fromHex.js","sourceRoot":"","sources":["../../../utils/encoding/fromHex.ts"],"sourcesContent":[],"names":[],"mappings":";;;;;;;;AAAA,OAAO,EACL,sBAAsB,EAEtB,iBAAiB,GAElB,MAAM,0BAA0B,CAAA;AAGjC,OAAO,EAAsB,IAAI,IAAI,KAAK,EAAE,MAAM,iBAAiB,CAAA;AACnE,OAAO,EAAsB,IAAI,EAAE,MAAM,iBAAiB,CAAA;AAE1D,OAAO,EAA4B,UAAU,EAAE,MAAM,cAAc,CAAA;;;;;AAO7D,SAAU,UAAU,CACxB,UAA2B;UACzB,IAAI,EAAoB,GAA1B;IAEA,6MAAI,OAAA,AAAK,EAAC,UAAU,CAAC,GAAG,IAAI,EAC1B,MAAM,sMAAI,oBAAiB,CAAC;QAC1B,SAAS,2MAAE,OAAA,AAAK,EAAC,UAAU,CAAC;QAC5B,OAAO,EAAE,IAAI;KACd,CAAC,CAAA;AACN,CAAC;AA6DK,SAAU,OAAO,CAErB,GAAQ,EAAE,QAA+B;IACzC,MAAM,IAAI,GAAG,OAAO,QAAQ,KAAK,QAAQ,CAAC,CAAC,CAAC;QAAE,EAAE,EAAE,QAAQ;IAAA,CAAE,CAAC,CAAC,CAAC,QAAQ,CAAA;IACvE,MAAM,EAAE,GAAG,IAAI,CAAC,EAAE,CAAA;IAElB,IAAI,EAAE,KAAK,QAAQ,EAAE,OAAO,WAAW,CAAC,GAAG,EAAE,IAAI,CAA0B,CAAA;IAC3E,IAAI,EAAE,KAAK,QAAQ,EAAE,OAAO,WAAW,CAAC,GAAG,EAAE,IAAI,CAA0B,CAAA;IAC3E,IAAI,EAAE,KAAK,QAAQ,EAAE,OAAO,WAAW,CAAC,GAAG,EAAE,IAAI,CAA0B,CAAA;IAC3E,IAAI,EAAE,KAAK,SAAS,EAAE,OAAO,SAAS,CAAC,GAAG,EAAE,IAAI,CAA0B,CAAA;IAC1E,OAAO,6NAAA,AAAU,EAAC,GAAG,EAAE,IAAI,CAA0B,CAAA;AACvD,CAAC;AA8BK,SAAU,WAAW,CAAC,GAAQ;eAAE,iEAAwB,CAAA,CAAE;IAC9D,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAA;IAEvB,IAAI,IAAI,CAAC,IAAI,EAAE,UAAU,CAAC,GAAG,EAAE;QAAE,IAAI,EAAE,IAAI,CAAC,IAAI;IAAA,CAAE,CAAC,CAAA;IAEnD,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,CAAA;IACzB,IAAI,CAAC,MAAM,EAAE,OAAO,KAAK,CAAA;IAEzB,MAAM,IAAI,GAAG,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,CAAA;IACjC,MAAM,GAAG,GAAG,CAAC,EAAE,IAAI,AAAC,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,AAAC,CAAC,GAAG,EAAE,CAAA;IACjD,IAAI,KAAK,IAAI,GAAG,EAAE,OAAO,KAAK,CAAA;IAE9B,OAAO,KAAK,GAAG,MAAM,CAAC,KAAgC,CAAE,CAAC,KAA9B,GAAG,CAAC,QAAQ,CAAC,IAAI,GAAG,CAAC,EAAE,GAAG,CAAC,KAAM,EAAE,CAAA;AAChE,CAAC;AAgCK,SAAU,SAAS,CAAC,IAAS;eAAE,iEAAsB,CAAA,CAAE;IAC3D,IAAI,GAAG,GAAG,IAAI,CAAA;IACd,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;QACd,UAAU,CAAC,GAAG,EAAE;YAAE,IAAI,EAAE,IAAI,CAAC,IAAI;QAAA,CAAE,CAAC,CAAA;QACpC,GAAG,4MAAG,OAAA,AAAI,EAAC,GAAG,CAAC,CAAA;IACjB,CAAC;IACD,KAAI,+MAAI,AAAJ,EAAK,GAAG,CAAC,KAAK,MAAM,EAAE,OAAO,KAAK,CAAA;IACtC,6MAAI,OAAA,AAAI,EAAC,GAAG,CAAC,KAAK,MAAM,EAAE,OAAO,IAAI,CAAA;IACrC,MAAM,sMAAI,yBAAsB,CAAC,GAAG,CAAC,CAAA;AACvC,CAAC;AAyBK,SAAU,WAAW,CAAC,GAAQ;eAAE,iEAAwB,CAAA,CAAE;IAC9D,OAAO,MAAM,CAAC,WAAW,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAA;AACvC,CAAC;AAkCK,SAAU,WAAW,CAAC,GAAQ;eAAE,iEAAwB,CAAA,CAAE;IAC9D,IAAI,KAAK,mNAAG,aAAA,AAAU,EAAC,GAAG,CAAC,CAAA;IAC3B,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;QACd,UAAU,CAAC,KAAK,EAAE;YAAE,IAAI,EAAE,IAAI,CAAC,IAAI;QAAA,CAAE,CAAC,CAAA;QACtC,KAAK,GAAG,gNAAA,AAAI,EAAC,KAAK,EAAE;YAAE,GAAG,EAAE,OAAO;QAAA,CAAE,CAAC,CAAA;IACvC,CAAC;IACD,OAAO,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,CAAA;AACxC,CAAC","debugId":null}},
    {"offset": {"line": 402, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/toHex.js","sourceRoot":"","sources":["../../../utils/encoding/toHex.ts"],"sourcesContent":[],"names":[],"mappings":";;;;;;;AAAA,OAAO,EACL,sBAAsB,GAEvB,MAAM,0BAA0B,CAAA;AAGjC,OAAO,EAAqB,GAAG,EAAE,MAAM,gBAAgB,CAAA;AAEvD,OAAO,EAA4B,UAAU,EAAE,MAAM,cAAc,CAAA;;;;AAEnE,MAAM,KAAK,GAAG,WAAA,EAAa,CAAC,KAAK,CAAC,IAAI,CAAC;IAAE,MAAM,EAAE,GAAG;AAAA,CAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAC9D,CADgE,AAC/D,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAChC,CAAA;AAuCK,SAAU,KAAK,CACnB,KAAqD;eACrD,iEAAwB,CAAA,CAAE;IAE1B,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,OAAO,KAAK,KAAK,QAAQ,EACxD,OAAO,WAAW,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA;IACjC,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;QAC9B,OAAO,WAAW,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA;IACjC,CAAC;IACD,IAAI,OAAO,KAAK,KAAK,SAAS,EAAE,OAAO,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA;IAC7D,OAAO,UAAU,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA;AAChC,CAAC;AAiCK,SAAU,SAAS,CAAC,KAAc;eAAE,iEAAsB,CAAA,CAAE;IAChE,MAAM,GAAG,GAAQ,KAAkB,CAAE,CAAA,KAAf,MAAM,CAAC,KAAK,CAAC;IACnC,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;YAClC,yNAAA,AAAU,EAAC,GAAG,EAAE;YAAE,IAAI,EAAE,IAAI,CAAC,IAAI;QAAA,CAAE,CAAC,CAAA;QACpC,+MAAO,MAAA,AAAG,EAAC,GAAG,EAAE;YAAE,IAAI,EAAE,IAAI,CAAC,IAAI;QAAA,CAAE,CAAC,CAAA;IACtC,CAAC;IACD,OAAO,GAAG,CAAA;AACZ,CAAC;AA4BK,SAAU,UAAU,CAAC,KAAgB;eAAE,iEAAuB,CAAA,CAAE;IACpE,IAAI,MAAM,GAAG,EAAE,CAAA;IACf,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE,CAAC;QACtC,MAAM,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAA;IAC3B,CAAC;IACD,MAAM,GAAG,GAAG,KAAW,CAAW,CAAA,KAAjB,MAAM;IAEvB,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;wNAClC,aAAA,AAAU,EAAC,GAAG,EAAE;YAAE,IAAI,EAAE,IAAI,CAAC,IAAI;QAAA,CAAE,CAAC,CAAA;QACpC,+MAAO,MAAA,AAAG,EAAC,GAAG,EAAE;YAAE,GAAG,EAAE,OAAO;YAAE,IAAI,EAAE,IAAI,CAAC,IAAI;QAAA,CAAE,CAAC,CAAA;IACpD,CAAC;IACD,OAAO,GAAG,CAAA;AACZ,CAAC;AAuCK,SAAU,WAAW,CACzB,MAAuB;eACvB,iEAAwB,CAAA,CAAE;IAE1B,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,CAAA;IAE7B,MAAM,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,CAAA;IAE5B,IAAI,QAAqC,CAAA;IACzC,IAAI,IAAI,EAAE,CAAC;QACT,IAAI,MAAM,EAAE,QAAQ,GAAG,CAAC,EAAE,IAAI,AAAC,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,AAAC,CAAC,GAAG,EAAE,CAAA;aACvD,QAAQ,GAAG,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAA;IAChD,CAAC,MAAM,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE,CAAC;QACtC,QAAQ,GAAG,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAA;IAC5C,CAAC;IAED,MAAM,QAAQ,GAAG,OAAO,QAAQ,KAAK,QAAQ,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,QAAQ,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAA;IAE5E,IAAI,AAAC,QAAQ,IAAI,KAAK,GAAG,QAAQ,CAAC,GAAI,KAAK,GAAG,QAAQ,EAAE,CAAC;QACvD,MAAM,MAAM,GAAG,OAAO,MAAM,KAAK,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAA;QACpD,MAAM,sMAAI,yBAAsB,CAAC;YAC/B,GAAG,EAAE,QAAQ,CAAC,CAAC,CAAC,UAAG,QAAQ,EAAS,CAAE,CAAC,CAAC,IAAV,MAAM,IAAK,SAAS;YAClD,GAAG,EAAE,UAAG,QAAQ,EAAS,CAAE,MAAR,MAAM;YACzB,MAAM;YACN,IAAI;YACJ,KAAK,EAAE,UAAG,MAAM,EAAS,CAAE,MAAR,MAAM;SAC1B,CAAC,CAAA;IACJ,CAAC;IAED,MAAM,GAAG,GAAG,KAEE,CAAS,CAAA,KAFN,CACf,MAAM,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,MAAM,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CACvE,CAAC,QAAQ,CAAC,EAAE,CAAC;IACd,IAAI,IAAI,EAAE,QAAO,6MAAG,AAAH,EAAI,GAAG,EAAE;QAAE,IAAI;IAAA,CAAE,CAAQ,CAAA;IAC1C,OAAO,GAAG,CAAA;AACZ,CAAC;AASD,MAAM,OAAO,GAAG,WAAA,EAAa,CAAC,IAAI,WAAW,EAAE,CAAA;AAqBzC,SAAU,WAAW,CAAC,MAAc;eAAE,iEAAwB,CAAA,CAAE;IACpE,MAAM,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;IACpC,OAAO,UAAU,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA;AAChC,CAAC","debugId":null}},
    {"offset": {"line": 496, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/toBytes.js","sourceRoot":"","sources":["../../../utils/encoding/toBytes.ts"],"sourcesContent":[],"names":[],"mappings":";;;;;;;AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,sBAAsB,CAAA;AAGhD,OAAO,EAAuB,KAAK,EAAE,MAAM,kBAAkB,CAAA;AAC7D,OAAO,EAAqB,GAAG,EAAE,MAAM,gBAAgB,CAAA;AAEvD,OAAO,EAA4B,UAAU,EAAE,MAAM,cAAc,CAAA;AACnE,OAAO,EAGL,WAAW,GACZ,MAAM,YAAY,CAAA;;;;;;AAEnB,MAAM,OAAO,GAAG,WAAA,EAAa,CAAC,IAAI,WAAW,EAAE,CAAA;AAwCzC,SAAU,OAAO,CACrB,KAA+C;eAC/C,iEAA0B,CAAA,CAAE;IAE5B,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,OAAO,KAAK,KAAK,QAAQ,EACxD,OAAO,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA;IACnC,IAAI,OAAO,KAAK,KAAK,SAAS,EAAE,OAAO,WAAW,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA;IAC/D,IAAI,kNAAA,AAAK,EAAC,KAAK,CAAC,EAAE,OAAO,UAAU,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA;IAChD,OAAO,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA;AACnC,CAAC;AA+BK,SAAU,WAAW,CAAC,KAAc;eAAE,iEAAwB,CAAA,CAAE;IACpE,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,CAAC,CAAC,CAAA;IAC/B,KAAK,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,CAAA;IACxB,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;wNAClC,aAAA,AAAU,EAAC,KAAK,EAAE;YAAE,IAAI,EAAE,IAAI,CAAC,IAAI;QAAA,CAAE,CAAC,CAAA;QACtC,WAAO,0MAAA,AAAG,EAAC,KAAK,EAAE;YAAE,IAAI,EAAE,IAAI,CAAC,IAAI;QAAA,CAAE,CAAC,CAAA;IACxC,CAAC;IACD,OAAO,KAAK,CAAA;AACd,CAAC;AAED,sEAAsE;AACtE,MAAM,WAAW,GAAG;IAClB,IAAI,EAAE,EAAE;IACR,IAAI,EAAE,EAAE;IACR,CAAC,EAAE,EAAE;IACL,CAAC,EAAE,EAAE;IACL,CAAC,EAAE,EAAE;IACL,CAAC,EAAE,GAAG;CACE,CAAA;AAEV,SAAS,gBAAgB,CAAC,IAAY;IACpC,IAAI,IAAI,IAAI,WAAW,CAAC,IAAI,IAAI,IAAI,IAAI,WAAW,CAAC,IAAI,EACtD,OAAO,IAAI,GAAG,WAAW,CAAC,IAAI,CAAA;IAChC,IAAI,IAAI,IAAI,WAAW,CAAC,CAAC,IAAI,IAAI,IAAI,WAAW,CAAC,CAAC,EAChD,OAAO,IAAI,GAAG,CAAC,WAAW,CAAC,CAAC,GAAG,EAAE,CAAC,CAAA;IACpC,IAAI,IAAI,IAAI,WAAW,CAAC,CAAC,IAAI,IAAI,IAAI,WAAW,CAAC,CAAC,EAChD,OAAO,IAAI,GAAG,CAAC,WAAW,CAAC,CAAC,GAAG,EAAE,CAAC,CAAA;IACpC,OAAO,SAAS,CAAA;AAClB,CAAC;AA4BK,SAAU,UAAU,CAAC,IAAS;eAAE,iEAAuB,CAAA,CAAE;IAC7D,IAAI,GAAG,GAAG,IAAI,CAAA;IACd,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;QACd,6NAAA,AAAU,EAAC,GAAG,EAAE;YAAE,IAAI,EAAE,IAAI,CAAC,IAAI;QAAA,CAAE,CAAC,CAAA;QACpC,GAAG,2MAAG,MAAG,AAAH,EAAI,GAAG,EAAE;YAAE,GAAG,EAAE,OAAO;YAAE,IAAI,EAAE,IAAI,CAAC,IAAI;QAAA,CAAE,CAAC,CAAA;IACnD,CAAC;IAED,IAAI,SAAS,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,CAAW,CAAA;IACtC,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,SAAS,GAAG,IAAa,CAAE,CAAA,KAAX,SAAS;IAEnD,MAAM,MAAM,GAAG,SAAS,CAAC,MAAM,GAAG,CAAC,CAAA;IACnC,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,CAAA;IACpC,IAAK,IAAI,KAAK,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,KAAK,GAAG,MAAM,EAAE,KAAK,EAAE,CAAE,CAAC;QACnD,MAAM,UAAU,GAAG,gBAAgB,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;QAC9D,MAAM,WAAW,GAAG,gBAAgB,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;QAC/D,IAAI,UAAU,KAAK,SAAS,IAAI,WAAW,KAAK,SAAS,EAAE,CAAC;YAC1D,MAAM,kMAAI,YAAS,CACjB,2BACE,OADyB,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,kBAChC,CAAC,CAAC,GAAG,CAAC,CACjB,EAAA,UAAkB,OAAT,SAAS,EAAA,IAAK,CACxB,CAAA;QACH,CAAC;QACD,KAAK,CAAC,KAAK,CAAC,GAAG,UAAU,GAAG,EAAE,GAAG,WAAW,CAAA;IAC9C,CAAC;IACD,OAAO,KAAK,CAAA;AACd,CAAC;AA0BK,SAAU,aAAa,CAC3B,KAAsB,EACtB,IAAkC;IAElC,MAAM,GAAG,iNAAG,cAAA,AAAW,EAAC,KAAK,EAAE,IAAI,CAAC,CAAA;IACpC,OAAO,UAAU,CAAC,GAAG,CAAC,CAAA;AACxB,CAAC;AA+BK,SAAU,aAAa,CAC3B,KAAa;eACb,iEAA0B,CAAA,CAAE;IAE5B,MAAM,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAA;IACnC,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;QAClC,6NAAA,AAAU,EAAC,KAAK,EAAE;YAAE,IAAI,EAAE,IAAI,CAAC,IAAI;QAAA,CAAE,CAAC,CAAA;QACtC,+MAAO,MAAA,AAAG,EAAC,KAAK,EAAE;YAAE,GAAG,EAAE,OAAO;YAAE,IAAI,EAAE,IAAI,CAAC,IAAI;QAAA,CAAE,CAAC,CAAA;IACtD,CAAC;IACD,OAAO,KAAK,CAAA;AACd,CAAC","debugId":null}},
    {"offset": {"line": 598, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/_assert.js","sourceRoot":"","sources":["../src/_assert.ts"],"sourcesContent":[],"names":[],"mappings":"AAAA;;;GAGG,CAEH,2CAAA,EAA6C;;;;;;;AAC7C,SAAS,OAAO,CAAC,CAAS;IACxB,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,iCAAiC,GAAG,CAAC,CAAC,CAAC;AAChG,CAAC;AAED,yDAAA,EAA2D,CAC3D,SAAS,OAAO,CAAC,CAAU;IACzB,OAAO,CAAC,YAAY,UAAU,IAAI,AAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,WAAW,CAAC,IAAI,KAAK,YAAY,CAAC,CAAC;AACnG,CAAC;AAED,qCAAA,EAAuC,CACvC,SAAS,MAAM,CAAC,CAAyB;QAAE;QAAG,mCAAiB;;IAC7D,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;IACxD,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,EACnD,MAAM,IAAI,KAAK,CAAC,gCAAgC,GAAG,OAAO,GAAG,eAAe,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC;AAC7F,CAAC;AAUD,8BAAA,EAAgC,CAChC,SAAS,KAAK,CAAC,CAAO;IACpB,IAAI,OAAO,CAAC,KAAK,UAAU,IAAI,OAAO,CAAC,CAAC,MAAM,KAAK,UAAU,EAC3D,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;IACrE,OAAO,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;IACrB,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;AACtB,CAAC;AAED,8DAAA,EAAgE,CAChE,SAAS,OAAO,CAAC,QAAa;wBAAE,aAAa,oDAAG,IAAI;IAClD,IAAI,QAAQ,CAAC,SAAS,EAAE,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;IAC5E,IAAI,aAAa,IAAI,QAAQ,CAAC,QAAQ,EAAE,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;AACnG,CAAC;AAED,gDAAA,EAAkD,CAClD,SAAS,OAAO,CAAC,GAAQ,EAAE,QAAa;IACtC,MAAM,CAAC,GAAG,CAAC,CAAC;IACZ,MAAM,GAAG,GAAG,QAAQ,CAAC,SAAS,CAAC;IAC/B,IAAI,GAAG,CAAC,MAAM,GAAG,GAAG,EAAE,CAAC;QACrB,MAAM,IAAI,KAAK,CAAC,wDAAwD,GAAG,GAAG,CAAC,CAAC;IAClF,CAAC;AACH,CAAC","debugId":null}},
    {"offset": {"line": 644, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/_u64.js","sourceRoot":"","sources":["../src/_u64.ts"],"sourcesContent":[],"names":[],"mappings":"AAAA;;;;GAIG;;;;;;;;;;;;;;;;;;;;;;;;;AACH,MAAM,UAAU,GAAG,aAAA,EAAe,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC;AACvD,MAAM,IAAI,GAAG,aAAA,EAAe,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AAExC,SAAS,OAAO,CACd,CAAS;aACT,EAAE,+DAAG,KAAK;IAKV,IAAI,EAAE,EAAE,OAAO;QAAE,CAAC,EAAE,MAAM,CAAC,CAAC,GAAG,UAAU,CAAC;QAAE,CAAC,EAAE,MAAM,CAAE,AAAD,CAAE,IAAI,IAAI,CAAC,EAAG,UAAU,CAAC;IAAA,CAAE,CAAC;IAClF,OAAO;QAAE,CAAC,EAAE,MAAM,CAAC,AAAC,CAAC,IAAI,IAAI,CAAC,EAAG,UAAU,CAAC,GAAG,CAAC;QAAE,CAAC,EAAE,MAAM,CAAC,CAAC,GAAG,UAAU,CAAC,GAAG,CAAC;IAAA,CAAE,CAAC;AACpF,CAAC;AAED,SAAS,KAAK,CAAC,GAAa;aAAE,EAAE,+DAAG,KAAK;IACtC,IAAI,EAAE,GAAG,IAAI,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IACrC,IAAI,EAAE,GAAG,IAAI,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IACrC,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE,CAAC;QACpC,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;QACrC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG;YAAC,CAAC;YAAE,CAAC;SAAC,CAAC;IAC1B,CAAC;IACD,OAAO;QAAC,EAAE;QAAE,EAAE;KAAC,CAAC;AAClB,CAAC;AAED,MAAM,KAAK,GAAG,CAAC,CAAS,EAAE,CAAS,EAAU,CAAG,AAAC,CAAF,KAAQ,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,IAAI,CAAC,EAAG,MAAM,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;AAC5F,uBAAuB;AACvB,MAAM,KAAK,GAAG,CAAC,CAAS,EAAE,EAAU,EAAE,CAAS,EAAU,CAAG,CAAD,AAAE,KAAK,CAAC,CAAC;AACpE,MAAM,KAAK,GAAG,CAAC,CAAS,EAAE,CAAS,EAAE,CAAS,EAAU,CAAG,AAAC,CAAF,AAAG,IAAI,AAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAI,CAAC,CAAF,IAAO,CAAC,CAAC,CAAC;AACvF,oCAAoC;AACpC,MAAM,MAAM,GAAG,CAAC,CAAS,EAAE,CAAS,EAAE,CAAS,EAAU,CAAI,AAAD,CAAE,AAAH,KAAQ,CAAC,CAAC,EAAI,CAAD,AAAE,IAAK,AAAD,EAAG,GAAG,CAAC,CAAC,CAAC,CAAC;AACxF,MAAM,MAAM,GAAG,CAAC,CAAS,EAAE,CAAS,EAAE,CAAS,EAAU,CAAI,AAAD,CAAE,AAAH,IAAO,AAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAI,CAAC,CAAF,IAAO,CAAC,CAAC,CAAC;AACxF,gEAAgE;AAChE,MAAM,MAAM,GAAG,CAAC,CAAS,EAAE,CAAS,EAAE,CAAS,EAAU,CAAG,AAAC,CAAF,AAAG,IAAI,AAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAI,CAAC,CAAF,IAAO,AAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;AAC/F,MAAM,MAAM,GAAG,CAAC,CAAS,EAAE,CAAS,EAAE,CAAS,EAAU,CAAG,AAAC,CAAF,AAAG,KAAM,AAAD,CAAE,GAAG,EAAE,CAAC,CAAC,CAAI,CAAC,CAAF,GAAM,AAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;AAC/F,+CAA+C;AAC/C,MAAM,OAAO,GAAG,CAAC,EAAU,EAAE,CAAS,EAAU,CAAG,CAAD,AAAE,CAAC;AACrD,MAAM,OAAO,GAAG,CAAC,CAAS,EAAE,EAAU,EAAU,CAAG,CAAD,AAAE,CAAC;AACrD,mCAAmC;AACnC,MAAM,MAAM,GAAG,CAAC,CAAS,EAAE,CAAS,EAAE,CAAS,EAAU,CAAG,AAAC,CAAC,AAAH,IAAO,CAAC,CAAC,EAAI,CAAD,AAAE,KAAK,AAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;AACxF,MAAM,MAAM,GAAG,CAAC,CAAS,EAAE,CAAS,EAAE,CAAS,EAAU,CAAG,AAAC,CAAF,AAAG,IAAI,CAAC,CAAC,EAAI,CAAD,AAAE,KAAK,AAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;AACxF,+DAA+D;AAC/D,MAAM,MAAM,GAAG,CAAC,CAAS,EAAE,CAAS,EAAE,CAAS,EAAU,CAAG,AAAC,CAAF,AAAG,IAAI,AAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAI,CAAC,CAAF,IAAQ,AAAD,EAAG,GAAG,CAAC,CAAC,CAAC,CAAC;AAC/F,MAAM,MAAM,GAAG,CAAC,CAAS,EAAE,CAAS,EAAE,CAAS,EAAU,CAAG,AAAC,CAAF,AAAG,IAAI,AAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAI,CAAC,CAAF,IAAO,AAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;AAE/F,8EAA8E;AAC9E,0EAA0E;AAC1E,SAAS,GAAG,CACV,EAAU,EACV,EAAU,EACV,EAAU,EACV,EAAU;IAKV,MAAM,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;IAClC,OAAO;QAAE,CAAC,EAAE,AAAC,EAAE,GAAG,EAAE,GAAG,CAAC,AAAC,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,EAAG,CAAC,CAAC,CAAC,EAAG,CAAC;QAAE,CAAC,EAAE,CAAC,GAAG,CAAC;IAAA,CAAE,CAAC;AAC9D,CAAC;AACD,qCAAqC;AACrC,MAAM,KAAK,GAAG,CAAC,EAAU,EAAE,EAAU,EAAE,EAAU,EAAU,CAAG,CAAD,AAAE,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;AACnG,MAAM,KAAK,GAAG,CAAC,GAAW,EAAE,EAAU,EAAE,EAAU,EAAE,EAAU,EAAU,CACtE,AAAC,CADuE,CACrE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,AAAC,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC,EAAG,CAAC,CAAC,CAAC,EAAG,CAAC,CAAC;AAC7C,MAAM,KAAK,GAAG,CAAC,EAAU,EAAE,EAAU,EAAE,EAAU,EAAE,EAAU,EAAU,CACrE,CADuE,AACtE,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;AACpD,MAAM,KAAK,GAAG,CAAC,GAAW,EAAE,EAAU,EAAE,EAAU,EAAE,EAAU,EAAE,EAAU,EAAU,CAClF,AAAC,CADmF,CACjF,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,AAAC,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC,EAAG,CAAC,CAAC,CAAC,EAAG,CAAC,CAAC;AAClD,MAAM,KAAK,GAAG,CAAC,EAAU,EAAE,EAAU,EAAE,EAAU,EAAE,EAAU,EAAE,EAAU,EAAU,CACjF,CADmF,AAClF,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;AACjE,MAAM,KAAK,GAAG,CAAC,GAAW,EAAE,EAAU,EAAE,EAAU,EAAE,EAAU,EAAE,EAAU,EAAE,EAAU,EAAU,CAC7F,AAAD,CADgG,CAC7F,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,AAAC,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC,EAAG,CAAC,CAAC,CAAC,EAAG,CAAC,CAAC;;AAWvD,kBAAkB;AAClB,MAAM,GAAG,GAAkpC;IACzpC,OAAO;IAAE,KAAK;IAAE,KAAK;IACrB,KAAK;IAAE,KAAK;IACZ,MAAM;IAAE,MAAM;IAAE,MAAM;IAAE,MAAM;IAC9B,OAAO;IAAE,OAAO;IAChB,MAAM;IAAE,MAAM;IAAE,MAAM;IAAE,MAAM;IAC9B,GAAG;IAAE,KAAK;IAAE,KAAK;IAAE,KAAK;IAAE,KAAK;IAAE,KAAK;IAAE,KAAK;CAC9C,CAAC;uCACa,GAAG,CAAC","debugId":null}},
    {"offset": {"line": 769, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/crypto.js","sourceRoot":"","sources":["../src/crypto.ts"],"sourcesContent":[],"names":[],"mappings":";;;AAOO,MAAM,MAAM,GACjB,OAAO,UAAU,KAAK,QAAQ,IAAI,QAAQ,IAAI,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC","debugId":null}},
    {"offset": {"line": 777, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/utils.js","sourceRoot":"","sources":["../src/utils.ts"],"sourcesContent":[],"names":[],"mappings":"AAAA;;;GAGG,CACH,oEAAA,EAAsE,CAEtE,oFAAoF;AACpF,sEAAsE;AACtE,kEAAkE;AAClE,8DAA8D;AAC9D,+DAA+D;AAC/D,2EAA2E;;;;;;;;;;;;;;;;;;;;;;;;;;AAC3E,OAAO,EAAE,MAAM,EAAE,MAAM,sBAAsB,CAAC;AAC9C,OAAO,EAAE,MAAM,EAAE,MAAM,cAAc,CAAC;;;AAGhC,SAAU,OAAO,CAAC,CAAU;IAChC,OAAO,CAAC,YAAY,UAAU,IAAI,AAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,WAAW,CAAC,IAAI,KAAK,YAAY,CAAC,CAAC;AACnG,CAAC;AAOK,SAAU,EAAE,CAAC,GAAe;IAChC,OAAO,IAAI,UAAU,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,UAAU,CAAC,CAAC;AACpE,CAAC;AACK,SAAU,GAAG,CAAC,GAAe;IACjC,OAAO,IAAI,WAAW,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,UAAU,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;AACrF,CAAC;AAGK,SAAU,UAAU,CAAC,GAAe;IACxC,OAAO,IAAI,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,UAAU,CAAC,CAAC;AAClE,CAAC;AAGK,SAAU,IAAI,CAAC,IAAY,EAAE,KAAa;IAC9C,OAAO,AAAC,IAAI,IAAI,AAAC,EAAE,GAAG,KAAK,CAAC,CAAC,CAAI,EAAD,EAAK,KAAK,KAAK,CAAC,CAAC;AACnD,CAAC;AAEK,SAAU,IAAI,CAAC,IAAY,EAAE,KAAa;IAC9C,OAAO,AAAC,IAAI,IAAI,KAAK,CAAC,EAAI,AAAC,CAAF,GAAM,KAAK,AAAC,EAAE,GAAG,KAAK,CAAC,CAAC,GAAK,CAAC,CAAC,CAAC;AAC3D,CAAC;AAGM,MAAM,IAAI,GAAY,aAAA,EAAe,CAAC,CAAC,GAAG,CAC/C,CADiD,GAC7C,UAAU,CAAC,IAAI,WAAW,CAAC;QAAC,UAAU;KAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,EAAE,CAAC;AAEhE,SAAU,QAAQ,CAAC,IAAY;IACnC,OAAO,AACL,AAAE,CAAD,GAAK,IAAI,EAAE,CAAC,EAAG,UAAU,CAAC,EAC1B,AAAC,IAAI,IAAI,CAAC,CAAC,EAAG,QAAQ,CAAC,EACvB,AAAC,IAAI,KAAK,CAAC,CAAC,EAAG,MAAM,CAAC,EACtB,AAAC,IAAI,KAAK,EAAE,CAAC,EAAG,IAAI,CAAC,CACvB,CAAC;AACJ,CAAC;AAEM,MAAM,YAAY,GAA0B,IAAI,GACnD,CAAC,CAAS,EAAE,CAAG,CAAD,AAAE,GAChB,CAAC,CAAS,EAAE,CAAG,CAAD,OAAS,CAAC,CAAC,CAAC,CAAC;AAGzB,SAAU,UAAU,CAAC,GAAgB;IACzC,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE,CAAC;QACpC,GAAG,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5B,CAAC;AACH,CAAC;AAED,wDAAwD;AACxD,MAAM,KAAK,GAAG,aAAA,EAAe,CAAC,KAAK,CAAC,IAAI,CAAC;IAAE,MAAM,EAAE,GAAG;AAAA,CAAE,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAC/D,CADiE,AAChE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAChC,CAAC;AAKI,SAAU,UAAU,CAAC,KAAiB;2MAC1C,SAAA,AAAM,EAAC,KAAK,CAAC,CAAC;IACd,oCAAoC;IACpC,IAAI,GAAG,GAAG,EAAE,CAAC;IACb,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE,CAAC;QACtC,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAED,iEAAiE;AACjE,MAAM,MAAM,GAAG;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,CAAC,EAAE,EAAE;IAAE,CAAC,EAAE,EAAE;IAAE,CAAC,EAAE,EAAE;IAAE,CAAC,EAAE,GAAG;AAAA,CAAW,CAAC;AACxE,SAAS,aAAa,CAAC,EAAU;IAC/B,IAAI,EAAE,IAAI,MAAM,CAAC,EAAE,IAAI,EAAE,IAAI,MAAM,CAAC,EAAE,EAAE,OAAO,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC,CAAC,eAAe;IAC9E,IAAI,EAAE,IAAI,MAAM,CAAC,CAAC,IAAI,EAAE,IAAI,MAAM,CAAC,CAAC,EAAE,OAAO,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,oBAAoB;IACvF,IAAI,EAAE,IAAI,MAAM,CAAC,CAAC,IAAI,EAAE,IAAI,MAAM,CAAC,CAAC,EAAE,OAAO,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,oBAAoB;IACvF,OAAO;AACT,CAAC;AAMK,SAAU,UAAU,CAAC,GAAW;IACpC,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE,MAAM,IAAI,KAAK,CAAC,2BAA2B,GAAG,OAAO,GAAG,CAAC,CAAC;IACvF,MAAM,EAAE,GAAG,GAAG,CAAC,MAAM,CAAC;IACtB,MAAM,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;IAClB,IAAI,EAAE,GAAG,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,kDAAkD,GAAG,EAAE,CAAC,CAAC;IACrF,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,EAAE,CAAC,CAAC;IACjC,IAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,CAAC,CAAE,CAAC;QAChD,MAAM,EAAE,GAAG,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC;QAC7C,MAAM,EAAE,GAAG,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;QACjD,IAAI,EAAE,KAAK,SAAS,IAAI,EAAE,KAAK,SAAS,EAAE,CAAC;YACzC,MAAM,IAAI,GAAG,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;YACnC,MAAM,IAAI,KAAK,CAAC,8CAA8C,GAAG,IAAI,GAAG,aAAa,GAAG,EAAE,CAAC,CAAC;QAC9F,CAAC;QACD,KAAK,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC,+DAA+D;IAC3F,CAAC;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAOM,MAAM,QAAQ,GAAG,KAAK,IAAmB,EAAE,AAAE,CAAC,CAAC;AAG/C,KAAK,UAAU,SAAS,CAC7B,KAAa,EACb,IAAY,EACZ,EAAuB;IAEvB,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;IACpB,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,CAAE,CAAC;QAC/B,EAAE,CAAC,CAAC,CAAC,CAAC;QACN,+FAA+F;QAC/F,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC;QAC7B,IAAI,IAAI,IAAI,CAAC,IAAI,IAAI,GAAG,IAAI,EAAE,SAAS;QACvC,MAAM,QAAQ,EAAE,CAAC;QACjB,EAAE,IAAI,IAAI,CAAC;IACb,CAAC;AACH,CAAC;AAUK,SAAU,WAAW,CAAC,GAAW;IACrC,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE,MAAM,IAAI,KAAK,CAAC,mCAAmC,GAAG,OAAO,GAAG,CAAC,CAAC;IAC/F,OAAO,IAAI,UAAU,CAAC,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,4BAA4B;AACpF,CAAC;AASK,SAAU,OAAO,CAAC,IAAW;IACjC,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE,IAAI,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC;2MACvD,SAAM,AAAN,EAAO,IAAI,CAAC,CAAC;IACb,OAAO,IAAI,CAAC;AACd,CAAC;AAKK,SAAU,WAAW;YAAC;QAAG,8BAAoB;;IACjD,IAAI,GAAG,GAAG,CAAC,CAAC;IACZ,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE,CAAC;QACvC,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;+MACpB,SAAA,AAAM,EAAC,CAAC,CAAC,CAAC;QACV,GAAG,IAAI,CAAC,CAAC,MAAM,CAAC;IAClB,CAAC;IACD,MAAM,GAAG,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC;IAChC,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE,CAAC;QAChD,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;QACpB,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;QAChB,GAAG,IAAI,CAAC,CAAC,MAAM,CAAC;IAClB,CAAC;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAGK,MAAgB,IAAI;IAqBxB,0CAA0C;IAC1C,KAAK,GAAA;QACH,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;IAC3B,CAAC;CACF;AAcK,SAAU,SAAS,CACvB,QAAY,EACZ,IAAS;IAET,IAAI,IAAI,KAAK,SAAS,KAAI,CAAA,CAAA,CAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,iBAAiB,EACpE,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;IAC3D,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;IAC7C,OAAO,MAAiB,CAAC;AAC3B,CAAC;AAUK,SAAU,eAAe,CAC7B,QAAuB;IAOvB,MAAM,KAAK,GAAG,CAAC,GAAU,EAAc,CAAG,CAAD,OAAS,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC;IACnF,MAAM,GAAG,GAAG,QAAQ,EAAE,CAAC;IACvB,KAAK,CAAC,SAAS,GAAG,GAAG,CAAC,SAAS,CAAC;IAChC,KAAK,CAAC,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC;IAC9B,KAAK,CAAC,MAAM,GAAG,GAAG,CAAG,CAAD,OAAS,EAAE,CAAC;IAChC,OAAO,KAAK,CAAC;AACf,CAAC;AAEK,SAAU,uBAAuB,CACrC,QAA+B;IAO/B,MAAM,KAAK,GAAG,CAAC,GAAU,EAAE,IAAQ,EAAc,CAAG,CAAD,OAAS,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC;IACjG,MAAM,GAAG,GAAG,QAAQ,CAAC,CAAA,CAAO,CAAC,CAAC;IAC9B,KAAK,CAAC,SAAS,GAAG,GAAG,CAAC,SAAS,CAAC;IAChC,KAAK,CAAC,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC;IAC9B,KAAK,CAAC,MAAM,GAAG,CAAC,IAAO,EAAE,CAAG,CAAD,OAAS,CAAC,IAAI,CAAC,CAAC;IAC3C,OAAO,KAAK,CAAC;AACf,CAAC;AAEK,SAAU,0BAA0B,CACxC,QAAkC;IAOlC,MAAM,KAAK,GAAG,CAAC,GAAU,EAAE,IAAQ,EAAc,CAAG,CAAD,OAAS,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC;IACjG,MAAM,GAAG,GAAG,QAAQ,CAAC,CAAA,CAAO,CAAC,CAAC;IAC9B,KAAK,CAAC,SAAS,GAAG,GAAG,CAAC,SAAS,CAAC;IAChC,KAAK,CAAC,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC;IAC9B,KAAK,CAAC,MAAM,GAAG,CAAC,IAAO,EAAE,CAAG,CAAD,OAAS,CAAC,IAAI,CAAC,CAAC;IAC3C,OAAO,KAAK,CAAC;AACf,CAAC;AAGK,SAAU,WAAW;sBAAC,WAAW,sDAAG,EAAE;IAC1C,qMAAI,UAAM,IAAI,yMAAO,SAAM,CAAC,eAAe,KAAK,UAAU,EAAE,CAAC;QAC3D,yMAAO,SAAM,CAAC,eAAe,CAAC,IAAI,UAAU,CAAC,WAAW,CAAC,CAAC,CAAC;IAC7D,CAAC;IACD,+BAA+B;IAC/B,sMAAI,SAAM,IAAI,yMAAO,SAAM,CAAC,WAAW,KAAK,UAAU,EAAE,CAAC;QACvD,yMAAO,SAAM,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;IACzC,CAAC;IACD,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC,CAAC;AAC5D,CAAC","debugId":null}},
    {"offset": {"line": 979, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/sha3.js","sourceRoot":"","sources":["../src/sha3.ts"],"sourcesContent":[],"names":[],"mappings":"AAAA;;;;;;;;;;GAUG;;;;;;;;;;;;;;AACH,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,cAAc,CAAC;AACjE,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,WAAW,CAAC;AAClE,OAAO,EACL,UAAU,EACV,IAAI,EACJ,IAAI,EACJ,OAAO,EACP,GAAG,EACH,eAAe,EACf,0BAA0B,GAK3B,MAAM,YAAY,CAAC;;;;AAEpB,2CAA2C;AAC3C,MAAM,OAAO,GAAa,EAAE,CAAC;AAC7B,MAAM,SAAS,GAAa,EAAE,CAAC;AAC/B,MAAM,UAAU,GAAa,EAAE,CAAC;AAChC,MAAM,GAAG,GAAG,aAAA,EAAe,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACtC,MAAM,GAAG,GAAG,aAAA,EAAe,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACtC,MAAM,GAAG,GAAG,aAAA,EAAe,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACtC,MAAM,GAAG,GAAG,aAAA,EAAe,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACtC,MAAM,KAAK,GAAG,aAAA,EAAe,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AAC1C,MAAM,MAAM,GAAG,aAAA,EAAe,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AAC5C,IAAK,IAAI,KAAK,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,KAAK,GAAG,EAAE,EAAE,KAAK,EAAE,CAAE,CAAC;IAC/D,KAAK;IACL,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG;QAAC,CAAC;QAAE,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;KAAC,CAAC;IAClC,OAAO,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAC9B,aAAa;IACb,SAAS,CAAC,IAAI,CAAC,AAAE,CAAC,AAAF,KAAO,GAAG,CAAC,CAAC,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,EAAG,CAAC,CAAC,EAAG,EAAE,CAAC,CAAC;IACvD,OAAO;IACP,IAAI,CAAC,GAAG,GAAG,CAAC;IACZ,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC;QAC3B,CAAC,GAAG,CAAC,AAAC,CAAC,IAAI,GAAG,CAAC,EAAI,CAAD,AAAE,CAAC,IAAI,GAAG,CAAC,GAAG,MAAO,AAAD,CAAE,GAAG,KAAK,CAAC;QACjD,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC,IAAI,GAAG,IAAK,AAAD,CAAE,GAAG,IAAI,aAAA,EAAe,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;IACtE,CAAC;IACD,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AACrB,CAAC;AACD,MAAM,CAAC,WAAW,EAAE,WAAW,CAAC,GAAG,aAAA,EAAe,qMAAC,QAAA,AAAK,EAAC,UAAU,EAAE,IAAI,CAAC,CAAC;AAE3E,oCAAoC;AACpC,MAAM,KAAK,GAAG,CAAC,CAAS,EAAE,CAAS,EAAE,CAAS,EAAE,CAAI,CAAF,AAAG,CAAF,EAAK,EAAE,CAAC,CAAC,CAAC,6MAAA,AAAM,EAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,qMAAC,SAAM,AAAN,EAAO,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;AAChG,MAAM,KAAK,GAAG,CAAC,CAAS,EAAE,CAAS,EAAE,CAAS,EAAE,CAAI,CAAF,AAAG,CAAF,EAAK,EAAE,CAAC,CAAC,qMAAC,SAAA,AAAM,EAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,6MAAA,AAAM,EAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;AAG1F,SAAU,OAAO,CAAC,CAAc;iBAAE,iEAAiB,EAAE;IACzD,MAAM,CAAC,GAAG,IAAI,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IACjC,8FAA8F;IAC9F,IAAK,IAAI,KAAK,GAAG,EAAE,GAAG,MAAM,EAAE,KAAK,GAAG,EAAE,EAAE,KAAK,EAAE,CAAE,CAAC;QAClD,UAAU;QACV,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,CAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;QACzF,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,CAAE,CAAC;YAC/B,MAAM,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;YAC1B,MAAM,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;YAC1B,MAAM,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;YACnB,MAAM,EAAE,GAAG,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;YACvB,MAAM,EAAE,GAAG,KAAK,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;YACtC,MAAM,EAAE,GAAG,KAAK,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;YAC1C,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,EAAE,CAAE,CAAC;gBAChC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC;gBACf,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC;YACrB,CAAC;QACH,CAAC;QACD,qBAAqB;QACrB,IAAI,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QAChB,IAAI,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QAChB,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,CAAE,CAAC;YAC5B,MAAM,KAAK,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;YAC3B,MAAM,EAAE,GAAG,KAAK,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;YACpC,MAAM,EAAE,GAAG,KAAK,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;YACpC,MAAM,EAAE,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;YACtB,IAAI,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;YACb,IAAI,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;YACjB,CAAC,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC;YACX,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;QACjB,CAAC;QACD,UAAU;QACV,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,EAAE,CAAE,CAAC;YAChC,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,CAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YAC7C,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,CAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;QAC9E,CAAC;QACD,WAAW;QACX,CAAC,CAAC,CAAC,CAAC,IAAI,WAAW,CAAC,KAAK,CAAC,CAAC;QAC3B,CAAC,CAAC,CAAC,CAAC,IAAI,WAAW,CAAC,KAAK,CAAC,CAAC;IAC7B,CAAC;IACD,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AACZ,CAAC;AAGK,MAAO,MAAO,0MAAQ,OAAY;IAyB5B,MAAM,GAAA;QACd,IAAI,kMAAC,OAAI,uMAAE,aAAA,AAAU,EAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACpC,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;QACnC,IAAI,kMAAC,OAAI,uMAAE,aAAA,AAAU,EAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACpC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;QAChB,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC;IACf,CAAC;IACD,MAAM,CAAC,IAAW,EAAA;+MAChB,UAAA,AAAO,EAAC,IAAI,CAAC,CAAC;QACd,MAAM,EAAE,QAAQ,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC;QACjC,IAAI,wMAAG,UAAA,AAAO,EAAC,IAAI,CAAC,CAAC;QACrB,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;QACxB,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,GAAG,EAAI,CAAC;YAC9B,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,GAAG,GAAG,CAAC,CAAC;YACtD,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,CAAE,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC;YAChE,IAAI,IAAI,CAAC,GAAG,KAAK,QAAQ,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC;QAC3C,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IACS,MAAM,GAAA;QACd,IAAI,IAAI,CAAC,QAAQ,EAAE,OAAO;QAC1B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;QAC9C,iBAAiB;QACjB,KAAK,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC;QACrB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,KAAK,QAAQ,GAAG,CAAC,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC;QACjE,KAAK,CAAC,QAAQ,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC;QAC5B,IAAI,CAAC,MAAM,EAAE,CAAC;IAChB,CAAC;IACS,SAAS,CAAC,GAAe,EAAA;+MACjC,UAAA,AAAO,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QACrB,gNAAA,AAAM,EAAC,GAAG,CAAC,CAAC;QACZ,IAAI,CAAC,MAAM,EAAE,CAAC;QACd,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC;QAC7B,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;QAC1B,IAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,GAAG,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAI,CAAC;YAChD,IAAI,IAAI,CAAC,MAAM,IAAI,QAAQ,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC;YAC3C,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,CAAC,CAAC;YACzD,GAAG,CAAC,GAAG,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;YAClE,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC;YACpB,GAAG,IAAI,IAAI,CAAC;QACd,CAAC;QACD,OAAO,GAAG,CAAC;IACb,CAAC;IACD,OAAO,CAAC,GAAe,EAAA;QACrB,kFAAkF;QAClF,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;QAC9E,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;IAC7B,CAAC;IACD,GAAG,CAAC,KAAa,EAAA;YACf,6MAAA,AAAO,EAAC,KAAK,CAAC,CAAC;QACf,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;IAC7C,CAAC;IACD,UAAU,CAAC,GAAe,EAAA;+MACxB,UAAA,AAAO,EAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QACnB,IAAI,IAAI,CAAC,QAAQ,EAAE,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;QAClE,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;QACpB,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,OAAO,GAAG,CAAC;IACb,CAAC;IACD,MAAM,GAAA;QACJ,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;IACzD,CAAC;IACD,OAAO,GAAA;QACL,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QACtB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACrB,CAAC;IACD,UAAU,CAAC,EAAW,EAAA;QACpB,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC;QAChE,EAAE,IAAA,CAAF,EAAE,GAAK,IAAI,MAAM,CAAC,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,MAAM,CAAC,EAAC;QAClE,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAC7B,EAAE,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;QAClB,EAAE,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QACxB,EAAE,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC5B,EAAE,CAAC,MAAM,GAAG,MAAM,CAAC;QACnB,8BAA8B;QAC9B,EAAE,CAAC,MAAM,GAAG,MAAM,CAAC;QACnB,EAAE,CAAC,SAAS,GAAG,SAAS,CAAC;QACzB,EAAE,CAAC,SAAS,GAAG,SAAS,CAAC;QACzB,EAAE,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;QAC9B,OAAO,EAAE,CAAC;IACZ,CAAC;IAnGD,2DAA2D;IAC3D,YACS,QAAgB,EAChB,MAAc,EACd,SAAiB,EACd,YAAY,KAAK,EACjB,SAAiB,EAAE,CAAA;QAE7B,KAAK,EAAE,CAAC;QAND,IAAA,CAAA,QAAQ,GAAR,QAAQ,CAAQ;QAChB,IAAA,CAAA,MAAM,GAAN,MAAM,CAAQ;QACd,IAAA,CAAA,SAAS,GAAT,SAAS,CAAQ;QACd,IAAA,CAAA,SAAS,GAAT,SAAS,CAAQ;QACjB,IAAA,CAAA,MAAM,GAAN,MAAM,CAAa;QAXrB,IAAA,CAAA,GAAG,GAAG,CAAC,CAAC;QACR,IAAA,CAAA,MAAM,GAAG,CAAC,CAAC;QACX,IAAA,CAAA,QAAQ,GAAG,KAAK,CAAC;QAEjB,IAAA,CAAA,SAAS,GAAG,KAAK,CAAC;QAU1B,mCAAmC;+MACnC,UAAA,AAAO,EAAC,SAAS,CAAC,CAAC;QACnB,uDAAuD;QACvD,qBAAqB;QACrB,IAAI,CAAC,IAAI,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,IAAI,GAAG,EAC5C,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;QAC9D,IAAI,CAAC,KAAK,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC;QACjC,IAAI,CAAC,OAAO,uMAAG,OAAA,AAAG,EAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACjC,CAAC;CAmFF;AAED,MAAM,GAAG,GAAG,CAAC,MAAc,EAAE,QAAgB,EAAE,SAAiB,EAAE,EAAE,oMAClE,kBAAA,AAAe,EAAC,GAAG,CAAG,CAAD,GAAK,MAAM,CAAC,QAAQ,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC,CAAC;AAG1D,MAAM,QAAQ,GAAU,aAAA,EAAe,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;AAEhE,MAAM,QAAQ,GAAU,aAAA,EAAe,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;AAEhE,MAAM,QAAQ,GAAU,aAAA,EAAe,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;AAEhE,MAAM,QAAQ,GAAU,aAAA,EAAe,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;AAG/D,MAAM,UAAU,GAAU,aAAA,EAAe,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;AAElE,MAAM,UAAU,GAAU,aAAA,EAAe,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;AAElE,MAAM,UAAU,GAAU,aAAA,EAAe,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;AAElE,MAAM,UAAU,GAAU,aAAA,EAAe,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;AAIxE,MAAM,QAAQ,GAAG,CAAC,MAAc,EAAE,QAAgB,EAAE,SAAiB,EAAE,EAAE,oMACvE,6BAAA,AAA0B,EACxB;YAAC,wEAAkB,CAAA,CAAE,EAAE,EAAE;eACvB,IAAI,MAAM,CAAC,QAAQ,EAAE,MAAM,EAAE,IAAI,CAAC,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,CACxF,CAAC;;AAGG,MAAM,QAAQ,GAAY,aAAA,EAAe,CAAC,QAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;AAEvE,MAAM,QAAQ,GAAY,aAAA,EAAe,CAAC,QAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC","debugId":null}},
    {"offset": {"line": 1206, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/hash/keccak256.js","sourceRoot":"","sources":["../../../utils/hash/keccak256.ts"],"sourcesContent":[],"names":[],"mappings":";;;AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,oBAAoB,CAAA;AAI/C,OAAO,EAAuB,KAAK,EAAE,MAAM,kBAAkB,CAAA;AAC7D,OAAO,EAAyB,OAAO,EAAE,MAAM,wBAAwB,CAAA;AACvE,OAAO,EAAuB,KAAK,EAAE,MAAM,sBAAsB,CAAA;;;;;AAc3D,SAAU,SAAS,CACvB,KAAsB,EACtB,GAAoB;IAEpB,MAAM,EAAE,GAAG,GAAG,IAAI,KAAK,CAAA;IACvB,MAAM,KAAK,uMAAG,aAAA,AAAU,4MACtB,QAAA,AAAK,EAAC,KAAK,EAAE;QAAE,MAAM,EAAE,KAAK;IAAA,CAAE,CAAC,CAAC,CAAC,iNAAC,UAAA,AAAO,EAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CACzD,CAAA;IACD,IAAI,EAAE,KAAK,OAAO,EAAE,OAAO,KAA0B,CAAA;IACrD,qNAAO,QAAA,AAAK,EAAC,KAAK,CAAsB,CAAA;AAC1C,CAAC","debugId":null}},
    {"offset": {"line": 1229, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/lru.js","sourceRoot":"","sources":["../../utils/lru.ts"],"sourcesContent":[],"names":[],"mappings":"AAAA;;;;GAIG;;;AACG,MAAO,MAAwB,SAAQ,GAAkB;IAQpD,GAAG,CAAC,GAAW,EAAA;QACtB,MAAM,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;QAE5B,IAAI,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;YAC1C,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;YAChB,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;QACvB,CAAC;QAED,OAAO,KAAK,CAAA;IACd,CAAC;IAEQ,GAAG,CAAC,GAAW,EAAE,KAAY,EAAA;QACpC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;QACrB,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;YAC7C,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,KAAK,CAAA;YACzC,IAAI,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA;QACrC,CAAC;QACD,OAAO,IAAI,CAAA;IACb,CAAC;IAvBD,YAAY,IAAY,CAAA;QACtB,KAAK,EAAE,CAAA;QAHT,OAAA,cAAA,CAAA,IAAA,EAAA,WAAA;;;;;WAAe;QAIb,IAAI,CAAC,OAAO,GAAG,IAAI,CAAA;IACrB,CAAC;CAqBF","debugId":null}},
    {"offset": {"line": 1268, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/address/isAddress.js","sourceRoot":"","sources":["../../../utils/address/isAddress.ts"],"sourcesContent":[],"names":[],"mappings":";;;;AAEA,OAAO,EAAE,MAAM,EAAE,MAAM,WAAW,CAAA;AAClC,OAAO,EAAE,eAAe,EAAE,MAAM,iBAAiB,CAAA;;;AAEjD,MAAM,YAAY,GAAG,qBAAqB,CAAA;AAGnC,MAAM,cAAc,GAAG,WAAA,EAAa,CAAC,gMAAI,SAAM,CAAU,IAAI,CAAC,CAAA;AAa/D,SAAU,SAAS,CACvB,OAAe,EACf,OAAsC;IAEtC,MAAM,EAAE,MAAM,GAAG,IAAI,EAAE,4CAAG,OAAO,GAAI,CAAA,CAAE,CAAA;IACvC,MAAM,QAAQ,GAAG,UAAG,OAAO,EAAA,KAAU,CAAE,CAAA,KAAR,MAAM;IAErC,IAAI,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,OAAO,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAE,CAAA;IAEtE,MAAM,MAAM,GAAG,CAAC,GAAG,EAAE;QACnB,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,OAAO,KAAK,CAAA;QAC7C,IAAI,OAAO,CAAC,WAAW,EAAE,KAAK,OAAO,EAAE,OAAO,IAAI,CAAA;QAClD,IAAI,MAAM,EAAE,yNAAO,kBAAe,AAAf,EAAgB,OAAkB,CAAC,KAAK,OAAO,CAAA;QAClE,OAAO,IAAI,CAAA;IACb,CAAC,CAAC,EAAE,CAAA;IACJ,cAAc,CAAC,GAAG,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAA;IACpC,OAAO,MAAM,CAAA;AACf,CAAC","debugId":null}},
    {"offset": {"line": 1295, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/address/getAddress.js","sourceRoot":"","sources":["../../../utils/address/getAddress.ts"],"sourcesContent":[],"names":[],"mappings":";;;;AAEA,OAAO,EAAE,mBAAmB,EAAE,MAAM,yBAAyB,CAAA;AAE7D,OAAO,EAEL,aAAa,GACd,MAAM,wBAAwB,CAAA;AAC/B,OAAO,EAA2B,SAAS,EAAE,MAAM,sBAAsB,CAAA;AACzE,OAAO,EAAE,MAAM,EAAE,MAAM,WAAW,CAAA;AAClC,OAAO,EAA2B,SAAS,EAAE,MAAM,gBAAgB,CAAA;;;;;;AAEnE,MAAM,oBAAoB,GAAG,WAAA,EAAa,CAAC,gMAAI,SAAM,CAAU,IAAI,CAAC,CAAA;AAO9D,SAAU,eAAe,CAC7B,QAAiB,EACjB;;;;;;;;;GASG,CACH,OAA4B;IAE5B,IAAI,oBAAoB,CAAC,GAAG,CAAC,UAAG,QAAQ,EAAA,KAAW,CAAE,CAAC,KAAV,OAAO,IACjD,OAAO,oBAAoB,CAAC,GAAG,CAAC,GAAe,OAAZ,AAAmB,QAAX,EAAA,KAAW,CAAE,CAAE,CAAA;IAE5D,MAAM,UAAU,GAAG,OAAO,GACtB,UAAG,OAAO,EAAyB,CAAE,MAAxB,QAAQ,CAAC,WAAW,EAAE,IACnC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAA;IACvC,MAAM,IAAI,IAAG,yNAAA,AAAS,kNAAC,gBAAA,AAAa,EAAC,UAAU,CAAC,EAAE,OAAO,CAAC,CAAA;IAE1D,MAAM,OAAO,GAAG,CACd,OAAO,CAAC,CAAC,CAAC,UAAU,CAAC,SAAS,CAAC,GAAU,GAAI,IAAX,OAAO,EAAA,MAAK,MAAM,CAAC,CAAC,CAAC,CAAC,UAAU,CACnE,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;IACX,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,CAAE,CAAC;QAC/B,IAAI,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC;YACzC,OAAO,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAA;QACvC,CAAC;QACD,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC;YACjD,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,WAAW,EAAE,CAAA;QAC/C,CAAC;IACH,CAAC;IAED,MAAM,MAAM,GAAG,KAAqB,CAAW,CAAA,KAA3B,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC;IACpC,oBAAoB,CAAC,GAAG,CAAC,UAAG,QAAQ,EAAA,KAAW,CAAE,MAAT,OAAO,GAAI,MAAM,CAAC,CAAA;IAC1D,OAAO,MAAM,CAAA;AACf,CAAC;AAOK,SAAU,UAAU,CACxB,OAAe,EACf;;;;;;;;;GASG,CACH,OAAgB;IAEhB,IAAI,kNAAC,YAAA,AAAS,EAAC,OAAO,EAAE;QAAE,MAAM,EAAE,KAAK;IAAA,CAAE,CAAC,EACxC,MAAM,qMAAI,sBAAmB,CAAC;QAAE,OAAO;IAAA,CAAE,CAAC,CAAA;IAC5C,OAAO,eAAe,CAAC,OAAO,EAAE,OAAO,CAAC,CAAA;AAC1C,CAAC","debugId":null}},
    {"offset": {"line": 1357, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js","sourceRoot":"","sources":["../../../accounts/utils/publicKeyToAddress.ts"],"sourcesContent":[],"names":[],"mappings":";;;AAIA,OAAO,EAEL,eAAe,GAChB,MAAM,mCAAmC,CAAA;AAC1C,OAAO,EAEL,SAAS,GACV,MAAM,+BAA+B,CAAA;;;AAchC,SAAU,kBAAkB,CAAC,SAAc;IAC/C,MAAM,OAAO,iNAAG,YAAA,AAAS,EAAC,KAA2B,CAAE,CAAC,KAAzB,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,GAAI,SAAS,CAAC,EAAE,CAAC,CAAA;IACtE,yNAAO,kBAAA,AAAe,EAAC,KAAY,CAAE,CAAY,CAAA,IAArB,OAAO;AACrC,CAAC","debugId":null}},
    {"offset": {"line": 1372, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverPublicKey.js","sourceRoot":"","sources":["../../../utils/signature/recoverPublicKey.ts"],"sourcesContent":[],"names":[],"mappings":";;;AAEA,OAAO,EAAuB,KAAK,EAAE,MAAM,kBAAkB,CAAA;AAC7D,OAAO,EAEL,WAAW,EACX,WAAW,GACZ,MAAM,wBAAwB,CAAA;AAC/B,OAAO,EAAE,KAAK,EAAE,MAAM,sBAAsB,CAAA;;;;AAcrC,KAAK,UAAU,gBAAgB;UACpC,IAAI,EACJ,SAAS,EACkB,GAHU;IAIrC,MAAM,OAAO,6MAAG,QAAA,AAAK,EAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,+MAAC,QAAK,AAAL,EAAM,IAAI,CAAC,CAAA;IAEhD,MAAM,EAAE,SAAS,EAAE,GAAG,MAAM,MAAM,CAAC,yBAAyB,CAAC,CAAA;IAC7D,MAAM,UAAU,GAAG,CAAC,GAAG,EAAE;QACvB,gCAAgC;QAChC,IAAI,OAAO,SAAS,KAAK,QAAQ,IAAI,GAAG,IAAI,SAAS,IAAI,GAAG,IAAI,SAAS,EAAE,CAAC;YAC1E,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,OAAO,EAAE,GAAG,SAAS,CAAA;YACtC,MAAM,UAAU,GAAG,MAAM,0CAAC,OAAO,GAAI,CAAC,CAAE,CAAA;YACxC,MAAM,WAAW,GAAG,aAAa,CAAC,UAAU,CAAC,CAAA;YAC7C,OAAO,IAAI,SAAS,CAAC,SAAS,CAC5B,8NAAW,AAAX,EAAY,CAAC,CAAC,kNACd,cAAA,AAAW,EAAC,CAAC,CAAC,CACf,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QAC/B,CAAC;QAED,sCAAsC;QACtC,MAAM,YAAY,6MAAG,QAAA,AAAK,EAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,+MAAC,QAAK,AAAL,EAAM,SAAS,CAAC,CAAA;QACpE,MAAM,UAAU,mNAAG,cAAA,AAAW,EAAC,KAA4B,CAAE,CAAC,CAAA,IAA1B,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC;QAC3D,MAAM,WAAW,GAAG,aAAa,CAAC,UAAU,CAAC,CAAA;QAC7C,OAAO,SAAS,CAAC,SAAS,CAAC,WAAW,CACpC,YAAY,CAAC,SAAS,CAAC,CAAC,EAAE,GAAG,CAAC,CAC/B,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;IAC/B,CAAC,CAAC,EAAE,CAAA;IAEJ,MAAM,SAAS,GAAG,UAAU,CACzB,gBAAgB,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CACtC,KAAK,CAAC,KAAK,CAAC,CAAA;IACf,OAAO,KAAc,CAAE,CAAA,KAAX,SAAS;AACvB,CAAC;AAED,SAAS,aAAa,CAAC,UAAkB;IACvC,IAAI,UAAU,KAAK,CAAC,IAAI,UAAU,KAAK,CAAC,EAAE,OAAO,UAAU,CAAA;IAC3D,IAAI,UAAU,KAAK,EAAE,EAAE,OAAO,CAAC,CAAA;IAC/B,IAAI,UAAU,KAAK,EAAE,EAAE,OAAO,CAAC,CAAA;IAC/B,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAA;AAC7C,CAAC","debugId":null}},
    {"offset": {"line": 1412, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverAddress.js","sourceRoot":"","sources":["../../../utils/signature/recoverAddress.ts"],"sourcesContent":[],"names":[],"mappings":";;;AAEA,OAAO,EAAE,kBAAkB,EAAE,MAAM,4CAA4C,CAAA;AAI/E,OAAO,EAAE,gBAAgB,EAAE,MAAM,uBAAuB,CAAA;;;AAWjD,KAAK,UAAU,cAAc;UAClC,IAAI,EACJ,SAAS,EACgB,GAHU;IAInC,kOAAO,qBAAA,AAAkB,EAAC,gOAAM,mBAAA,AAAgB,EAAC;QAAE,IAAI,EAAE,IAAI;QAAE,SAAS;IAAA,CAAE,CAAC,CAAC,CAAA;AAC9E,CAAC","debugId":null}},
    {"offset": {"line": 1430, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/utils/node_modules/base-x/src/esm/index.js"],"sourcesContent":["// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  const BASE_MAP = new Uint8Array(256)\n  for (let j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (let i = 0; i < ALPHABET.length; i++) {\n    const x = ALPHABET.charAt(i)\n    const xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  const BASE = ALPHABET.length\n  const LEADER = ALPHABET.charAt(0)\n  const FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  const iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    // eslint-disable-next-line no-empty\n    if (source instanceof Uint8Array) { } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n    // Skip & count leading zeroes.\n    let zeroes = 0\n    let length = 0\n    let pbegin = 0\n    const pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n    // Allocate enough space in big-endian base58 representation.\n    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    const b58 = new Uint8Array(size)\n    // Process the bytes.\n    while (pbegin !== pend) {\n      let carry = source[pbegin]\n      // Apply \"b58 = b58 * 256 + ch\".\n      let i = 0\n      for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n    // Skip leading zeroes in base58 result.\n    let it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    let psz = 0\n    // Skip and count leading '1's.\n    let zeroes = 0\n    let length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n    // Allocate enough space in big-endian base256 representation.\n    const size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    const b256 = new Uint8Array(size)\n    // Process the characters.\n    while (psz < source.length) {\n      // Find code of next character\n      const charCode = source.charCodeAt(psz)\n      // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n      // Decode character\n      let carry = BASE_MAP[charCode]\n      // Invalid character\n      if (carry === 255) { return }\n      let i = 0\n      for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n    // Skip leading zeroes in b256.\n    let it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    const vch = new Uint8Array(zeroes + (size - it4))\n    let j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    const buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode,\n    decodeUnsafe,\n    decode\n  }\n}\nexport default base\n"],"names":[],"mappings":"AAAA,6BAA6B;AAC7B,yCAAyC;AACzC,mEAAmE;AACnE,mEAAmE;AACnE,sEAAsE;;;;AACtE,SAAS,KAAM,QAAQ;IACrB,IAAI,SAAS,MAAM,IAAI,KAAK;QAAE,MAAM,IAAI,UAAU;IAAqB;IACvE,MAAM,WAAW,IAAI,WAAW;IAChC,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,IAAK;QACxC,QAAQ,CAAC,EAAE,GAAG;IAChB;IACA,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,IAAK;QACxC,MAAM,IAAI,SAAS,MAAM,CAAC;QAC1B,MAAM,KAAK,EAAE,UAAU,CAAC;QACxB,IAAI,QAAQ,CAAC,GAAG,KAAK,KAAK;YAAE,MAAM,IAAI,UAAU,IAAI;QAAiB;QACrE,QAAQ,CAAC,GAAG,GAAG;IACjB;IACA,MAAM,OAAO,SAAS,MAAM;IAC5B,MAAM,SAAS,SAAS,MAAM,CAAC;IAC/B,MAAM,SAAS,KAAK,GAAG,CAAC,QAAQ,KAAK,GAAG,CAAC,KAAK,mCAAmC;;IACjF,MAAM,UAAU,KAAK,GAAG,CAAC,OAAO,KAAK,GAAG,CAAC,MAAM,mCAAmC;;IAClF,SAAS,OAAQ,MAAM;QACrB,oCAAoC;QACpC,IAAI,kBAAkB,YAAY,CAAE,OAAO,IAAI,YAAY,MAAM,CAAC,SAAS;YACzE,SAAS,IAAI,WAAW,OAAO,MAAM,EAAE,OAAO,UAAU,EAAE,OAAO,UAAU;QAC7E,OAAO,IAAI,MAAM,OAAO,CAAC,SAAS;YAChC,SAAS,WAAW,IAAI,CAAC;QAC3B;QACA,IAAI,CAAC,CAAC,kBAAkB,UAAU,GAAG;YAAE,MAAM,IAAI,UAAU;QAAuB;QAClF,IAAI,OAAO,MAAM,KAAK,GAAG;YAAE,OAAO;QAAG;QACrC,+BAA+B;QAC/B,IAAI,SAAS;QACb,IAAI,SAAS;QACb,IAAI,SAAS;QACb,MAAM,OAAO,OAAO,MAAM;QAC1B,MAAO,WAAW,QAAQ,MAAM,CAAC,OAAO,KAAK,EAAG;YAC9C;YACA;QACF;QACA,6DAA6D;QAC7D,MAAM,OAAO,AAAC,CAAC,OAAO,MAAM,IAAI,UAAU,MAAO;QACjD,MAAM,MAAM,IAAI,WAAW;QAC3B,qBAAqB;QACrB,MAAO,WAAW,KAAM;YACtB,IAAI,QAAQ,MAAM,CAAC,OAAO;YAC1B,gCAAgC;YAChC,IAAI,IAAI;YACR,IAAK,IAAI,MAAM,OAAO,GAAG,CAAC,UAAU,KAAK,IAAI,MAAM,KAAM,QAAQ,CAAC,GAAI,OAAO,IAAK;gBAChF,SAAS,AAAC,MAAM,GAAG,CAAC,IAAI,KAAM;gBAC9B,GAAG,CAAC,IAAI,GAAG,AAAC,QAAQ,SAAU;gBAC9B,QAAQ,AAAC,QAAQ,SAAU;YAC7B;YACA,IAAI,UAAU,GAAG;gBAAE,MAAM,IAAI,MAAM;YAAkB;YACrD,SAAS;YACT;QACF;QACA,wCAAwC;QACxC,IAAI,MAAM,OAAO;QACjB,MAAO,QAAQ,QAAQ,GAAG,CAAC,IAAI,KAAK,EAAG;YACrC;QACF;QACA,sCAAsC;QACtC,IAAI,MAAM,OAAO,MAAM,CAAC;QACxB,MAAO,MAAM,MAAM,EAAE,IAAK;YAAE,OAAO,SAAS,MAAM,CAAC,GAAG,CAAC,IAAI;QAAE;QAC7D,OAAO;IACT;IACA,SAAS,aAAc,MAAM;QAC3B,IAAI,OAAO,WAAW,UAAU;YAAE,MAAM,IAAI,UAAU;QAAmB;QACzE,IAAI,OAAO,MAAM,KAAK,GAAG;YAAE,OAAO,IAAI;QAAa;QACnD,IAAI,MAAM;QACV,+BAA+B;QAC/B,IAAI,SAAS;QACb,IAAI,SAAS;QACb,MAAO,MAAM,CAAC,IAAI,KAAK,OAAQ;YAC7B;YACA;QACF;QACA,8DAA8D;QAC9D,MAAM,OAAO,AAAE,CAAC,OAAO,MAAM,GAAG,GAAG,IAAI,SAAU,MAAO,EAAE,kCAAkC;;QAC5F,MAAM,OAAO,IAAI,WAAW;QAC5B,0BAA0B;QAC1B,MAAO,MAAM,OAAO,MAAM,CAAE;YAC1B,8BAA8B;YAC9B,MAAM,WAAW,OAAO,UAAU,CAAC;YACnC,8CAA8C;YAC9C,IAAI,WAAW,KAAK;gBAAE;YAAO;YAC7B,mBAAmB;YACnB,IAAI,QAAQ,QAAQ,CAAC,SAAS;YAC9B,oBAAoB;YACpB,IAAI,UAAU,KAAK;gBAAE;YAAO;YAC5B,IAAI,IAAI;YACR,IAAK,IAAI,MAAM,OAAO,GAAG,CAAC,UAAU,KAAK,IAAI,MAAM,KAAM,QAAQ,CAAC,GAAI,OAAO,IAAK;gBAChF,SAAS,AAAC,OAAO,IAAI,CAAC,IAAI,KAAM;gBAChC,IAAI,CAAC,IAAI,GAAG,AAAC,QAAQ,QAAS;gBAC9B,QAAQ,AAAC,QAAQ,QAAS;YAC5B;YACA,IAAI,UAAU,GAAG;gBAAE,MAAM,IAAI,MAAM;YAAkB;YACrD,SAAS;YACT;QACF;QACA,+BAA+B;QAC/B,IAAI,MAAM,OAAO;QACjB,MAAO,QAAQ,QAAQ,IAAI,CAAC,IAAI,KAAK,EAAG;YACtC;QACF;QACA,MAAM,MAAM,IAAI,WAAW,SAAS,CAAC,OAAO,GAAG;QAC/C,IAAI,IAAI;QACR,MAAO,QAAQ,KAAM;YACnB,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,MAAM;QACxB;QACA,OAAO;IACT;IACA,SAAS,OAAQ,MAAM;QACrB,MAAM,SAAS,aAAa;QAC5B,IAAI,QAAQ;YAAE,OAAO;QAAO;QAC5B,MAAM,IAAI,MAAM,aAAa,OAAO;IACtC;IACA,OAAO;QACL;QACA;QACA;IACF;AACF;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1588, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/utils/node_modules/bs58/src/esm/index.js"],"sourcesContent":["import basex from 'base-x';\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nexport default basex(ALPHABET);\n"],"names":[],"mappings":";;;AAAA;;AACA,IAAI,WAAW;uCACA,CAAA,GAAA,+LAAA,CAAA,UAAK,AAAD,EAAE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1599, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/relay-auth/dist/index.es.js","sources":["file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/hashes/esm/_assert.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/hashes/esm/crypto.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/hashes/esm/utils.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/hashes/esm/_md.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/hashes/esm/_u64.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/hashes/esm/sha512.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/curves/esm/abstract/utils.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/curves/esm/abstract/modular.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/curves/esm/abstract/curve.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/curves/esm/abstract/edwards.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/curves/esm/abstract/montgomery.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/curves/esm/ed25519.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/relay-auth/src/constants.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/uint8arrays/esm/src/util/as-uint8array.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/uint8arrays/esm/src/alloc.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/uint8arrays/esm/src/concat.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/vendor/base-x.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bytes.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/identity.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base2.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base8.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base10.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base16.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base32.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base36.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base58.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base64.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base256emoji.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/vendor/varint.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/varint.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/hashes/digest.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/hashes/hasher.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/hashes/sha2-browser.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/hashes/identity.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/codecs/json.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/basics.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/uint8arrays/esm/src/util/bases.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/uint8arrays/esm/src/to-string.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/uint8arrays/esm/src/from-string.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/relay-auth/src/utils.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/relay-auth/src/api.ts"],"sourcesContent":["/**\n * Assertion helpers\n * @module\n */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n// copied from utils\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\nexport { anumber, abytes, ahash, aexists, aoutput };\n//# sourceMappingURL=_assert.js.map","export const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n/** The rotate right (circular right shift) operation for uint32 */\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n/** The rotate left (circular left shift) operation for uint32 */\nexport const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nexport const byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n/** Conditionally byte swap if on a big-endian platform */\nexport const byteSwapIfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Convert JS string to byte array.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('utf8ToBytes expected string, got ' + typeof str);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","import { aexists, aoutput } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n/**\n * Merkle-Damgard hash utils.\n * @module\n */\n/**\n * Polyfill for Safari 14\n */\nexport function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/**\n * Choice: a ? b : c\n */\nexport const Chi = (a, b, c) => (a & b) ^ (~a & c);\n/**\n * Majority function, true if any two inputs is true\n */\nexport const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n/**\n * BigUint64Array is too slow as per 2024, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","import { HashMD } from './_md.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n/**\n * SHA2-512 a.k.a. sha512 and sha384. It is slower than sha256 in js because u64 operations are slow.\n *\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [the paper on truncated SHA512/256](https://eprint.iacr.org/2010/548.pdf).\n * @module\n */\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends HashMD {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexport class SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nexport class SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nexport class SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\n/** SHA2-512 hash function. */\nexport const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());\n/** SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks. */\nexport const sha512_224 = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\n/** SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks. */\nexport const sha512_256 = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\n/** SHA2-384 hash function. */\nexport const sha384 = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n//# sourceMappingURL=sha512.js.map","/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nexport function abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\nexport function abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexport function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nexport function inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */\nexport const notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map","/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitMask, bytesToNumberBE, bytesToNumberLE, ensureBytes, numberToBytesBE, numberToBytesLE, validateObject, } from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// prettier-ignore\nconst _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @todo use field version && remove\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num, power, modulo) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (modulo <= _0n)\n        throw new Error('invalid modulus');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++) {\n        // Crash instead of infinity loop, we cannot reasonable count until P.\n        if (Z > 1000)\n            throw new Error('Cannot find square root: likely non-prime P');\n    }\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\n/**\n * Square root for a finite field. It will try to check if optimizations are applicable and fall back to 4:\n *\n * 1. P ≡ 3 (mod 4)\n * 2. P ≡ 5 (mod 8)\n * 3. P ≡ 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P) {\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return validateObject(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nexport function FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n/**\n * Legendre symbol.\n * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ≡ 0    if a ≡ 0 (mod p)\n */\nexport function FpLegendre(order) {\n    const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n    return (f, x) => f.pow(x, legendreConst);\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(f) {\n    const legendre = FpLegendre(f.ORDER);\n    return (x) => {\n        const p = legendre(f, x);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = ensureBytes('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { validateField, nLength } from './modular.js';\nimport { validateObject, bitLen } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, bits) {\n    validateW(W, bits);\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return { windows, windowSize };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport function wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes(elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n, p = c.ZERO) {\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = calcWOpts(W, bits);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */\n        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                if (n === _0n)\n                    break; // No need to go over empty scalar\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                if (wbits === 0)\n                    continue;\n                let curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero\n                if (wbits < 0)\n                    curr = curr.negate();\n                // NOTE: by re-using acc, we can save a lot of additions in case of MSM\n                acc = acc.add(curr);\n            }\n            return acc;\n        },\n        getPrecomputes(W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1)\n                    pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached(P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe(P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1)\n                return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize(P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        },\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nexport function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    if (points.length !== scalars.length)\n        throw new Error('arrays of points and scalars must have equal length');\n    const zero = c.ZERO;\n    const wbits = bitLen(BigInt(points.length));\n    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n    const MASK = (1 << windowSize) - 1;\n    const buckets = new Array(MASK + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < scalars.length; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & BigInt(MASK));\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar × 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 × 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 × 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = BigInt((1 << windowSize) - 1);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nexport function validateBasic(curve) {\n    validateField(curve.Fp);\n    validateObject(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...nLength(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map","/**\n * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².\n * For design rationale of types / exports, see weierstrass module documentation.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { validateBasic, wNAF, pippenger, } from './curve.js';\nimport { mod, Field } from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes, memoized, abool } from './utils.js';\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(curve, {\n        hash: 'function',\n        a: 'bigint',\n        d: 'bigint',\n        randomBytes: 'function',\n    }, {\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        uvRatio: 'function',\n        mapToCurve: 'function',\n    });\n    // Set defaults\n    return Object.freeze({ ...opts });\n}\n/**\n * Creates Twisted Edwards curve with EdDSA signatures.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, d, p, n, Gx, Gy, h\n * const curve = twistedEdwards({ a, d, Fp: Field(p), n, Gx, Gy, h })\n */\nexport function twistedEdwards(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor, } = CURVE;\n    // Important:\n    // There are some places where Fp.BYTES is used instead of nByteLength.\n    // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n    // TODO: test and find curves which behave otherwise.\n    const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n    const modP = Fp.create; // Function overrides\n    const Fn = Field(CURVE.n, CURVE.nBitLength);\n    // sqrt(u/v)\n    const uvRatio = CURVE.uvRatio ||\n        ((u, v) => {\n            try {\n                return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n            }\n            catch (e) {\n                return { isValid: false, value: _0n };\n            }\n        });\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes); // NOOP\n    const domain = CURVE.domain ||\n        ((data, ctx, phflag) => {\n            abool('phflag', phflag);\n            if (ctx.length || phflag)\n                throw new Error('Contexts/pre-hash are not supported');\n            return data;\n        }); // NOOP\n    // 0 <= n < MASK\n    // Coordinates larger than Fp.ORDER are allowed for zip215\n    function aCoordinate(title, n) {\n        ut.aInRange('coordinate ' + title, n, _0n, MASK);\n    }\n    function assertPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ExtendedPoint expected');\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    const toAffineMemo = memoized((p, iz) => {\n        const { ex: x, ey: y, ez: z } = p;\n        const is0 = p.is0();\n        if (iz == null)\n            iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n        const ax = modP(x * iz);\n        const ay = modP(y * iz);\n        const zz = modP(z * iz);\n        if (is0)\n            return { x: _0n, y: _1n };\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    const assertValidMemo = memoized((p) => {\n        const { a, d } = CURVE;\n        if (p.is0())\n            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n        const { ex: X, ey: Y, ez: Z, et: T } = p;\n        const X2 = modP(X * X); // X²\n        const Y2 = modP(Y * Y); // Y²\n        const Z2 = modP(Z * Z); // Z²\n        const Z4 = modP(Z2 * Z2); // Z⁴\n        const aX2 = modP(X2 * a); // aX²\n        const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n        if (left !== right)\n            throw new Error('bad point: equation left != right (1)');\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        const XY = modP(X * Y);\n        const ZT = modP(Z * T);\n        if (XY !== ZT)\n            throw new Error('bad point: equation left != right (2)');\n        return true;\n    });\n    // Extended Point works in extended coordinates: (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(ex, ey, ez, et) {\n            this.ex = ex;\n            this.ey = ey;\n            this.ez = ez;\n            this.et = et;\n            aCoordinate('x', ex);\n            aCoordinate('y', ey);\n            aCoordinate('z', ez);\n            aCoordinate('t', et);\n            Object.freeze(this);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point)\n                throw new Error('extended point not allowed');\n            const { x, y } = p || {};\n            aCoordinate('x', x);\n            aCoordinate('y', y);\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.ez));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return pippenger(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // Not required for fromHex(), which always creates valid points.\n        // Could be useful for fromAffine().\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        // Compare one point to another.\n        equals(other) {\n            assertPoint(other);\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            assertPoint(other);\n            const { a, d } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n            // Faster algo for adding 2 Extended Points when curve's a=-1.\n            // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n            // Cost: 8M + 8add + 2*2.\n            // Note: It does not check whether the `other` point is valid.\n            if (a === BigInt(-1)) {\n                const A = modP((Y1 - X1) * (Y2 + X2));\n                const B = modP((Y1 + X1) * (Y2 - X2));\n                const F = modP(B - A);\n                if (F === _0n)\n                    return this.double(); // Same point. Tests say it doesn't affect timing\n                const C = modP(Z1 * _2n * T2);\n                const D = modP(T1 * _2n * Z2);\n                const E = D + C;\n                const G = B + A;\n                const H = D - C;\n                const X3 = modP(E * F);\n                const Y3 = modP(G * H);\n                const T3 = modP(E * H);\n                const Z3 = modP(F * G);\n                return new Point(X3, Y3, Z3, T3);\n            }\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            const n = scalar;\n            ut.aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n            const { p, f } = this.wNAF(n);\n            return Point.normalizeZ([p, f])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n        multiplyUnsafe(scalar, acc = Point.ZERO) {\n            const n = scalar;\n            ut.aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n            if (n === _0n)\n                return I;\n            if (this.is0() || n === _1n)\n                return this;\n            return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        clearCofactor() {\n            const { h: cofactor } = CURVE;\n            if (cofactor === _1n)\n                return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        // Converts hash string or Uint8Array to Point.\n        // Uses algo from RFC8032 5.1.3.\n        static fromHex(hex, zip215 = false) {\n            const { d, a } = CURVE;\n            const len = Fp.BYTES;\n            hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n            abool('zip215', zip215);\n            const normed = hex.slice(); // copy again, we'll manipulate it\n            const lastByte = hex[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = ut.bytesToNumberLE(normed);\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // RFC8032 prohibits >= p, but ZIP215 doesn't\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            const max = zip215 ? MASK : Fp.ORDER;\n            ut.aInRange('pointHex.y', y, _0n, max);\n            // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n            // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y² - 1\n            const v = modP(d * y2 - a); // v = d y² + 1.\n            let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n            if (!isValid)\n                throw new Error('Point.fromHex: invalid y coordinate');\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd)\n                // if x=0 and x_0 = 1, fail\n                throw new Error('Point.fromHex: x=0 and x_0=1');\n            if (isLastByteOdd !== isXOdd)\n                x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({ x, y });\n        }\n        static fromPrivateKey(privKey) {\n            return getExtendedPublicKey(privKey).point;\n        }\n        toRawBytes() {\n            const { x, y } = this.toAffine();\n            const bytes = ut.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n            return bytes; // and use the last byte to encode sign of x\n        }\n        toHex() {\n            return ut.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    const { BASE: G, ZERO: I } = Point;\n    const wnaf = wNAF(Point, nByteLength * 8);\n    function modN(a) {\n        return mod(a, CURVE_ORDER);\n    }\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return modN(ut.bytesToNumberLE(hash));\n    }\n    /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n    function getExtendedPublicKey(key) {\n        const len = Fp.BYTES;\n        key = ensureBytes('private key', key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        const point = G.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toRawBytes(); // Uint8Array representation\n        return { head, prefix, scalar, point, pointBytes };\n    }\n    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n    function getPublicKey(privKey) {\n        return getExtendedPublicKey(privKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {\n        const msg = ut.concatBytes(...msgs);\n        return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */\n    function sign(msg, privKey, options = {}) {\n        msg = ensureBytes('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = G.multiply(r).toRawBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = modN(r + k * scalar); // S = (r + k * s) mod L\n        ut.aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n        const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));\n        return ensureBytes('result', res, Fp.BYTES * 2); // 64-byte signature\n    }\n    const verifyOpts = VERIFY_DEFAULT;\n    /**\n     * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n     * An extended group equation is checked.\n     */\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n        sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n        msg = ensureBytes('message', msg);\n        publicKey = ensureBytes('publicKey', publicKey, len);\n        if (zip215 !== undefined)\n            abool('zip215', zip215);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph, etc\n        const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));\n        let A, R, SB;\n        try {\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            A = Point.fromHex(publicKey, zip215);\n            R = Point.fromHex(sig.slice(0, len), zip215);\n            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n        }\n        catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder())\n            return false;\n        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // Extended group equation\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n    }\n    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    const utils = {\n        getExtendedPublicKey,\n        // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n        randomPrivateKey: () => randomBytes(Fp.BYTES),\n        /**\n         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n         * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n         * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n         * @param windowSize 2, 4, 8, 16\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3));\n            return point;\n        },\n    };\n    return {\n        CURVE,\n        getPublicKey,\n        sign,\n        verify,\n        ExtendedPoint: Point,\n        utils,\n    };\n}\n//# sourceMappingURL=edwards.js.map","/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { mod, pow } from './modular.js';\nimport { aInRange, bytesToNumberLE, ensureBytes, numberToBytesLE, validateObject, } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction validateOpts(curve) {\n    validateObject(curve, {\n        a: 'bigint',\n    }, {\n        montgomeryBits: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        powPminus2: 'function',\n        Gu: 'bigint',\n    });\n    // Set defaults\n    return Object.freeze({ ...curve });\n}\n// Uses only one coordinate instead of two\nexport function montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P } = CURVE;\n    const modP = (n) => mod(n, P);\n    const montgomeryBits = CURVE.montgomeryBits;\n    const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n    const fieldLen = CURVE.nByteLength;\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);\n    const powPminus2 = CURVE.powPminus2 || ((x) => pow(x, P - BigInt(2), P));\n    // cswap from RFC7748. But it is not from RFC7748!\n    /*\n      cswap(swap, x_2, x_3):\n           dummy = mask(swap) AND (x_2 XOR x_3)\n           x_2 = x_2 XOR dummy\n           x_3 = x_3 XOR dummy\n           Return (x_2, x_3)\n    Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n     and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    */\n    function cswap(swap, x_2, x_3) {\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy);\n        x_3 = modP(x_3 + dummy);\n        return [x_2, x_3];\n    }\n    // x25519 from 4\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n    const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n    /**\n     *\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */\n    function montgomeryLadder(u, scalar) {\n        aInRange('u', u, _0n, P);\n        aInRange('scalar', scalar, _0n, P);\n        // Section 5: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.\n        const k = scalar;\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        let sw;\n        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n            const k_t = (k >> t) & _1n;\n            swap ^= k_t;\n            sw = cswap(swap, x_2, x_3);\n            x_2 = sw[0];\n            x_3 = sw[1];\n            sw = cswap(swap, z_2, z_3);\n            z_2 = sw[0];\n            z_3 = sw[1];\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        // (x_2, x_3) = cswap(swap, x_2, x_3)\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        // (z_2, z_3) = cswap(swap, z_2, z_3)\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        // z_2^(p - 2)\n        const z2 = powPminus2(z_2);\n        // Return x_2 * (z_2^(p - 2))\n        return modP(x_2 * z2);\n    }\n    function encodeUCoordinate(u) {\n        return numberToBytesLE(modP(u), montgomeryBytes);\n    }\n    function decodeUCoordinate(uEnc) {\n        // Section 5: When receiving such an array, implementations of X25519\n        // MUST mask the most significant bit in the final byte.\n        const u = ensureBytes('u coordinate', uEnc, montgomeryBytes);\n        if (fieldLen === 32)\n            u[31] &= 127; // 0b0111_1111\n        return bytesToNumberLE(u);\n    }\n    function decodeScalar(n) {\n        const bytes = ensureBytes('scalar', n);\n        const len = bytes.length;\n        if (len !== montgomeryBytes && len !== fieldLen) {\n            let valid = '' + montgomeryBytes + ' or ' + fieldLen;\n            throw new Error('invalid scalar, expected ' + valid + ' bytes, got ' + len);\n        }\n        return bytesToNumberLE(adjustScalarBytes(bytes));\n    }\n    function scalarMult(scalar, u) {\n        const pointU = decodeUCoordinate(u);\n        const _scalar = decodeScalar(scalar);\n        const pu = montgomeryLadder(pointU, _scalar);\n        // The result was not contributory\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n)\n            throw new Error('invalid private or public key received');\n        return encodeUCoordinate(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    const GuBytes = encodeUCoordinate(CURVE.Gu);\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    return {\n        scalarMult,\n        scalarMultBase,\n        getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),\n        getPublicKey: (privateKey) => scalarMultBase(privateKey),\n        utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },\n        GuBytes: GuBytes,\n    };\n}\n//# sourceMappingURL=montgomery.js.map","/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha512';\nimport { concatBytes, randomBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { twistedEdwards } from './abstract/edwards.js';\nimport { createHasher, expand_message_xmd, } from './abstract/hash-to-curve.js';\nimport { Field, FpSqrtEven, isNegativeLE, mod, pow2 } from './abstract/modular.js';\nimport { montgomery } from './abstract/montgomery.js';\nimport { pippenger } from './abstract/curve.js';\nimport { bytesToHex, bytesToNumberLE, ensureBytes, equalBytes, numberToBytesLE, } from './abstract/utils.js';\nconst ED25519_P = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949');\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\nfunction ed25519_pow_2_252_3(x) {\n    // prettier-ignore\n    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n    const P = ED25519_P;\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P; // x^3, 11\n    const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n    const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n    const b10 = (pow2(b5, _5n, P) * b5) % P;\n    const b20 = (pow2(b10, _10n, P) * b10) % P;\n    const b40 = (pow2(b20, _20n, P) * b20) % P;\n    const b80 = (pow2(b40, _40n, P) * b40) % P;\n    const b160 = (pow2(b80, _80n, P) * b80) % P;\n    const b240 = (pow2(b160, _80n, P) * b80) % P;\n    const b250 = (pow2(b240, _10n, P) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ED25519_P;\n    const v3 = mod(v * v * v, P); // v³\n    const v7 = mod(v3 * v3 * v, P); // v⁷\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow, P); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = mod(v * x * x, P); // vx²\n    const root1 = x; // First root candidate\n    const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u, P); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx² = -u√(-1)\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if (isNegativeLE(x, P))\n        x = mod(-x, P);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\n// Just in case\nexport const ED25519_TORSION_SUBGROUP = [\n    '0100000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n    '0000000000000000000000000000000000000000000000000000000000000080',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n    '0000000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\nconst Fp = /* @__PURE__ */ (() => Field(ED25519_P, undefined, true))();\nconst ed25519Defaults = /* @__PURE__ */ (() => ({\n    // Param: a\n    a: BigInt(-1), // Fp.create(-1) is proper; our way still works and is faster\n    // d is equal to -121665/121666 over finite field.\n    // Negative number is P - number, and division is invert(number, P)\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n\n    Fp,\n    // Subgroup order: how many points curve has\n    // 2n**252n + 27742317777372353535851937790883648493n;\n    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n    // Cofactor\n    h: _8n,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n    hash: sha512,\n    randomBytes,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/√v\n    uvRatio,\n}))();\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * import { ed25519 } from '@noble/curves/ed25519';\n * const priv = ed25519.utils.randomPrivateKey();\n * const pub = ed25519.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = ed25519.sign(msg, priv);\n * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215\n * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5\n */\nexport const ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255)\n        throw new Error('Context is too big');\n    return concatBytes(utf8ToBytes('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);\n}\nexport const ed25519ctx = /* @__PURE__ */ (() => twistedEdwards({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n}))();\nexport const ed25519ph = /* @__PURE__ */ (() => twistedEdwards(Object.assign({}, ed25519Defaults, {\n    domain: ed25519_domain,\n    prehash: sha512,\n})))();\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * import { x25519 } from '@noble/curves/ed25519';\n * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\n * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\n * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\n * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\n * x25519.getPublicKey(x25519.utils.randomPrivateKey());\n */\nexport const x25519 = /* @__PURE__ */ (() => montgomery({\n    P: ED25519_P,\n    a: BigInt(486662),\n    montgomeryBits: 255, // n is 253 bits\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: (x) => {\n        const P = ED25519_P;\n        // x^(p-2) aka x^(2^255-21)\n        const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n        return mod(pow2(pow_p_5_8, _3n, P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes,\n}))();\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nexport function edwardsToMontgomeryPub(edwardsPub) {\n    const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n    const _1n = BigInt(1);\n    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nexport const edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nexport function edwardsToMontgomeryPriv(edwardsPriv) {\n    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n    const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n    const ELL2_J = BigInt(486662);\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const inv = Fp.invertBatch([xd, yd]); // batch division\n    return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)\n}\nconst htf = /* @__PURE__ */ (() => createHasher(ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {\n    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha512,\n}))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistPoint))\n        throw new Error('RistrettoPoint expected');\n}\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// √(ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\n// 1 / √(a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\n// 1-d²\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\n// (d-1)²\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n// Calculates 1/√(number)\nconst invertSqrt = (number) => uvRatio(_1n, number);\nconst MAX_255B = /* @__PURE__ */ BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nconst bytes255ToNumberLE = (bytes) => ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!isNegativeLE(s_, P))\n        s_ = mod(-s_);\n    if (!Ns_D_is_sq)\n        s = s_; // 7\n    if (!Ns_D_is_sq)\n        c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */\nclass RistPoint {\n    // Private property to discourage combining ExtendedPoint + RistrettoPoint\n    // Always use Ristretto encoding/decoding instead.\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static fromAffine(ap) {\n        return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n    }\n    /**\n     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n     * The hash-to-group operation applies Elligator twice and adds the results.\n     * **Note:** this is one-way map, there is no conversion from point to hash.\n     * https://ristretto.group/formulas/elligator.html\n     * @param hex 64-byte output of a hash function\n     */\n    static hashToCurve(hex) {\n        hex = ensureBytes('ristrettoHash', hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = calcElligatorRistrettoMap(r2);\n        return new RistPoint(R1.add(R2));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * https://ristretto.group/formulas/decoding.html\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */\n    static fromHex(hex) {\n        hex = ensureBytes('ristrettoHex', hex, 32);\n        const { a, d } = ed25519.CURVE;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!equalBytes(numberToBytesLE(s, 32), hex) || isNegativeLE(s, P))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if (isNegativeLE(x, P))\n            x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || isNegativeLE(t, P) || y === _0n)\n            throw new Error(emsg);\n        return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n    }\n    static msm(points, scalars) {\n        const Fn = Field(ed25519.CURVE.n, ed25519.CURVE.nBitLength);\n        return pippenger(RistPoint, Fn, points, scalars);\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * https://ristretto.group/formulas/encoding.html\n     */\n    toRawBytes() {\n        let { ex: x, ey: y, ez: z, et: t } = this.ep;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const u1 = mod(mod(z + y) * mod(z - y)); // 1\n        const u2 = mod(x * y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * t); // 6\n        let D; // 7\n        if (isNegativeLE(t * zInv, P)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2; // 8\n        }\n        if (isNegativeLE(x * zInv, P))\n            y = mod(-y); // 9\n        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n        if (isNegativeLE(s, P))\n            s = mod(-s);\n        return numberToBytesLE(s, 32); // 11\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    // Compare one point to another.\n    equals(other) {\n        assertRstPoint(other);\n        const { ex: X1, ey: Y1 } = this.ep;\n        const { ex: X2, ey: Y2 } = other.ep;\n        const mod = ed25519.CURVE.Fp.create;\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistPoint(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return new RistPoint(this.ep.double());\n    }\n    negate() {\n        return new RistPoint(this.ep.negate());\n    }\n}\nexport const RistrettoPoint = /* @__PURE__ */ (() => {\n    if (!RistPoint.BASE)\n        RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n    if (!RistPoint.ZERO)\n        RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n    return RistPoint;\n})();\n// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B\nexport const hashToRistretto255 = (msg, options) => {\n    const d = options.DST;\n    const DST = typeof d === 'string' ? utf8ToBytes(d) : d;\n    const uniform_bytes = expand_message_xmd(msg, DST, 64, sha512);\n    const P = RistPoint.hashToCurve(uniform_bytes);\n    return P;\n};\nexport const hash_to_ristretto255 = hashToRistretto255; // legacy\n//# sourceMappingURL=ed25519.js.map","import { IridiumJWTHeader } from \"./types\";\n\n// ---------- JWT ----------------------------------------------- //\n\nexport const JWT_IRIDIUM_ALG: IridiumJWTHeader[\"alg\"] = \"EdDSA\";\n\nexport const JWT_IRIDIUM_TYP: IridiumJWTHeader[\"typ\"] = \"JWT\";\n\nexport const JWT_DELIMITER = \".\";\n\nexport const JWT_ENCODING = \"base64url\";\n\nexport const JSON_ENCODING = \"utf8\";\n\nexport const DATA_ENCODING = \"utf8\";\n\n// ---------- DID ----------------------------------------------- //\n\nexport const DID_DELIMITER = \":\";\n\nexport const DID_PREFIX = \"did\";\n\nexport const DID_METHOD = \"key\";\n\n// ---------- Multicodec ----------------------------------------------- //\n\nexport const MULTICODEC_ED25519_ENCODING = \"base58btc\";\n\nexport const MULTICODEC_ED25519_BASE = \"z\";\n\nexport const MULTICODEC_ED25519_HEADER = \"K36\";\n\nexport const MULTICODEC_ED25519_LENGTH = 32;\n\n// ---------- KeyPair ----------------------------------------------- //\n\nexport const KEY_PAIR_SEED_LENGTH = 32;\n","export function asUint8Array(buf) {\n  if (globalThis.Buffer != null) {\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n  }\n  return buf;\n}","import { asUint8Array } from './util/as-uint8array.js';\nexport function alloc(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {\n    return asUint8Array(globalThis.Buffer.alloc(size));\n  }\n  return new Uint8Array(size);\n}\nexport function allocUnsafe(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {\n    return asUint8Array(globalThis.Buffer.allocUnsafe(size));\n  }\n  return new Uint8Array(size);\n}","import { allocUnsafe } from './alloc.js';\nimport { asUint8Array } from './util/as-uint8array.js';\nexport function concat(arrays, length) {\n  if (!length) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0);\n  }\n  const output = allocUnsafe(length);\n  let offset = 0;\n  for (const arr of arrays) {\n    output.set(arr, offset);\n    offset += arr.length;\n  }\n  return asUint8Array(output);\n}","function base(ALPHABET, name) {\n  if (ALPHABET.length >= 255) {\n    throw new TypeError('Alphabet too long');\n  }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) {\n      throw new TypeError(x + ' is ambiguous');\n    }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256);\n  var iFACTOR = Math.log(256) / Math.log(BASE);\n  function encode(source) {\n    if (source instanceof Uint8Array);\n    else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) {\n      throw new TypeError('Expected Uint8Array');\n    }\n    if (source.length === 0) {\n      return '';\n    }\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n    var b58 = new Uint8Array(size);\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n        carry += 256 * b58[it1] >>> 0;\n        b58[it1] = carry % BASE >>> 0;\n        carry = carry / BASE >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      pbegin++;\n    }\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n      str += ALPHABET.charAt(b58[it2]);\n    }\n    return str;\n  }\n  function decodeUnsafe(source) {\n    if (typeof source !== 'string') {\n      throw new TypeError('Expected String');\n    }\n    if (source.length === 0) {\n      return new Uint8Array();\n    }\n    var psz = 0;\n    if (source[psz] === ' ') {\n      return;\n    }\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n    var size = (source.length - psz) * FACTOR + 1 >>> 0;\n    var b256 = new Uint8Array(size);\n    while (source[psz]) {\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n      if (carry === 255) {\n        return;\n      }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n        carry += BASE * b256[it3] >>> 0;\n        b256[it3] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      psz++;\n    }\n    if (source[psz] === ' ') {\n      return;\n    }\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch;\n  }\n  function decode(string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) {\n      return buffer;\n    }\n    throw new Error(`Non-${ name } character`);\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nexport default _brrp__multiformats_scope_baseX;","const empty = new Uint8Array(0);\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\nconst fromHex = hex => {\n  const hexes = hex.match(/../g);\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n};\nconst equals = (aa, bb) => {\n  if (aa === bb)\n    return true;\n  if (aa.byteLength !== bb.byteLength) {\n    return false;\n  }\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false;\n    }\n  }\n  return true;\n};\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n    return o;\n  if (o instanceof ArrayBuffer)\n    return new Uint8Array(o);\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n};\nconst isBinary = o => o instanceof ArrayBuffer || ArrayBuffer.isView(o);\nconst fromString = str => new TextEncoder().encode(str);\nconst toString = b => new TextDecoder().decode(b);\nexport {\n  equals,\n  coerce,\n  isBinary,\n  fromHex,\n  toHex,\n  fromString,\n  toString,\n  empty\n};","import basex from '../../vendor/base-x.js';\nimport { coerce } from '../bytes.js';\nclass Encoder {\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${ this.prefix }${ this.baseEncode(bytes) }`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}\nclass Decoder {\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character');\n    }\n    this.prefixCodePoint = prefix.codePointAt(0);\n    this.baseDecode = baseDecode;\n  }\n  decode(text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);\n      }\n      return this.baseDecode(text.slice(this.prefix.length));\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n}\nclass ComposedDecoder {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);\n    }\n  }\n}\nexport const or = (left, right) => new ComposedDecoder({\n  ...left.decoders || { [left.prefix]: left },\n  ...right.decoders || { [right.prefix]: right }\n});\nexport class Codec {\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n}\nexport const from = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);\nexport const baseX = ({prefix, name, alphabet}) => {\n  const {encode, decode} = basex(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => coerce(decode(text))\n  });\n};\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  const codes = {};\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n  let end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string[i]];\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${ name } character`);\n    }\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0;\n  let buffer = 0;\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\nexport const rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {\n  return from({\n    prefix,\n    name,\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n  });\n};","import { from } from './base.js';\nimport {\n  fromString,\n  toString\n} from '../bytes.js';\nexport const identity = from({\n  prefix: '\\0',\n  name: 'identity',\n  encode: buf => toString(buf),\n  decode: str => fromString(str)\n});","import { rfc4648 } from './base.js';\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n});","import { rfc4648 } from './base.js';\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n});","import { baseX } from './base.js';\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n});","import { rfc4648 } from './base.js';\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n});\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n});","import { rfc4648 } from './base.js';\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n});\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n});\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n});\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n});\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n});\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n});\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n});\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n});\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n});","import { baseX } from './base.js';\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n});\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n});","import { baseX } from './base.js';\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});","import { rfc4648 } from './base.js';\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n});\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n});\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n});\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n});","import { from } from './base.js';\nconst alphabet = Array.from('\\uD83D\\uDE80\\uD83E\\uDE90\\u2604\\uD83D\\uDEF0\\uD83C\\uDF0C\\uD83C\\uDF11\\uD83C\\uDF12\\uD83C\\uDF13\\uD83C\\uDF14\\uD83C\\uDF15\\uD83C\\uDF16\\uD83C\\uDF17\\uD83C\\uDF18\\uD83C\\uDF0D\\uD83C\\uDF0F\\uD83C\\uDF0E\\uD83D\\uDC09\\u2600\\uD83D\\uDCBB\\uD83D\\uDDA5\\uD83D\\uDCBE\\uD83D\\uDCBF\\uD83D\\uDE02\\u2764\\uD83D\\uDE0D\\uD83E\\uDD23\\uD83D\\uDE0A\\uD83D\\uDE4F\\uD83D\\uDC95\\uD83D\\uDE2D\\uD83D\\uDE18\\uD83D\\uDC4D\\uD83D\\uDE05\\uD83D\\uDC4F\\uD83D\\uDE01\\uD83D\\uDD25\\uD83E\\uDD70\\uD83D\\uDC94\\uD83D\\uDC96\\uD83D\\uDC99\\uD83D\\uDE22\\uD83E\\uDD14\\uD83D\\uDE06\\uD83D\\uDE44\\uD83D\\uDCAA\\uD83D\\uDE09\\u263A\\uD83D\\uDC4C\\uD83E\\uDD17\\uD83D\\uDC9C\\uD83D\\uDE14\\uD83D\\uDE0E\\uD83D\\uDE07\\uD83C\\uDF39\\uD83E\\uDD26\\uD83C\\uDF89\\uD83D\\uDC9E\\u270C\\u2728\\uD83E\\uDD37\\uD83D\\uDE31\\uD83D\\uDE0C\\uD83C\\uDF38\\uD83D\\uDE4C\\uD83D\\uDE0B\\uD83D\\uDC97\\uD83D\\uDC9A\\uD83D\\uDE0F\\uD83D\\uDC9B\\uD83D\\uDE42\\uD83D\\uDC93\\uD83E\\uDD29\\uD83D\\uDE04\\uD83D\\uDE00\\uD83D\\uDDA4\\uD83D\\uDE03\\uD83D\\uDCAF\\uD83D\\uDE48\\uD83D\\uDC47\\uD83C\\uDFB6\\uD83D\\uDE12\\uD83E\\uDD2D\\u2763\\uD83D\\uDE1C\\uD83D\\uDC8B\\uD83D\\uDC40\\uD83D\\uDE2A\\uD83D\\uDE11\\uD83D\\uDCA5\\uD83D\\uDE4B\\uD83D\\uDE1E\\uD83D\\uDE29\\uD83D\\uDE21\\uD83E\\uDD2A\\uD83D\\uDC4A\\uD83E\\uDD73\\uD83D\\uDE25\\uD83E\\uDD24\\uD83D\\uDC49\\uD83D\\uDC83\\uD83D\\uDE33\\u270B\\uD83D\\uDE1A\\uD83D\\uDE1D\\uD83D\\uDE34\\uD83C\\uDF1F\\uD83D\\uDE2C\\uD83D\\uDE43\\uD83C\\uDF40\\uD83C\\uDF37\\uD83D\\uDE3B\\uD83D\\uDE13\\u2B50\\u2705\\uD83E\\uDD7A\\uD83C\\uDF08\\uD83D\\uDE08\\uD83E\\uDD18\\uD83D\\uDCA6\\u2714\\uD83D\\uDE23\\uD83C\\uDFC3\\uD83D\\uDC90\\u2639\\uD83C\\uDF8A\\uD83D\\uDC98\\uD83D\\uDE20\\u261D\\uD83D\\uDE15\\uD83C\\uDF3A\\uD83C\\uDF82\\uD83C\\uDF3B\\uD83D\\uDE10\\uD83D\\uDD95\\uD83D\\uDC9D\\uD83D\\uDE4A\\uD83D\\uDE39\\uD83D\\uDDE3\\uD83D\\uDCAB\\uD83D\\uDC80\\uD83D\\uDC51\\uD83C\\uDFB5\\uD83E\\uDD1E\\uD83D\\uDE1B\\uD83D\\uDD34\\uD83D\\uDE24\\uD83C\\uDF3C\\uD83D\\uDE2B\\u26BD\\uD83E\\uDD19\\u2615\\uD83C\\uDFC6\\uD83E\\uDD2B\\uD83D\\uDC48\\uD83D\\uDE2E\\uD83D\\uDE46\\uD83C\\uDF7B\\uD83C\\uDF43\\uD83D\\uDC36\\uD83D\\uDC81\\uD83D\\uDE32\\uD83C\\uDF3F\\uD83E\\uDDE1\\uD83C\\uDF81\\u26A1\\uD83C\\uDF1E\\uD83C\\uDF88\\u274C\\u270A\\uD83D\\uDC4B\\uD83D\\uDE30\\uD83E\\uDD28\\uD83D\\uDE36\\uD83E\\uDD1D\\uD83D\\uDEB6\\uD83D\\uDCB0\\uD83C\\uDF53\\uD83D\\uDCA2\\uD83E\\uDD1F\\uD83D\\uDE41\\uD83D\\uDEA8\\uD83D\\uDCA8\\uD83E\\uDD2C\\u2708\\uD83C\\uDF80\\uD83C\\uDF7A\\uD83E\\uDD13\\uD83D\\uDE19\\uD83D\\uDC9F\\uD83C\\uDF31\\uD83D\\uDE16\\uD83D\\uDC76\\uD83E\\uDD74\\u25B6\\u27A1\\u2753\\uD83D\\uDC8E\\uD83D\\uDCB8\\u2B07\\uD83D\\uDE28\\uD83C\\uDF1A\\uD83E\\uDD8B\\uD83D\\uDE37\\uD83D\\uDD7A\\u26A0\\uD83D\\uDE45\\uD83D\\uDE1F\\uD83D\\uDE35\\uD83D\\uDC4E\\uD83E\\uDD32\\uD83E\\uDD20\\uD83E\\uDD27\\uD83D\\uDCCC\\uD83D\\uDD35\\uD83D\\uDC85\\uD83E\\uDDD0\\uD83D\\uDC3E\\uD83C\\uDF52\\uD83D\\uDE17\\uD83E\\uDD11\\uD83C\\uDF0A\\uD83E\\uDD2F\\uD83D\\uDC37\\u260E\\uD83D\\uDCA7\\uD83D\\uDE2F\\uD83D\\uDC86\\uD83D\\uDC46\\uD83C\\uDFA4\\uD83D\\uDE47\\uD83C\\uDF51\\u2744\\uD83C\\uDF34\\uD83D\\uDCA3\\uD83D\\uDC38\\uD83D\\uDC8C\\uD83D\\uDCCD\\uD83E\\uDD40\\uD83E\\uDD22\\uD83D\\uDC45\\uD83D\\uDCA1\\uD83D\\uDCA9\\uD83D\\uDC50\\uD83D\\uDCF8\\uD83D\\uDC7B\\uD83E\\uDD10\\uD83E\\uDD2E\\uD83C\\uDFBC\\uD83E\\uDD75\\uD83D\\uDEA9\\uD83C\\uDF4E\\uD83C\\uDF4A\\uD83D\\uDC7C\\uD83D\\uDC8D\\uD83D\\uDCE3\\uD83E\\uDD42');\nconst alphabetBytesToChars = alphabet.reduce((p, c, i) => {\n  p[i] = c;\n  return p;\n}, []);\nconst alphabetCharsToBytes = alphabet.reduce((p, c, i) => {\n  p[c.codePointAt(0)] = i;\n  return p;\n}, []);\nfunction encode(data) {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c];\n    return p;\n  }, '');\n}\nfunction decode(str) {\n  const byts = [];\n  for (const char of str) {\n    const byt = alphabetCharsToBytes[char.codePointAt(0)];\n    if (byt === undefined) {\n      throw new Error(`Non-base256emoji character: ${ char }`);\n    }\n    byts.push(byt);\n  }\n  return new Uint8Array(byts);\n}\nexport const base256emoji = from({\n  prefix: '\\uD83D\\uDE80',\n  name: 'base256emoji',\n  encode,\n  decode\n});","var encode_1 = encode;\nvar MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n  while (num >= INT) {\n    out[offset++] = num & 255 | MSB;\n    num /= 128;\n  }\n  while (num & MSBALL) {\n    out[offset++] = num & 255 | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  encode.bytes = offset - oldOffset + 1;\n  return out;\n}\nvar decode = read;\nvar MSB$1 = 128, REST$1 = 127;\nfunction read(buf, offset) {\n  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint');\n    }\n    b = buf[counter++];\n    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1);\n  read.bytes = counter - offset;\n  return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (value) {\n  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;\n};\nvar varint = {\n  encode: encode_1,\n  decode: decode,\n  encodingLength: length\n};\nvar _brrp_varint = varint;\nexport default _brrp_varint;","import varint from '../vendor/varint.js';\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset);\n  return [\n    code,\n    varint.decode.bytes\n  ];\n};\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset);\n  return target;\n};\nexport const encodingLength = int => {\n  return varint.encodingLength(int);\n};","import {\n  coerce,\n  equals as equalBytes\n} from '../bytes.js';\nimport * as varint from '../varint.js';\nexport const create = (code, digest) => {\n  const size = digest.byteLength;\n  const sizeOffset = varint.encodingLength(code);\n  const digestOffset = sizeOffset + varint.encodingLength(size);\n  const bytes = new Uint8Array(digestOffset + size);\n  varint.encodeTo(code, bytes, 0);\n  varint.encodeTo(size, bytes, sizeOffset);\n  bytes.set(digest, digestOffset);\n  return new Digest(code, size, digest, bytes);\n};\nexport const decode = multihash => {\n  const bytes = coerce(multihash);\n  const [code, sizeOffset] = varint.decode(bytes);\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset));\n  const digest = bytes.subarray(sizeOffset + digestOffset);\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length');\n  }\n  return new Digest(code, size, digest, bytes);\n};\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true;\n  } else {\n    return a.code === b.code && a.size === b.size && equalBytes(a.bytes, b.bytes);\n  }\n};\nexport class Digest {\n  constructor(code, size, digest, bytes) {\n    this.code = code;\n    this.size = size;\n    this.digest = digest;\n    this.bytes = bytes;\n  }\n}","import * as Digest from './digest.js';\nexport const from = ({name, code, encode}) => new Hasher(name, code, encode);\nexport class Hasher {\n  constructor(name, code, encode) {\n    this.name = name;\n    this.code = code;\n    this.encode = encode;\n  }\n  digest(input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input);\n      return result instanceof Uint8Array ? Digest.create(this.code, result) : result.then(digest => Digest.create(this.code, digest));\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}","import { from } from './hasher.js';\nconst sha = name => async data => new Uint8Array(await crypto.subtle.digest(name, data));\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 18,\n  encode: sha('SHA-256')\n});\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 19,\n  encode: sha('SHA-512')\n});","import { coerce } from '../bytes.js';\nimport * as Digest from './digest.js';\nconst code = 0;\nconst name = 'identity';\nconst encode = coerce;\nconst digest = input => Digest.create(code, encode(input));\nexport const identity = {\n  code,\n  name,\n  encode,\n  digest\n};","const textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nexport const name = 'json';\nexport const code = 512;\nexport const encode = node => textEncoder.encode(JSON.stringify(node));\nexport const decode = data => JSON.parse(textDecoder.decode(data));","import * as identityBase from './bases/identity.js';\nimport * as base2 from './bases/base2.js';\nimport * as base8 from './bases/base8.js';\nimport * as base10 from './bases/base10.js';\nimport * as base16 from './bases/base16.js';\nimport * as base32 from './bases/base32.js';\nimport * as base36 from './bases/base36.js';\nimport * as base58 from './bases/base58.js';\nimport * as base64 from './bases/base64.js';\nimport * as base256emoji from './bases/base256emoji.js';\nimport * as sha2 from './hashes/sha2.js';\nimport * as identity from './hashes/identity.js';\nimport * as raw from './codecs/raw.js';\nimport * as json from './codecs/json.js';\nimport {\n  CID,\n  hasher,\n  digest,\n  varint,\n  bytes\n} from './index.js';\nconst bases = {\n  ...identityBase,\n  ...base2,\n  ...base8,\n  ...base10,\n  ...base16,\n  ...base32,\n  ...base36,\n  ...base58,\n  ...base64,\n  ...base256emoji\n};\nconst hashes = {\n  ...sha2,\n  ...identity\n};\nconst codecs = {\n  raw,\n  json\n};\nexport {\n  CID,\n  hasher,\n  digest,\n  varint,\n  bytes,\n  hashes,\n  bases,\n  codecs\n};","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: { decode }\n  };\n}\nconst string = createCodec('utf8', 'u', buf => {\n  const decoder = new TextDecoder('utf8');\n  return 'u' + decoder.decode(buf);\n}, str => {\n  const encoder = new TextEncoder();\n  return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', buf => {\n  let string = 'a';\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i]);\n  }\n  return string;\n}, str => {\n  str = str.substring(1);\n  const buf = allocUnsafe(str.length);\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n});\nconst BASES = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii: ascii,\n  binary: ascii,\n  ...bases\n};\nexport default BASES;","import bases from './util/bases.js';\nexport function toString(array, encoding = 'utf8') {\n  const base = bases[encoding];\n  if (!base) {\n    throw new Error(`Unsupported encoding \"${ encoding }\"`);\n  }\n  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString('utf8');\n  }\n  return base.encoder.encode(array).substring(1);\n}","import bases from './util/bases.js';\nimport { asUint8Array } from './util/as-uint8array.js';\nexport function fromString(string, encoding = 'utf8') {\n  const base = bases[encoding];\n  if (!base) {\n    throw new Error(`Unsupported encoding \"${ encoding }\"`);\n  }\n  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n    return asUint8Array(globalThis.Buffer.from(string, 'utf-8'));\n  }\n  return base.decoder.decode(`${ base.prefix }${ string }`);\n}","import { concat } from \"uint8arrays/concat\";\nimport { toString } from \"uint8arrays/to-string\";\nimport { fromString } from \"uint8arrays/from-string\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\n\nimport {\n  DATA_ENCODING,\n  DID_DELIMITER,\n  DID_METHOD,\n  DID_PREFIX,\n  JSON_ENCODING,\n  JWT_DELIMITER,\n  JWT_ENCODING,\n  MULTICODEC_ED25519_BASE,\n  MULTICODEC_ED25519_ENCODING,\n  MULTICODEC_ED25519_HEADER,\n  MULTICODEC_ED25519_LENGTH,\n} from \"./constants\";\nimport { IridiumJWTData, IridiumJWTDecoded, IridiumJWTSigned } from \"./types\";\n\n// ---------- JSON ----------------------------------------------- //\n\nexport function decodeJSON(str: string): any {\n  return safeJsonParse(toString(fromString(str, JWT_ENCODING), JSON_ENCODING));\n}\n\nexport function encodeJSON(val: any): string {\n  return toString(fromString(safeJsonStringify(val), JSON_ENCODING), JWT_ENCODING);\n}\n\n// ---------- Issuer ----------------------------------------------- //\n\nexport function encodeIss(publicKey: Uint8Array): string {\n  const header = fromString(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING);\n  const multicodec =\n    MULTICODEC_ED25519_BASE + toString(concat([header, publicKey]), MULTICODEC_ED25519_ENCODING);\n  return [DID_PREFIX, DID_METHOD, multicodec].join(DID_DELIMITER);\n}\n\nexport function decodeIss(issuer: string): Uint8Array {\n  const [prefix, method, multicodec] = issuer.split(DID_DELIMITER);\n  if (prefix !== DID_PREFIX || method !== DID_METHOD) {\n    throw new Error(`Issuer must be a DID with method \"key\"`);\n  }\n  const base = multicodec.slice(0, 1);\n  if (base !== MULTICODEC_ED25519_BASE) {\n    throw new Error(`Issuer must be a key in mulicodec format`);\n  }\n  const bytes = fromString(multicodec.slice(1), MULTICODEC_ED25519_ENCODING);\n  const type = toString(bytes.slice(0, 2), MULTICODEC_ED25519_ENCODING);\n  if (type !== MULTICODEC_ED25519_HEADER) {\n    throw new Error(`Issuer must be a public key with type \"Ed25519\"`);\n  }\n  const publicKey = bytes.slice(2);\n  if (publicKey.length !== MULTICODEC_ED25519_LENGTH) {\n    throw new Error(`Issuer must be a public key with length 32 bytes`);\n  }\n  return publicKey;\n}\n\n// ---------- Signature ----------------------------------------------- //\n\nexport function encodeSig(bytes: Uint8Array): string {\n  return toString(bytes, JWT_ENCODING);\n}\n\nexport function decodeSig(encoded: string): Uint8Array {\n  return fromString(encoded, JWT_ENCODING);\n}\n\n// ---------- Data ----------------------------------------------- //\n\nexport function encodeData(params: IridiumJWTData): Uint8Array {\n  return fromString(\n    [encodeJSON(params.header), encodeJSON(params.payload)].join(JWT_DELIMITER),\n    DATA_ENCODING,\n  );\n}\n\nexport function decodeData(data: Uint8Array): IridiumJWTData {\n  const params = toString(data, DATA_ENCODING).split(JWT_DELIMITER);\n  const header = decodeJSON(params[0]);\n  const payload = decodeJSON(params[1]);\n  return { header, payload };\n}\n\n// ---------- JWT ----------------------------------------------- //\n\nexport function encodeJWT(params: IridiumJWTSigned): string {\n  return [encodeJSON(params.header), encodeJSON(params.payload), encodeSig(params.signature)].join(\n    JWT_DELIMITER,\n  );\n}\n\nexport function decodeJWT(jwt: string): IridiumJWTDecoded {\n  const params = jwt.split(JWT_DELIMITER);\n  const header = decodeJSON(params[0]);\n  const payload = decodeJSON(params[1]);\n  const signature = decodeSig(params[2]);\n  const data = fromString(params.slice(0, 2).join(JWT_DELIMITER), DATA_ENCODING);\n  return { header, payload, signature, data };\n}\n","import { ed25519 } from \"@noble/curves/ed25519\";\nimport { randomBytes } from \"@noble/hashes/utils\";\nimport { fromMiliseconds } from \"@walletconnect/time\";\nimport { JWT_IRIDIUM_ALG, JWT_IRIDIUM_TYP, KEY_PAIR_SEED_LENGTH } from \"./constants\";\n\nimport { decodeIss, decodeJWT, encodeData, encodeIss, encodeJWT } from \"./utils\";\nimport { concat } from \"uint8arrays/concat\";\n\nexport interface Keypair {\n  secretKey: Uint8Array;\n  publicKey: Uint8Array;\n}\n\nexport function generateKeyPair(seed: Uint8Array = randomBytes(KEY_PAIR_SEED_LENGTH)): Keypair {\n  const publicKey = ed25519.getPublicKey(seed);\n  const secretKey = concat([seed, publicKey]);\n  return {\n    secretKey,\n    publicKey,\n  };\n}\n\nexport async function signJWT(\n  sub: string,\n  aud: string,\n  ttl: number,\n  keyPair: Keypair,\n  iat: number = fromMiliseconds(Date.now()),\n) {\n  const header = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP };\n  const iss = encodeIss(keyPair.publicKey);\n  const exp = iat + ttl;\n  const payload = { iss, sub, aud, iat, exp };\n  const data = encodeData({ header, payload });\n  const signature = ed25519.sign(data, keyPair.secretKey.slice(0, 32));\n  return encodeJWT({ header, payload, signature });\n}\n\nexport async function verifyJWT(jwt: string) {\n  const { header, payload, data, signature } = decodeJWT(jwt);\n  if (header.alg !== JWT_IRIDIUM_ALG || header.typ !== JWT_IRIDIUM_TYP) {\n    throw new Error(\"JWT must use EdDSA algorithm\");\n  }\n  const publicKey = decodeIss(payload.iss);\n  return ed25519.verify(signature, data, publicKey);\n}\n"],"names":["isBytes","abytes","crypto","sha512","_0n","_1n","_2n","_5n","_8n","ut.validateObject","ut.aInRange","ut.bytesToNumberLE","ut.numberToBytesLE","ut.bytesToHex","ut.concatBytes","fromString","toString","from","basex","decode","encode","identity","varint","varint.encodingLength","varint.encodeTo","Digest.create","base2","base8","base10","base16","base32","base36","base64","base256emoji","bases","str","safeJsonParse","JWT_ENCODING","JSON_ENCODING","val","safeJsonStringify","publicKey","header","MULTICODEC_ED25519_HEADER","MULTICODEC_ED25519_ENCODING","multicodec","MULTICODEC_ED25519_BASE","concat","DID_PREFIX","DID_METHOD","DID_DELIMITER","issuer","prefix","method","bytes","MULTICODEC_ED25519_LENGTH","encoded","params","JWT_DELIMITER","DATA_ENCODING","data","payload","jwt","signature","seed","randomBytes","KEY_PAIR_SEED_LENGTH","ed25519","sub","aud","ttl","keyPair","iat","fromMiliseconds","JWT_IRIDIUM_ALG","JWT_IRIDIUM_TYP","iss","encodeIss","exp","encodeData","encodeJWT","decodeJWT","decodeIss"],"mappings":"","debugId":null}},
    {"offset": {"line": 3249, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/relay-api/dist/index.es.js","sources":["file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/relay-api/src/misc.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/relay-api/src/validators.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/relay-api/src/parsers.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/relay-api/src/jsonrpc.ts"],"sourcesContent":["export function assertType(obj: any, key: string, type = \"string\") {\n  if (!obj[key] || typeof obj[key] !== type) {\n    throw new Error(`Missing or invalid \"${key}\" param`);\n  }\n}\n\nexport function hasRequiredParams(params: any, required: string[]) {\n  let matches = true;\n  required.forEach((key) => {\n    const exists = key in params;\n    if (!exists) {\n      matches = false;\n    }\n  });\n  return matches;\n}\n\nexport function hasExactParamsLength(params: any, length: number): boolean {\n  return Array.isArray(params) ? params.length === length : Object.keys(params).length === length;\n}\n\nexport function hasRequiredParamsLength(params: any, minLength: number): boolean {\n  return Array.isArray(params)\n    ? params.length >= minLength\n    : Object.keys(params).length >= minLength;\n}\n\nexport function checkParams(params: any, required: string[], optional: string[]) {\n  const exact = !optional.length;\n  const matchesLength = exact\n    ? hasExactParamsLength(params, required.length)\n    : hasRequiredParamsLength(params, required.length);\n  if (!matchesLength) return false;\n  return hasRequiredParams(params, required);\n}\n\nexport function methodEndsWith(method: string, expected: string, separator = \"_\") {\n  const split = method.split(separator);\n  return split[split.length - 1].trim().toLowerCase() === expected.trim().toLowerCase();\n}\n","import { JsonRpcRequest } from \"@walletconnect/jsonrpc-types\";\n\nimport { checkParams, methodEndsWith } from \"./misc\";\nimport { RelayJsonRpc } from \"./types\";\n\n// ---------- Subscribe ----------------------------------------------- //\n\nexport function isSubscribeRequest(\n  request: JsonRpcRequest,\n): request is JsonRpcRequest<RelayJsonRpc.SubscribeParams> {\n  return isSubscribeMethod(request.method) && isSubscribeParams(request.params);\n}\n\nexport function isSubscribeMethod(method: string): boolean {\n  return methodEndsWith(method, \"subscribe\");\n}\n\nexport function isSubscribeParams(params: any): params is RelayJsonRpc.SubscribeParams {\n  const required = [\"topic\"];\n  const optional: string[] = [];\n  return checkParams(params, required, optional);\n}\n\n// ---------- Publish ----------------------------------------------- //\n\nexport function isPublishRequest(\n  request: JsonRpcRequest,\n): request is JsonRpcRequest<RelayJsonRpc.PublishParams> {\n  return isPublishMethod(request.method) && isPublishParams(request.params);\n}\n\nexport function isPublishMethod(method: string): boolean {\n  return methodEndsWith(method, \"publish\");\n}\n\nexport function isPublishParams(params: any): params is RelayJsonRpc.PublishParams {\n  const required = [\"message\", \"topic\", \"ttl\"];\n  const optional = [\"prompt\", \"tag\"];\n  return checkParams(params, required, optional);\n}\n\n// ---------- Unsubscribe ----------------------------------------------- //\n\nexport function isUnsubscribeRequest(\n  request: JsonRpcRequest,\n): request is JsonRpcRequest<RelayJsonRpc.UnsubscribeParams> {\n  return isUnsubscribeMethod(request.method) && isUnsubscribeParams(request.params);\n}\n\nexport function isUnsubscribeMethod(method: string): boolean {\n  return methodEndsWith(method, \"unsubscribe\");\n}\n\nexport function isUnsubscribeParams(params: any): params is RelayJsonRpc.UnsubscribeParams {\n  const required = [\"id\", \"topic\"];\n  const optional: string[] = [];\n  return checkParams(params, required, optional);\n}\n\n// ---------- Subscription ----------------------------------------------- //\n\nexport function isSubscriptionRequest(\n  request: JsonRpcRequest,\n): request is JsonRpcRequest<RelayJsonRpc.SubscriptionParams> {\n  return isSubscriptionMethod(request.method) && isSubscriptionParams(request.params);\n}\n\nexport function isSubscriptionMethod(method: string): boolean {\n  return methodEndsWith(method, \"subscription\");\n}\n\nexport function isSubscriptionParams(params: any): params is RelayJsonRpc.SubscriptionParams {\n  const required = [\"id\", \"data\"];\n  const optional: string[] = [];\n  return checkParams(params, required, optional);\n}\n","import { JsonRpcRequest } from \"@walletconnect/jsonrpc-types\";\n\nimport { RelayJsonRpc } from \"./types\";\nimport { assertType } from \"./misc\";\nimport {\n  isPublishMethod,\n  isPublishParams,\n  isSubscribeMethod,\n  isSubscribeParams,\n  isSubscriptionMethod,\n  isSubscriptionParams,\n  isUnsubscribeMethod,\n  isUnsubscribeParams,\n} from \"./validators\";\n\nexport function parseSubscribeRequest(request: JsonRpcRequest): RelayJsonRpc.SubscribeParams {\n  if (!isSubscribeMethod(request.method)) {\n    throw new Error(\"JSON-RPC Request has invalid subscribe method\");\n  }\n  if (!isSubscribeParams(request.params)) {\n    throw new Error(\"JSON-RPC Request has invalid subscribe params\");\n  }\n  const params = request.params as RelayJsonRpc.SubscribeParams;\n\n  assertType(params, \"topic\");\n\n  return params;\n}\n\nexport function parsePublishRequest(request: JsonRpcRequest): RelayJsonRpc.PublishParams {\n  if (!isPublishMethod(request.method)) {\n    throw new Error(\"JSON-RPC Request has invalid publish method\");\n  }\n  if (!isPublishParams(request.params)) {\n    throw new Error(\"JSON-RPC Request has invalid publish params\");\n  }\n  const params = request.params as RelayJsonRpc.PublishParams;\n\n  assertType(params, \"topic\");\n  assertType(params, \"message\");\n  assertType(params, \"ttl\", \"number\");\n\n  return params;\n}\n\nexport function parseUnsubscribeRequest(request: JsonRpcRequest): RelayJsonRpc.UnsubscribeParams {\n  if (!isUnsubscribeMethod(request.method)) {\n    throw new Error(\"JSON-RPC Request has invalid unsubscribe method\");\n  }\n  if (!isUnsubscribeParams(request.params)) {\n    throw new Error(\"JSON-RPC Request has invalid unsubscribe params\");\n  }\n  const params = request.params as RelayJsonRpc.UnsubscribeParams;\n\n  assertType(params, \"id\");\n\n  return params;\n}\n\nexport function parseSubscriptionRequest(request: JsonRpcRequest): RelayJsonRpc.SubscriptionParams {\n  if (!isSubscriptionMethod(request.method)) {\n    throw new Error(\"JSON-RPC Request has invalid subscription method\");\n  }\n  if (!isSubscriptionParams(request.params)) {\n    throw new Error(\"JSON-RPC Request has invalid subscription params\");\n  }\n  const params = request.params as RelayJsonRpc.SubscriptionParams;\n\n  assertType(params, \"id\");\n  assertType(params, \"data\");\n\n  return params;\n}\n","import { RelayJsonRpc } from \"./types\";\n\nexport const RELAY_JSONRPC: { [protocol: string]: RelayJsonRpc.Methods } = {\n  waku: {\n    publish: \"waku_publish\",\n    batchPublish: \"waku_batchPublish\",\n    subscribe: \"waku_subscribe\",\n    batchSubscribe: \"waku_batchSubscribe\",\n    subscription: \"waku_subscription\",\n    unsubscribe: \"waku_unsubscribe\",\n    batchUnsubscribe: \"waku_batchUnsubscribe\",\n    batchFetchMessages: \"waku_batchFetchMessages\",\n  },\n  irn: {\n    publish: \"irn_publish\",\n    batchPublish: \"irn_batchPublish\",\n    subscribe: \"irn_subscribe\",\n    batchSubscribe: \"irn_batchSubscribe\",\n    subscription: \"irn_subscription\",\n    unsubscribe: \"irn_unsubscribe\",\n    batchUnsubscribe: \"irn_batchUnsubscribe\",\n    batchFetchMessages: \"irn_batchFetchMessages\",\n  },\n  iridium: {\n    publish: \"iridium_publish\",\n    batchPublish: \"iridium_batchPublish\",\n    subscribe: \"iridium_subscribe\",\n    batchSubscribe: \"iridium_batchSubscribe\",\n    subscription: \"iridium_subscription\",\n    unsubscribe: \"iridium_unsubscribe\",\n    batchUnsubscribe: \"iridium_batchUnsubscribe\",\n    batchFetchMessages: \"iridium_batchFetchMessages\",\n  },\n};\n"],"names":["obj","key","type","params","required","matches","length","minLength","optional","method","expected","separator","split","request","methodEndsWith","checkParams","isSubscribeMethod","isSubscribeParams","assertType","isPublishMethod","isPublishParams","isUnsubscribeMethod","isUnsubscribeParams","isSubscriptionMethod","isSubscriptionParams"],"mappings":";;;;;;;;;;;;;;;;;;;AAAO,SAAS,EAAA,CAAA,EAAA,CAAA;QAAA,IAAA,iEAAA,EAAWA,CAAAA,CAAAA,CAAUC,CAAaC,CAAAA,CAAAA,CAAO;IAAA,IAAA,CAAA,CAAA,CAAA,CAAU,CAAA,CACjE,GAAA,EAAI,CAACF,CAAIC,CAAAA,CAAG,CAAK,CAAA,CAAA,EAAA,KAAA,GAAOD,EAAIC,CAAG,CAAA,EAAA,CAAMC,CACnC,CAAA,CAAA,KAAM,CAAA,EAAI,KAAA,CAAM,CAAuBD,cAAAA,KAAAA,EAAAA,CAAAA,EAAAA;AAAAA;AAAAA,MAAAA,CAAY,CAEvD,CAEO,EAAA,CAAA,EAAA,CAAA;IAAA,EAAS,EAAA,IAAA,CAAA;IAAA,OAAA,EAAA,CAAkBE,CAAAA,CAAAA,CAAaC,CAAoB,CAAA,CACjE,CAAA,CAAA,GAAIC;QAAAA,CAAU,GACd,CAAA,KAAA,CAAA,IAAAD,CAAAA,CAAS;IAAA,IAAA;AAAA;AAAA,CAASH,CAAAA,CAAAA,EAAQ,CACTA,CAAAA,EAAAA,EAAOE,CAEpBE,EAAAA,CAAAA,CAAAA;IAAAA,CAAU,CAEd,CAAA,EAAA,CAAC,CACMA,CAAAA,CACT,CAEO,GAAA,MAAS,CAAA,CAAA,KAAA,EAAA,MAAA,KAAA,IAAA,EAAqBF,CAAAA,CAAAA,CAAaG,EAAyB,CACzE,GAAA,CAAA,GAAO,KAAM,CAAA,KAAA;AAAA;AAAA,EAAA,CAAQH,CAAM,CAAA,CAAIA,CAAO,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA;IAAA,CAAWG,EAAS,IAAA,EAAO,CAAA,GAAA,CAAA,CAAKH,CAAM,CAAA,CAAE,EAAA,CAAA,KAAWG,EAAAA,CAAAA,CAC3F,CAEO,GAAA,IAAA,IAAA,EAAS,KAAA,IAAA,CAAA,GAAA,MAAA,IAAA;AAAA;AAAA,CAAwBH,CAAaI,CAAAA,CAAAA,CAA4B,CAC/E,GAAA,EAAA,CAAA,EAAO,CAAA,EAAA,CAAA;IAAM,CAAA,MAAA,CAAA,CAAA,CAAQJ,CAAM,CAAA,CACvBA,CAAO,CAAA,CAAA,GAAA,EAAA,GAAA,EAAUI,CACjB,CAAA,IAAA,IAAA,CAAO,CAAA,GAAA,CAAKJ,CAAAA,CAAM,CAAE,CAAA,GAAA,CAAA,IAAA,EAAUI,CACpC,EAEO,KAAA,CAAA;AAAA;AAAA,GAAS,MAAA,EAAA,CAAA,EAAA,CAAYJ;YAAAA,CAAAA,gEAAaC,CAAoBI,CAAAA,CAAAA,CAAoB;IAK/E,MAAA,CAAA,GAJc,CAACA,CAAS,CAAA,IAAA,CAAA,CAAA,CAEpB;IAAA,OAAA,CAAA,CAAA,EAAA,MAAA,GAAA,CAAqBL,CAAAA,CAAAA,CAAQC,CAAS,CAAA,CAAA,GAAA,EAAM,CAC5C,CAAA,OAAA,OAAA,EAAA,IAAA,GAAA,EAAA,CAAwBD,EAAQC,CAAS,CAAA,IAAA;AAAM;AAE5C,EAAA,OAAA,EAAA,CAAA;IAAA,KAAA,CAAkBD,CAAQC,CAAAA,CAAQ,CADd,CAAA,CAAA,CAE7B,CAEgB,GAAA,KAAA,EAAA,CAAA,CAAA,MAAA;AAAA;AAAA,KAAA,CAAeK,CAAgBC,CAAAA,CAAAA,CAAkBC,CAAY,CAAA;IAAA,CAAA,CAAK,CAChF,IAAA,EAAMC,GAAQH,CAAO,CAAA,KAAA,CAAME,CAAS,CAAA,CACpC;AAAA;AAAA,KAAOC,CAAAA,CAAMA,CAAM,CAAA,EAAA,CAAA;IAAA,CAAA,CAAS,CAAC,CAAE,CAAA,EAAA,EAAA,GAAO;QAAA;KAAA,EAAA,EAAA;AAAA;AAAkBF,GAAAA,CAAAA,CAAS,IAAK,EAAA,CAAE;IAAA,OAAA,EAAA,EAC1E,MAAA,KAAA,EAAA,EAAA,MAAA;AAAA;AAAA,SAAA,EAAA,CAAA;IAAA,OAAA,EAAA,GAAA;AAAA;AAAA,SAAA,EAAA,CAAA;IAAA,OAAA,EAAA,GAAA;QAAA;QAAA;QAAA;KAAA,EAAA;QAAA;QAAA;KAAA;AAAA;AAAA,SAAA,EAAA,CAAA;IAAA,OAAA,EAAA,EAAA,MAAA,KAAA,EAAA,EAAA,MAAA;AAAA;AAAA,SAAA,EAAA,CAAA;IAAA,OAAA,EAAA,GAAA;AAAA;AAAA,SAAA,EAAA,CAAA;IAAA,OAAA,EAAA,GAAA;QAAA;QAAA;KAAA,EAAA,EAAA;AAAA;AAAA,SAAA,EAAA,CAAA;IAAA,OAAA,EAAA,EAAA,MAAA,KAAA,EAAA,EAAA,MAAA;AAAA;AAAA,SAAA,EAAA,CAAA;IAAA,OAAA,EAAA,GAAA;AAAA;AAAA,SAAA,EAAA,CAAA;IAAA,OAAA,EAAA,GAAA;QAAA;QAAA;KAAA,EAAA,EAAA;AAAA;AAAA,SAAA,EAAA,CAAA;IAAA,IAAA,CAAA,EAAA,EAAA,MAAA,GAAA,MAAA,IAAA,MAAA;IAAA,IAAA,CAAA,EAAA,EAAA,MAAA,GAAA,MAAA,IAAA,MAAA;IAAA,MAAA,IAAA,EAAA,MAAA;IAAA,OAAA,EAAA,GAAA,UAAA;AAAA;AAAA,SAAA,EAAA,CAAA;IAAA,IAAA,CAAA,EAAA,EAAA,MAAA,GAAA,MAAA,IAAA,MAAA;IAAA,IAAA,CAAA,EAAA,EAAA,MAAA,GAAA,MAAA,IAAA,MAAA;IAAA,MAAA,IAAA,EAAA,MAAA;IAAA,OAAA,EAAA,GAAA,UAAA,EAAA,GAAA,YAAA,EAAA,GAAA,OAAA,WAAA;AAAA;AAAA,SAAA,EAAA,CAAA;IAAA,IAAA,CAAA,EAAA,EAAA,MAAA,GAAA,MAAA,IAAA,MAAA;IAAA,IAAA,CAAA,EAAA,EAAA,MAAA,GAAA,MAAA,IAAA,MAAA;IAAA,MAAA,IAAA,EAAA,MAAA;IAAA,OAAA,EAAA,GAAA,OAAA;AAAA;AAAA,SAAA,EAAA,CAAA;IAAA,IAAA,CAAA,EAAA,EAAA,MAAA,GAAA,MAAA,IAAA,MAAA;IAAA,IAAA,CAAA,EAAA,EAAA,MAAA,GAAA,MAAA,IAAA,MAAA;IAAA,MAAA,IAAA,EAAA,MAAA;IAAA,OAAA,EAAA,GAAA,OAAA,EAAA,GAAA,SAAA;AAAA;AAAA,MAAA,IAAA;IAAA,MAAA;QAAA,SAAA;QAAA,cAAA;QAAA,WAAA;QAAA,gBAAA;QAAA,cAAA;QAAA,aAAA;QAAA,kBAAA;QAAA,oBAAA;IAAA;IAAA,KAAA;QAAA,SAAA;QAAA,cAAA;QAAA,WAAA;QAAA,gBAAA;QAAA,cAAA;QAAA,aAAA;QAAA,kBAAA;QAAA,oBAAA;IAAA;IAAA,SAAA;QAAA,SAAA;QAAA,cAAA;QAAA,WAAA;QAAA,gBAAA;QAAA,cAAA;QAAA,aAAA;QAAA,kBAAA;QAAA,oBAAA;IAAA;AAAA","debugId":null}},
    {"offset": {"line": 3405, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/utils/dist/index.es.js","sources":["file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/utils/src/caip.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/utils/src/misc.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/hashes/esm/_assert.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/hashes/esm/_u64.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/hashes/esm/crypto.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/hashes/esm/utils.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/hashes/esm/sha3.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/utils/src/signatures.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/utils/src/cacao.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/ciphers/esm/_assert.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/ciphers/esm/utils.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/ciphers/esm/_arx.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/ciphers/esm/_poly1305.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/ciphers/esm/chacha.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/hashes/esm/hmac.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/hashes/esm/hkdf.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/hashes/esm/_md.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/hashes/esm/sha256.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/curves/esm/abstract/utils.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/curves/esm/abstract/modular.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/curves/esm/abstract/curve.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/curves/esm/abstract/edwards.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/curves/esm/abstract/montgomery.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/curves/esm/ed25519.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/curves/esm/abstract/weierstrass.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/curves/esm/_shortw_utils.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/%40noble/curves/esm/p256.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/utils/src/crypto.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/utils/src/relay.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/utils/src/uri.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/utils/src/namespaces.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/utils/src/errors.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/utils/src/validators.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/utils/src/network.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/utils/src/memoryStore.ts"],"sourcesContent":["import { SessionTypes, ProposalTypes } from \"@walletconnect/types\";\n\ninterface ChainIdParams {\n  namespace: string;\n  reference: string;\n}\n\ninterface AccountIdParams extends ChainIdParams {\n  address: string;\n}\n\nconst CAIP_DELIMITER = \":\";\n\nexport function parseChainId(chain: string): ChainIdParams {\n  const [namespace, reference] = chain.split(CAIP_DELIMITER);\n  return { namespace, reference };\n}\n\nexport function formatChainId(params: ChainIdParams): string {\n  const { namespace, reference } = params;\n  return [namespace, reference].join(CAIP_DELIMITER);\n}\n\nexport function parseAccountId(account: string): AccountIdParams {\n  const [namespace, reference, address] = account.split(CAIP_DELIMITER);\n  return { namespace, reference, address };\n}\n\nexport function formatAccountId(params: AccountIdParams): string {\n  const { namespace, reference, address } = params;\n  return [namespace, reference, address].join(CAIP_DELIMITER);\n}\n\nexport function getUniqueValues(array: string[], parser: (str: string) => string): string[] {\n  const unique: string[] = [];\n  array.forEach((str) => {\n    const value = parser(str);\n    if (!unique.includes(value)) unique.push(value);\n  });\n  return unique;\n}\n\nexport function getAddressFromAccount(account: string) {\n  const { address } = parseAccountId(account);\n  return address;\n}\n\nexport function getChainFromAccount(account: string) {\n  const { namespace, reference } = parseAccountId(account);\n  const chain = formatChainId({ namespace, reference });\n  return chain;\n}\n\nexport function formatAccountWithChain(address: string, chain: string) {\n  const { namespace, reference } = parseChainId(chain);\n  const account = formatAccountId({ namespace, reference, address });\n  return account;\n}\n\nexport function getAddressesFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getAddressFromAccount);\n}\n\nexport function getChainsFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getChainFromAccount);\n}\n\nexport function getAccountsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const accounts: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    accounts.push(...ns.accounts);\n  });\n  return accounts;\n}\n\nexport function getChainsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    chains.push(...getChainsFromAccounts(ns.accounts));\n  });\n  return chains;\n}\n\nexport function getChainsFromRequiredNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(requiredNamespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = requiredNamespaces[key];\n    chains.push(...getChainsFromNamespace(key, ns));\n  });\n  return chains;\n}\n\nexport function getChainsFromNamespace(\n  namespace: string,\n  namespaceProps: ProposalTypes.BaseRequiredNamespace,\n) {\n  // check if chainId is provided in the key as `eip155:1` or in the namespace as chains[]\n  return namespace.includes(\":\") ? [namespace] : namespaceProps.chains || [];\n}\n","import { detect } from \"detect-browser\";\nimport { FIVE_MINUTES, fromMiliseconds, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  SignClientTypes,\n  RelayerClientMetadata,\n  EngineTypes,\n  RelayerTypes,\n} from \"@walletconnect/types\";\nimport { getDocument, getLocation, getNavigator } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata } from \"@walletconnect/window-metadata\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-utils\";\nimport { IKeyValueStorage } from \"@walletconnect/keyvaluestorage\";\n\n// -- constants -----------------------------------------//\nexport const REACT_NATIVE_PRODUCT = \"ReactNative\";\n\nexport const ENV_MAP = {\n  reactNative: \"react-native\",\n  node: \"node\",\n  browser: \"browser\",\n  unknown: \"unknown\",\n};\n\nexport const EMPTY_SPACE = \" \";\n\nexport const COLON = \":\";\n\nexport const SLASH = \"/\";\n\nexport const DEFAULT_DEPTH = 2;\n\nexport const ONE_THOUSAND = 1000;\n\nexport const SDK_TYPE = \"js\";\n\n// -- env -----------------------------------------------//\n\nexport function isNode(): boolean {\n  return (\n    typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\"\n  );\n}\n\nexport function isReactNative(): boolean {\n  return !getDocument() && !!getNavigator() && navigator.product === REACT_NATIVE_PRODUCT;\n}\n\nexport function isAndroid(): boolean {\n  return (\n    isReactNative() &&\n    typeof global !== \"undefined\" &&\n    typeof (global as any)?.Platform !== \"undefined\" &&\n    (global as any)?.Platform.OS === \"android\"\n  );\n}\n\nexport function isIos(): boolean {\n  return (\n    isReactNative() &&\n    typeof global !== \"undefined\" &&\n    typeof (global as any)?.Platform !== \"undefined\" &&\n    (global as any)?.Platform.OS === \"ios\"\n  );\n}\n\nexport function isBrowser(): boolean {\n  return !isNode() && !!getNavigator() && !!getDocument();\n}\n\nexport function getEnvironment(): string {\n  if (isReactNative()) return ENV_MAP.reactNative;\n  if (isNode()) return ENV_MAP.node;\n  if (isBrowser()) return ENV_MAP.browser;\n  return ENV_MAP.unknown;\n}\n\nexport function getAppId(): string | undefined {\n  try {\n    if (\n      isReactNative() &&\n      typeof global !== \"undefined\" &&\n      typeof (global as any)?.Application !== \"undefined\"\n    ) {\n      return (global as any).Application?.applicationId;\n    }\n    return undefined;\n  } catch {\n    return undefined;\n  }\n}\n\n// -- query -----------------------------------------------//\n\nexport function appendToQueryString(\n  queryString: string,\n  newQueryParams: Record<string, any>,\n): string {\n  const urlSearchParams = new URLSearchParams(queryString);\n\n  for (const key of Object.keys(newQueryParams).sort()) {\n    if (newQueryParams.hasOwnProperty(key)) {\n      const value = newQueryParams[key];\n      if (value !== undefined) {\n        urlSearchParams.set(key, value);\n      }\n    }\n  }\n\n  return urlSearchParams.toString();\n}\n\n// -- metadata ----------------------------------------------//\n\nexport function populateAppMetadata(metadata?: SignClientTypes.Metadata): SignClientTypes.Metadata {\n  const appMetadata = getAppMetadata();\n  try {\n    if (metadata?.url && appMetadata.url) {\n      if (new URL(metadata.url).host !== new URL(appMetadata.url).host) {\n        console.warn(\n          `The configured WalletConnect 'metadata.url':${metadata.url} differs from the actual page url:${appMetadata.url}. This is probably unintended and can lead to issues.`,\n        );\n        metadata.url = appMetadata.url;\n      }\n    }\n\n    if (metadata?.icons?.length && metadata.icons.length > 0) {\n      metadata.icons = metadata.icons.filter((icon) => icon !== \"\");\n    }\n\n    return {\n      ...appMetadata,\n      ...metadata,\n      url: metadata?.url || appMetadata.url,\n      name: metadata?.name || appMetadata.name,\n      description: metadata?.description || appMetadata.description,\n      icons:\n        metadata?.icons?.length && metadata.icons.length > 0 ? metadata.icons : appMetadata.icons,\n    };\n  } catch (error) {\n    console.warn(\"Error populating app metadata\", error);\n    return metadata || appMetadata;\n  }\n}\n\nexport function getAppMetadata(): SignClientTypes.Metadata {\n  return (\n    getWindowMetadata() || {\n      name: \"\",\n      description: \"\",\n      url: \"\",\n      icons: [\"\"],\n    }\n  );\n}\n\nexport function getRelayClientMetadata(protocol: string, version: number): RelayerClientMetadata {\n  const env = getEnvironment();\n\n  const metadata: RelayerClientMetadata = { protocol, version, env };\n  if (env === \"browser\") {\n    metadata.host = getLocation()?.host || \"unknown\";\n  }\n  return metadata;\n}\n\n// -- rpcUrl ----------------------------------------------//\n\nexport function getJavascriptOS() {\n  const env = getEnvironment();\n  // global.Platform is set by react-native-compat\n  if (\n    env === ENV_MAP.reactNative &&\n    typeof global !== \"undefined\" &&\n    typeof (global as any)?.Platform !== \"undefined\"\n  ) {\n    const { OS, Version } = (global as any).Platform;\n    return [OS, Version].join(\"-\");\n  }\n\n  const info = detect();\n  if (info === null) return \"unknown\";\n  const os = info.os ? info.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  if (info.type === \"browser\") {\n    return [os, info.name, info.version].join(\"-\");\n  }\n  return [os, info.version].join(\"-\");\n}\n\nexport function getJavascriptID() {\n  const env = getEnvironment();\n  return env === ENV_MAP.browser ? [env, getLocation()?.host || \"unknown\"].join(\":\") : env;\n}\n\nexport function formatUA(protocol: string, version: number, sdkVersion: string) {\n  const os = getJavascriptOS();\n  const id = getJavascriptID();\n  return [[protocol, version].join(\"-\"), [SDK_TYPE, sdkVersion].join(\"-\"), os, id].join(\"/\");\n}\nconsole;\n\nexport function formatRelayRpcUrl({\n  protocol,\n  version,\n  relayUrl,\n  sdkVersion,\n  auth,\n  projectId,\n  useOnCloseEvent,\n  bundleId,\n  packageName,\n}: RelayerTypes.RpcUrlParams) {\n  const splitUrl = relayUrl.split(\"?\");\n  const ua = formatUA(protocol, version, sdkVersion);\n  const params = {\n    auth,\n    ua,\n    projectId,\n    useOnCloseEvent: useOnCloseEvent || undefined,\n    packageName: packageName || undefined,\n    bundleId: bundleId || undefined,\n  };\n  const queryString = appendToQueryString(splitUrl[1] || \"\", params);\n  return splitUrl[0] + \"?\" + queryString;\n}\n\nexport function getHttpUrl(url: string) {\n  // regex from https://stackoverflow.com/questions/3883871/regexp-to-grab-protocol-from-url\n  const matches = url.match(/^[^:]+(?=:\\/\\/)/gi) || [];\n  let protocol = matches[0];\n  const domain = typeof protocol !== \"undefined\" ? url.split(\"://\")[1] : url;\n  protocol = protocol === \"wss\" ? \"https\" : \"http\";\n  return [protocol, domain].join(\"://\");\n}\n\n// -- assert ------------------------------------------------- //\n\nexport function assertType(obj: any, key: string, type: string) {\n  // eslint-disable-next-line valid-typeof\n  if (!obj[key] || typeof obj[key] !== type) {\n    throw new Error(`Missing or invalid \"${key}\" param`);\n  }\n}\n\n// -- context ------------------------------------------------- //\n\nexport function parseContextNames(context: string, depth = DEFAULT_DEPTH) {\n  return getLastItems(context.split(SLASH), depth);\n}\n\nexport function formatMessageContext(context: string): string {\n  return parseContextNames(context).join(EMPTY_SPACE);\n}\n\n// -- array ------------------------------------------------- //\n\nexport function hasOverlap(a: any[], b: any[]): boolean {\n  const matches = a.filter((x) => b.includes(x));\n  return matches.length === a.length;\n}\n\nexport function getLastItems(arr: any[], depth = DEFAULT_DEPTH): any[] {\n  return arr.slice(Math.max(arr.length - depth, 0));\n}\n\n// -- map ------------------------------------------------- //\n\nexport function mapToObj<T = any>(map: Map<string, T>): Record<string, T> {\n  return Object.fromEntries(map.entries());\n}\n\nexport function objToMap<T = any>(obj: Record<string, T>): Map<string, T> {\n  return new Map<string, T>(Object.entries<T>(obj));\n}\n\nexport function mapEntries<A = any, B = any>(\n  obj: Record<string, A>,\n  cb: (x: A) => B,\n): Record<string, B> {\n  const res: any = {};\n  Object.keys(obj).forEach((key) => {\n    res[key] = cb(obj[key]);\n  });\n  return res;\n}\n\n// -- enum ------------------------------------------------- //\n\n// source: https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275\nexport const enumify = <T extends { [index: string]: U }, U extends string>(x: T): T => x;\n\n// -- string ------------------------------------------------- //\n\nexport function capitalizeWord(word: string) {\n  return word.trim().replace(/^\\w/, (c) => c.toUpperCase());\n}\n\nexport function capitalize(str: string) {\n  return str\n    .split(EMPTY_SPACE)\n    .map((w) => capitalizeWord(w))\n    .join(EMPTY_SPACE);\n}\n\n// -- promises --------------------------------------------- //\nexport function createDelayedPromise<T>(\n  expiry: number = FIVE_MINUTES,\n  expireErrorMessage?: string,\n) {\n  const timeout = toMiliseconds(expiry || FIVE_MINUTES);\n  let cacheResolve: undefined | ((value: T | PromiseLike<T>) => void);\n  let cacheReject: undefined | ((value?: ErrorResponse) => void);\n  let cacheTimeout: undefined | NodeJS.Timeout;\n  let result: Promise<Awaited<T>> | Promise<T> | undefined;\n\n  const done = () =>\n    new Promise<T>((promiseResolve, promiseReject) => {\n      if (result) {\n        return promiseResolve(result);\n      }\n      cacheTimeout = setTimeout(() => {\n        const err = new Error(expireErrorMessage);\n        result = Promise.reject(err);\n        promiseReject(err);\n      }, timeout);\n      cacheResolve = promiseResolve;\n      cacheReject = promiseReject;\n    });\n  const resolve = (value?: T) => {\n    if (cacheTimeout && cacheResolve) {\n      clearTimeout(cacheTimeout);\n      cacheResolve(value as T);\n      result = Promise.resolve(value) as Promise<Awaited<T>>;\n    }\n  };\n  const reject = (value?: ErrorResponse) => {\n    if (cacheTimeout && cacheReject) {\n      clearTimeout(cacheTimeout);\n      cacheReject(value);\n    }\n  };\n\n  return {\n    resolve,\n    reject,\n    done,\n  };\n}\n\nexport function createExpiringPromise<T>(\n  promise: Promise<T>,\n  expiry: number,\n  expireErrorMessage?: string,\n) {\n  return new Promise(async (resolve, reject) => {\n    const timeout = setTimeout(() => reject(new Error(expireErrorMessage)), expiry);\n    try {\n      const result = await promise;\n      resolve(result);\n    } catch (error) {\n      reject(error);\n    }\n    clearTimeout(timeout);\n  });\n}\n\n// -- expirer --------------------------------------------- //\n\nexport function formatExpirerTarget(type: \"topic\" | \"id\", value: string | number): string {\n  if (typeof value === \"string\" && value.startsWith(`${type}:`)) return value;\n  if (type.toLowerCase() === \"topic\") {\n    if (typeof value !== \"string\")\n      throw new Error(`Value must be \"string\" for expirer target type: topic`);\n    return `topic:${value}`;\n  } else if (type.toLowerCase() === \"id\") {\n    if (typeof value !== \"number\")\n      throw new Error(`Value must be \"number\" for expirer target type: id`);\n    return `id:${value}`;\n  }\n  throw new Error(`Unknown expirer target type: ${type}`);\n}\n\nexport function formatTopicTarget(topic: string): string {\n  return formatExpirerTarget(\"topic\", topic);\n}\n\nexport function formatIdTarget(id: number): string {\n  return formatExpirerTarget(\"id\", id);\n}\n\nexport function parseExpirerTarget(target: string) {\n  const [type, value] = target.split(\":\");\n  const parsed: { id?: number; topic?: string } = { id: undefined, topic: undefined };\n  if (type === \"topic\" && typeof value === \"string\") {\n    parsed.topic = value;\n  } else if (type === \"id\" && Number.isInteger(Number(value))) {\n    parsed.id = Number(value);\n  } else {\n    throw new Error(`Invalid target, expected id:number or topic:string, got ${type}:${value}`);\n  }\n\n  return parsed;\n}\n\nexport function calcExpiry(ttl: number, now?: number): number {\n  return fromMiliseconds((now || Date.now()) + toMiliseconds(ttl));\n}\n\nexport function isExpired(expiry: number) {\n  return Date.now() >= toMiliseconds(expiry);\n}\n\n// -- events ---------------------------------------------- //\n\nexport function engineEvent(event: EngineTypes.Event, id?: number | string | undefined) {\n  return `${event}${id ? `:${id}` : \"\"}`;\n}\n\nexport function mergeArrays<T>(a: T[] = [], b: T[] = []): T[] {\n  return [...new Set([...a, ...b])];\n}\n\nexport async function handleDeeplinkRedirect({\n  id,\n  topic,\n  wcDeepLink,\n}: {\n  id: number;\n  topic: string;\n  wcDeepLink: string;\n}) {\n  try {\n    if (!wcDeepLink) return;\n\n    const json = typeof wcDeepLink === \"string\" ? JSON.parse(wcDeepLink) : wcDeepLink;\n    const deeplink = json?.href;\n    if (typeof deeplink !== \"string\") return;\n    const link = formatDeeplinkUrl(deeplink, id, topic);\n    const env = getEnvironment();\n\n    if (env === ENV_MAP.browser) {\n      if (!getDocument()?.hasFocus()) {\n        console.warn(\"Document does not have focus, skipping deeplink.\");\n        return;\n      }\n\n      openDeeplink(link);\n    } else if (env === ENV_MAP.reactNative) {\n      // global.Linking is set by react-native-compat\n      if (typeof (global as any)?.Linking !== \"undefined\") {\n        await (global as any).Linking.openURL(link);\n      }\n    }\n  } catch (err) {\n    // Silent error, just log in console\n    // eslint-disable-next-line no-console\n    console.error(err);\n  }\n}\n\nexport function formatDeeplinkUrl(deeplink: string, requestId: number, sessionTopic: string) {\n  const payload = `requestId=${requestId}&sessionTopic=${sessionTopic}`;\n  if (deeplink.endsWith(\"/\")) deeplink = deeplink.slice(0, -1);\n  let link = `${deeplink}`;\n  if (deeplink.startsWith(\"https://t.me\")) {\n    const startApp = deeplink.includes(\"?\") ? \"&startapp=\" : \"?startapp=\";\n    link = `${link}${startApp}${toBase64(payload, true)}`;\n  } else {\n    link = `${link}/wc?${payload}`;\n  }\n  return link;\n}\n\nexport function openDeeplink(url: string) {\n  let target = \"_self\";\n  if (isIframe()) {\n    target = \"_top\";\n  } else if (isTelegram() || url.startsWith(\"https://\") || url.startsWith(\"http://\")) {\n    target = \"_blank\";\n  }\n\n  window.open(url, target, \"noreferrer noopener\");\n}\n\nexport async function getDeepLink(storage: IKeyValueStorage, key: string) {\n  let link: string | undefined = \"\";\n  try {\n    if (isBrowser()) {\n      link = localStorage.getItem(key) as string;\n      if (link) return link;\n    }\n    link = await storage.getItem(key);\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error(err);\n  }\n  return link;\n}\n\nexport function getCommonValuesInArrays<T = string | number | boolean>(arr1: T[], arr2: T[]): T[] {\n  return arr1.filter((value) => arr2.includes(value));\n}\n\nexport function getSearchParamFromURL(url: string, param: any) {\n  const include = url.includes(param);\n  if (!include) return null;\n  const params = url.split(/([&,?,=])/);\n  const index = params.indexOf(param);\n  const value = params[index + 2];\n  return value;\n}\n\nexport function uuidv4() {\n  if (typeof crypto !== \"undefined\" && crypto?.randomUUID) {\n    return crypto.randomUUID();\n  }\n\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/gu, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n\n    return v.toString(16);\n  });\n}\n\nexport function isTestRun() {\n  return typeof process !== \"undefined\" && process.env.IS_VITEST === \"true\";\n}\n\nexport function isTelegram() {\n  return (\n    typeof window !== \"undefined\" &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (Boolean((window as any).TelegramWebviewProxy) ||\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      Boolean((window as any).Telegram) ||\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      Boolean((window as any).TelegramWebviewProxyProto))\n  );\n}\n\nexport function isIframe() {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return false;\n  }\n}\n\nexport function toBase64(input: string, removePadding = false): string {\n  const encoded = Buffer.from(input).toString(\"base64\");\n  return removePadding ? encoded.replace(/[=]/g, \"\") : encoded;\n}\n\nexport function fromBase64(encodedString: string): string {\n  return Buffer.from(encodedString, \"base64\").toString(\"utf-8\");\n}\n\nexport function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","/**\n * Internal assertion helpers.\n * @module\n */\n/** Asserts something is positive integer. */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Is number an Uint8Array? Copied from utils for perf. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\nexport { anumber, abytes, ahash, aexists, aoutput };\n//# sourceMappingURL=_assert.js.map","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","export const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n// Cast array to different type\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n// Cast array to view\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nexport function byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const byteSwapIfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Convert JS string to byte array.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('utf8ToBytes expected string, got ' + typeof str);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n/** For runtime check if class implements interface */\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** Wraps hash function, creating an interface on top of it */\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\nimport { abytes, aexists, anumber, aoutput } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport { byteSwap32, Hash, isLE, toBytes, u32, wrapConstructor, wrapXOFConstructorWithOpts, } from './utils.js';\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nexport function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\n/** Keccak sponge function. */\nexport class Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        anumber(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        // 0 < blockLen < 200\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = u32(this.state);\n    }\n    keccak() {\n        if (!isLE)\n            byteSwap32(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!isLE)\n            byteSwap32(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        aexists(this);\n        const { blockLen, state } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        aexists(this, false);\n        abytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        anumber(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        aoutput(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\n/** SHA3-224 hash function. */\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/** SHA3-256 hash function. Different from keccak-256. */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\n/** SHA3-384 hash function. */\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\n/** SHA3-512 hash function. */\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\n/** keccak-224 hash function. */\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/** keccak-256 hash function. Different from SHA3-256. */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\n/** keccak-384 hash function. */\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\n/** keccak-512 hash function. */\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\n/** SHAKE128 XOF with 128-bit security. */\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\n/** SHAKE256 XOF with 256-bit security. */\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map","import { keccak_256 } from \"@noble/hashes/sha3\";\nimport { recoverAddress } from \"viem\";\nimport { AuthTypes } from \"@walletconnect/types\";\nimport bs58 from \"bs58\";\n\nimport { parseChainId } from \"./caip\";\n\nconst DEFAULT_RPC_URL = \"https://rpc.walletconnect.org/v1\";\n\nexport function hashEthereumMessage(message: string) {\n  const prefix = `\\x19Ethereum Signed Message:\\n${message.length}`;\n  const prefixedMessage = new TextEncoder().encode(prefix + message);\n  return \"0x\" + Buffer.from(keccak_256(prefixedMessage)).toString(\"hex\");\n}\n\nexport async function verifySignature(\n  address: string,\n  reconstructedMessage: string,\n  cacaoSignature: AuthTypes.CacaoSignature,\n  chainId: string,\n  projectId: string,\n  baseRpcUrl?: string,\n): Promise<boolean> {\n  // Determine if this signature is from an EOA or a contract.\n  switch (cacaoSignature.t) {\n    case \"eip191\":\n      return await isValidEip191Signature(address, reconstructedMessage, cacaoSignature.s);\n    case \"eip1271\":\n      return await isValidEip1271Signature(\n        address,\n        reconstructedMessage,\n        cacaoSignature.s,\n        chainId,\n        projectId,\n        baseRpcUrl,\n      );\n      break;\n    default:\n      throw new Error(\n        `verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${cacaoSignature.t}`,\n      );\n  }\n}\n\nexport async function isValidEip191Signature(\n  address: string,\n  message: string,\n  signature: string,\n): Promise<boolean> {\n  const recoveredAddress = await recoverAddress({\n    hash: hashEthereumMessage(message) as `0x${string}`,\n    signature: signature as `0x${string}`,\n  });\n  return recoveredAddress.toLowerCase() === address.toLowerCase();\n}\n\nexport async function isValidEip1271Signature(\n  address: string,\n  reconstructedMessage: string,\n  signature: string,\n  chainId: string,\n  projectId: string,\n  baseRpcUrl?: string,\n) {\n  const parsedChain = parseChainId(chainId);\n  if (!parsedChain.namespace || !parsedChain.reference) {\n    throw new Error(\n      `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${chainId}`,\n    );\n  }\n  try {\n    const eip1271MagicValue = \"0x1626ba7e\";\n    const dynamicTypeOffset = \"0000000000000000000000000000000000000000000000000000000000000040\";\n    const dynamicTypeLength = \"0000000000000000000000000000000000000000000000000000000000000041\";\n    const nonPrefixedSignature = signature.substring(2);\n    const nonPrefixedHashedMessage = hashEthereumMessage(reconstructedMessage).substring(2);\n\n    const data =\n      eip1271MagicValue +\n      nonPrefixedHashedMessage +\n      dynamicTypeOffset +\n      dynamicTypeLength +\n      nonPrefixedSignature;\n    const response = await fetch(\n      `${baseRpcUrl || DEFAULT_RPC_URL}/?chainId=${chainId}&projectId=${projectId}`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          id: generateJsonRpcId(),\n          jsonrpc: \"2.0\",\n          method: \"eth_call\",\n          params: [{ to: address, data }, \"latest\"],\n        }),\n      },\n    );\n    const { result } = await response.json();\n    if (!result) return false;\n\n    // Remove right-padded zeros from result to get only the concrete recovered value.\n    const recoveredValue = result.slice(0, eip1271MagicValue.length);\n    return recoveredValue.toLowerCase() === eip1271MagicValue.toLowerCase();\n  } catch (error: any) {\n    // eslint-disable-next-line no-console\n    console.error(\"isValidEip1271Signature: \", error);\n    return false;\n  }\n}\n\nfunction generateJsonRpcId() {\n  return Date.now() + Math.floor(Math.random() * 1000);\n}\n\nexport function extractSolanaTransactionId(solanaTransaction: string): string {\n  const binary = atob(solanaTransaction);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n\n  // Check signature count (first byte)\n  const signatureCount = bytes[0];\n  if (signatureCount === 0) {\n    throw new Error(\"No signatures found\");\n  }\n\n  // Verify we have enough bytes for all signatures\n  // Each signature is 64 bytes\n  const signatureEndPos = 1 + signatureCount * 64;\n  if (bytes.length < signatureEndPos) {\n    throw new Error(\"Transaction data too short for claimed signature count\");\n  }\n\n  // A transaction must have at least some minimum length\n  if (bytes.length < 100) {\n    throw new Error(\"Transaction too short\");\n  }\n\n  const transactionBuffer = Buffer.from(solanaTransaction, \"base64\");\n\n  const signatureBuffer = transactionBuffer.slice(1, 65);\n\n  return bs58.encode(signatureBuffer);\n}\n","import { AuthTypes } from \"@walletconnect/types\";\nimport { getCommonValuesInArrays } from \"./misc\";\nimport { verifySignature } from \"./signatures\";\nconst didPrefix = \"did:pkh:\";\nexport const getDidAddressSegments = (iss: string) => {\n  return iss?.split(\":\");\n};\n\nexport const getDidChainId = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return iss.includes(didPrefix) ? segments[3] : segments[1];\n  }\n  return undefined;\n};\n\nexport const getNamespacedDidChainId = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments[2] + \":\" + segments[3];\n  }\n  return undefined;\n};\n\nexport const getDidAddress = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments.pop();\n  }\n  return undefined;\n};\n\nexport async function validateSignedCacao(params: { cacao: AuthTypes.Cacao; projectId?: string }) {\n  const { cacao, projectId } = params;\n  const { s: signature, p: payload } = cacao;\n  const reconstructed = formatMessage(payload, payload.iss);\n  const walletAddress = getDidAddress(payload.iss) as string;\n  const isValid = await verifySignature(\n    walletAddress,\n    reconstructed,\n    signature,\n    getNamespacedDidChainId(payload.iss) as string,\n    projectId as string,\n  );\n\n  return isValid;\n}\n\nexport const formatMessage = (cacao: AuthTypes.FormatMessageParams, iss: string) => {\n  const header = `${cacao.domain} wants you to sign in with your Ethereum account:`;\n  const walletAddress = getDidAddress(iss);\n\n  if (!cacao.aud && !cacao.uri) {\n    throw new Error(\"Either `aud` or `uri` is required to construct the message\");\n  }\n\n  let statement = cacao.statement || undefined;\n  const uri = `URI: ${cacao.aud || cacao.uri}`;\n  const version = `Version: ${cacao.version}`;\n  const chainId = `Chain ID: ${getDidChainId(iss)}`;\n  const nonce = `Nonce: ${cacao.nonce}`;\n  const issuedAt = `Issued At: ${cacao.iat}`;\n  const expirationTime = cacao.exp ? `Expiration Time: ${cacao.exp}` : undefined;\n  const notBefore = cacao.nbf ? `Not Before: ${cacao.nbf}` : undefined;\n  const requestId = cacao.requestId ? `Request ID: ${cacao.requestId}` : undefined;\n  const resources = cacao.resources\n    ? `Resources:${cacao.resources.map((resource) => `\\n- ${resource}`).join(\"\")}`\n    : undefined;\n  const recap = getRecapFromResources(cacao.resources);\n  if (recap) {\n    const decoded = decodeRecap(recap);\n    statement = formatStatementFromRecap(statement, decoded);\n  }\n\n  const message = [\n    header,\n    walletAddress,\n    ``,\n    statement,\n    ``,\n    uri,\n    version,\n    chainId,\n    nonce,\n    issuedAt,\n    expirationTime,\n    notBefore,\n    requestId,\n    resources,\n  ]\n    .filter((val) => val !== undefined && val !== null) // remove unnecessary empty lines\n    .join(\"\\n\");\n\n  return message;\n};\n\nexport function buildAuthObject(\n  requestPayload: AuthTypes.PayloadParams,\n  signature: AuthTypes.CacaoSignature,\n  iss: string,\n) {\n  if (!iss.includes(\"did:pkh:\")) {\n    iss = `did:pkh:${iss}`;\n  }\n\n  const authObject: AuthTypes.Cacao = {\n    h: {\n      t: \"caip122\",\n    },\n    p: {\n      iss,\n      domain: requestPayload.domain,\n      aud: requestPayload.aud,\n      version: requestPayload.version,\n      nonce: requestPayload.nonce,\n      iat: requestPayload.iat,\n      statement: requestPayload.statement,\n      requestId: requestPayload.requestId,\n      resources: requestPayload.resources,\n      nbf: requestPayload.nbf,\n      exp: requestPayload.exp,\n    },\n    s: signature,\n  };\n  return authObject;\n}\ntype PopulateAuthPayloadParams = {\n  authPayload: AuthTypes.PayloadParams;\n  chains: string[];\n  methods: string[];\n};\nexport function populateAuthPayload(params: PopulateAuthPayloadParams): AuthTypes.PayloadParams {\n  const { authPayload, chains, methods } = params;\n  const statement = authPayload.statement || \"\";\n\n  if (!chains?.length) return authPayload;\n\n  const requested = authPayload.chains;\n  const supported = chains;\n\n  const supportedChains = getCommonValuesInArrays<string>(requested, supported);\n  if (!supportedChains?.length) {\n    throw new Error(\"No supported chains\");\n  }\n\n  const requestedRecaps = getDecodedRecapFromResources(authPayload.resources);\n  if (!requestedRecaps) return authPayload;\n\n  isValidRecap(requestedRecaps);\n  const resource = getRecapResource(requestedRecaps, \"eip155\");\n  let updatedResources = authPayload?.resources || [];\n\n  if (resource?.length) {\n    const actions = getReCapActions(resource);\n    const supportedActions = getCommonValuesInArrays<string>(actions, methods);\n    if (!supportedActions?.length) {\n      throw new Error(\n        `Supported methods don't satisfy the requested: ${JSON.stringify(\n          actions,\n        )}, supported: ${JSON.stringify(methods)}`,\n      );\n    }\n    const formattedActions = assignAbilityToActions(\"request\", supportedActions as string[], {\n      chains: supportedChains,\n    });\n    const updatedRecap = addResourceToRecap(requestedRecaps, \"eip155\", formattedActions);\n    // remove recap from resources as we will add the updated one\n    updatedResources = authPayload?.resources?.slice(0, -1) || [];\n    updatedResources.push(encodeRecap(updatedRecap));\n  }\n\n  return {\n    ...authPayload,\n    statement: buildRecapStatement(statement, getRecapFromResources(updatedResources)),\n    chains: supportedChains,\n    resources: authPayload?.resources || updatedResources.length > 0 ? updatedResources : undefined,\n  };\n}\n\nexport function getDecodedRecapFromResources(resources?: string[]) {\n  const resource = getRecapFromResources(resources);\n  if (!resource) return;\n  if (!isRecap(resource)) return;\n  return decodeRecap(resource);\n}\n\nexport function recapHasResource(recap: any, resource: string) {\n  return recap?.att?.hasOwnProperty(resource);\n}\n\nexport function getRecapResource(recap: any, resource: string): any[] {\n  return recap?.att?.[resource] ? Object.keys(recap?.att?.[resource]) : [];\n}\n\nexport function getRecapAbilitiesFromResource(actions: any[]) {\n  return actions?.map((action) => Object.keys(action)) || [];\n}\n\nexport function getReCapActions(abilities: any[]) {\n  return abilities?.map((ability) => ability.split(\"/\")?.[1]) || [];\n}\n\nexport function base64Encode(input: unknown): string {\n  return Buffer.from(JSON.stringify(input)).toString(\"base64\");\n}\n\nexport function base64Decode(encodedString: string): string {\n  return JSON.parse(Buffer.from(encodedString, \"base64\").toString(\"utf-8\"));\n}\n\nexport function isValidRecap(recap: any) {\n  if (!recap) throw new Error(\"No recap provided, value is undefined\");\n  if (!recap.att) throw new Error(\"No `att` property found\");\n  const resources = Object.keys(recap.att);\n  if (!resources?.length) throw new Error(\"No resources found in `att` property\");\n  resources.forEach((resource) => {\n    const resourceAbilities = recap.att[resource];\n    if (Array.isArray(resourceAbilities))\n      throw new Error(`Resource must be an object: ${resource}`);\n    if (typeof resourceAbilities !== \"object\")\n      throw new Error(`Resource must be an object: ${resource}`);\n    if (!Object.keys(resourceAbilities).length)\n      throw new Error(`Resource object is empty: ${resource}`);\n\n    Object.keys(resourceAbilities).forEach((ability) => {\n      const limits = resourceAbilities[ability];\n      if (!Array.isArray(limits))\n        throw new Error(`Ability limits ${ability} must be an array of objects, found: ${limits}`);\n      if (!limits.length)\n        throw new Error(`Value of ${ability} is empty array, must be an array with objects`);\n      limits.forEach((limit) => {\n        if (typeof limit !== \"object\")\n          throw new Error(\n            `Ability limits (${ability}) must be an array of objects, found: ${limit}`,\n          );\n      });\n    });\n  });\n}\n\nexport function createRecap(resource: string, ability: string, actions: string[], limits = {}) {\n  actions?.sort((a, b) => a.localeCompare(b));\n  return {\n    att: { [resource]: assignAbilityToActions(ability, actions, limits) },\n  };\n}\n\ntype RecapType = {\n  att: {\n    [key: string]: Record<string, unknown>;\n  };\n};\nexport function addResourceToRecap(recap: RecapType, resource: string, actions: unknown[]) {\n  recap.att[resource] = {\n    ...actions,\n  };\n  const keys = Object.keys(recap.att)?.sort((a, b) => a.localeCompare(b));\n  const baseRecap: RecapType = { att: {} };\n  const sorted = keys.reduce((obj, key) => {\n    obj.att[key] = recap.att[key];\n    return obj;\n  }, baseRecap);\n  return sorted;\n}\n\nexport function assignAbilityToActions(ability: string, actions: string[], limits = {}) {\n  // sort resources alphabetically\n  actions = actions?.sort((a, b) => a.localeCompare(b));\n  const abilities = actions.map((action) => {\n    return {\n      [`${ability}/${action}`]: [limits],\n    };\n  });\n  return Object.assign({}, ...abilities);\n}\n\nexport function encodeRecap(recap: any) {\n  isValidRecap(recap);\n  // remove the padding from the base64 string as per recap spec\n  return `urn:recap:${base64Encode(recap).replace(/=/g, \"\")}`;\n}\n\nexport function decodeRecap(recap: any): RecapType {\n  // base64Decode adds padding internally so don't need to add it back if it was removed\n  const decoded = base64Decode(recap.replace(\"urn:recap:\", \"\"));\n  isValidRecap(decoded);\n  return decoded as unknown as RecapType;\n}\n\nexport function createEncodedRecap(resource: string, ability: string, actions: string[]): string {\n  const recap = createRecap(resource, ability, actions);\n  return encodeRecap(recap);\n}\n\nexport function isRecap(resource: string) {\n  return resource && resource.includes(\"urn:recap:\");\n}\n\nexport function mergeEncodedRecaps(recap1: string, recap2: string) {\n  const decoded1 = decodeRecap(recap1);\n  const decoded2 = decodeRecap(recap2);\n  const merged = mergeRecaps(decoded1, decoded2);\n  return encodeRecap(merged);\n}\n\nexport function mergeRecaps(recap1: RecapType, recap2: RecapType) {\n  isValidRecap(recap1);\n  isValidRecap(recap2);\n  const keys = Object.keys(recap1.att)\n    .concat(Object.keys(recap2.att))\n    .sort((a, b) => a.localeCompare(b));\n  const mergedRecap: RecapType = { att: {} };\n  keys.forEach((key) => {\n    const actions = Object.keys(recap1.att?.[key] || {})\n      .concat(Object.keys(recap2.att?.[key] || {}))\n      .sort((a, b) => a.localeCompare(b));\n    actions.forEach((action) => {\n      mergedRecap.att[key] = {\n        ...mergedRecap.att[key],\n        [action]: recap1.att[key]?.[action] || recap2.att[key]?.[action],\n      };\n    });\n  });\n  return mergedRecap;\n}\n\nexport function formatStatementFromRecap(statement = \"\", recap: RecapType) {\n  isValidRecap(recap);\n  const base = \"I further authorize the stated URI to perform the following actions on my behalf: \";\n\n  if (statement.includes(base)) return statement;\n\n  const statementForRecap: string[] = [];\n  let currentCounter = 0;\n  Object.keys(recap.att).forEach((resource) => {\n    const actions = Object.keys(recap.att[resource]).map((ability: any) => {\n      return {\n        ability: ability.split(\"/\")[0],\n        action: ability.split(\"/\")[1],\n      };\n    });\n    //\n    actions.sort((a, b) => a.action.localeCompare(b.action));\n    const uniqueAbilities: Record<string, string[]> = {};\n    actions.forEach((action: any) => {\n      if (!uniqueAbilities[action.ability]) {\n        uniqueAbilities[action.ability] = [];\n      }\n      uniqueAbilities[action.ability].push(action.action);\n    });\n    const abilities = Object.keys(uniqueAbilities).map((ability) => {\n      currentCounter++;\n      return `(${currentCounter}) '${ability}': '${uniqueAbilities[ability].join(\n        \"', '\",\n      )}' for '${resource}'.`;\n    });\n    statementForRecap.push(abilities.join(\", \").replace(\".,\", \".\"));\n  });\n\n  const recapStatemet = statementForRecap.join(\" \");\n  const recapStatement = `${base}${recapStatemet}`;\n  // add a space if there is a statement\n  return `${statement ? statement + \" \" : \"\"}${recapStatement}`;\n}\n\nexport function getMethodsFromRecap(recap: string) {\n  const decoded = decodeRecap(recap);\n  isValidRecap(decoded);\n  // methods are only available for eip155 as per the current implementation\n  const resource = decoded.att?.eip155;\n  if (!resource) return [];\n  return Object.keys(resource).map((ability: any) => ability.split(\"/\")[1]);\n}\n\nexport function getChainsFromRecap(recap: string) {\n  const decoded = decodeRecap(recap);\n  isValidRecap(decoded);\n  const chains: string[] = [];\n\n  Object.values(decoded.att).forEach((resource: any) => {\n    Object.values(resource).forEach((ability: any) => {\n      if (ability?.[0]?.chains) {\n        chains.push(ability[0].chains);\n      }\n    });\n  });\n  return [...new Set(chains.flat())];\n}\n\nexport function buildRecapStatement(statement: string, recap: unknown) {\n  if (!recap) return statement;\n  const decoded = decodeRecap(recap);\n  isValidRecap(decoded);\n  return formatStatementFromRecap(statement, decoded);\n}\n\nexport function getRecapFromResources(resources?: string[]) {\n  if (!resources) return;\n  // per spec, recap is always the last resource\n  const resource = resources?.[resources.length - 1];\n  return isRecap(resource) ? resource : undefined;\n}\n","/**\n * Internal assertion helpers.\n * @module\n */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n// copied from utils\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\nfunction abool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\nexport { abool, abytes, aexists, ahash, anumber, aoutput, isBytes };\n//# sourceMappingURL=_assert.js.map","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\nimport { abytes, isBytes } from './_assert.js';\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// big-endian hardware is rare. Just in case someone still decides to run ciphers:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return BigInt(hex === '' ? '0' : '0x' + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    else if (isBytes(data))\n        data = copyBytes(data);\n    else\n        throw new Error('Uint8Array expected, got ' + typeof data);\n    return data;\n}\n/**\n * Checks if two U8A use same underlying buffer and overlaps (will corrupt and break if input and output same)\n */\nexport function overlapBytes(a, b) {\n    return (a.buffer === b.buffer && // probably will fail with some obscure proxies, but this is best we can do\n        a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end\n        b.byteOffset < a.byteOffset + a.byteLength // b starts before a end\n    );\n}\n/**\n * If input and output overlap and input starts before output, we will overwrite end of input before\n * we start processing it, so this is not supported for most ciphers (except chacha/salse, which designed with this)\n */\nexport function complexOverlapBytes(input, output) {\n    // This is very cursed. It works somehow, but I'm completely unsure,\n    // reasoning about overlapping aligned windows is very hard.\n    if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)\n        throw new Error('complex overlap of input and output is not supported');\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexport function checkOpts(defaults, opts) {\n    if (opts == null || typeof opts !== 'object')\n        throw new Error('options must be defined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n// For runtime check if class implements interface\nexport class Hash {\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nexport const wrapCipher = (params, constructor) => {\n    function wrappedCipher(key, ...args) {\n        // Validate key\n        abytes(key);\n        // Validate nonce if nonceLength is present\n        if (params.nonceLength !== undefined) {\n            const nonce = args[0];\n            if (!nonce)\n                throw new Error('nonce / iv required');\n            if (params.varSizeNonce)\n                abytes(nonce);\n            else\n                abytes(nonce, params.nonceLength);\n        }\n        // Validate AAD if tagLength present\n        const tagl = params.tagLength;\n        if (tagl && args[1] !== undefined) {\n            abytes(args[1]);\n        }\n        const cipher = constructor(key, ...args);\n        const checkOutput = (fnLength, output) => {\n            if (output !== undefined) {\n                if (fnLength !== 2)\n                    throw new Error('cipher output not supported');\n                abytes(output);\n            }\n        };\n        // Create wrapped cipher with validation and single-use encryption\n        let called = false;\n        const wrCipher = {\n            encrypt(data, output) {\n                if (called)\n                    throw new Error('cannot encrypt() twice with same key + nonce');\n                called = true;\n                abytes(data);\n                checkOutput(cipher.encrypt.length, output);\n                return cipher.encrypt(data, output);\n            },\n            decrypt(data, output) {\n                abytes(data);\n                if (tagl && data.length < tagl)\n                    throw new Error('invalid ciphertext length: smaller than tagLength=' + tagl);\n                checkOutput(cipher.decrypt.length, output);\n                return cipher.decrypt(data, output);\n            },\n        };\n        return wrCipher;\n    }\n    Object.assign(wrappedCipher, params);\n    return wrappedCipher;\n};\nexport function getOutput(expectedLength, out, onlyAligned = true) {\n    if (out === undefined)\n        return new Uint8Array(expectedLength);\n    if (out.length !== expectedLength)\n        throw new Error('invalid output length, expected ' + expectedLength + ', got: ' + out.length);\n    if (onlyAligned && !isAligned32(out))\n        throw new Error('invalid output, must be aligned');\n    return out;\n}\n// Polyfill for Safari 14\nexport function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\nexport function u64Lengths(ciphertext, AAD) {\n    const num = new Uint8Array(16);\n    const view = createView(num);\n    setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);\n    setBigUint64(view, 8, BigInt(ciphertext.length), true);\n    return num;\n}\n// Is byte array aligned to 4 byte offset (u32)?\nexport function isAligned32(bytes) {\n    return bytes.byteOffset % 4 === 0;\n}\n// copy bytes to new u8a (aligned). Because Buffer.slice is broken.\nexport function copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n}\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n//# sourceMappingURL=utils.js.map","/**\n * Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.\n\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB\n- Original papers don't allow mutating counters\n- Counter overflow is undefined [^1]\n- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it\n- Caveat: Cannot be re-used through all cases:\n- * chacha has (counter | nonce)\n- * xchacha has (nonce16 | counter | nonce16)\n- Idea B: separate nonce / counter and provide separate API for counter re-use\n- Caveat: there are different counter sizes depending on an algorithm.\n- salsa & chacha also differ in structures of key & sigma:\n  salsa20:      s[0] | k(4) | s[1] | nonce(2) | ctr(2) | s[2] | k(4) | s[3]\n  chacha:       s(4) | k(8) | ctr(1) | nonce(3)\n  chacha20orig: s(4) | k(8) | ctr(2) | nonce(2)\n- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`\n- Caveat: we can't re-use counter array\n\nxchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n\n[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\n\n * @module\n */\nimport { abool, abytes, anumber } from './_assert.js';\nimport { checkOpts, clean, copyBytes, u32 } from './utils.js';\n// We can't make top-level var depend on utils.utf8ToBytes\n// because it's not present in all envs. Creating a similar fn here\nconst _utf8ToBytes = (str) => Uint8Array.from(str.split('').map((c) => c.charCodeAt(0)));\nconst sigma16 = _utf8ToBytes('expand 16-byte k');\nconst sigma32 = _utf8ToBytes('expand 32-byte k');\nconst sigma16_32 = u32(sigma16);\nconst sigma32_32 = u32(sigma32);\nexport function rotl(a, b) {\n    return (a << b) | (a >>> (32 - b));\n}\n// Is byte array aligned to 4 byte offset (u32)?\nfunction isAligned32(b) {\n    return b.byteOffset % 4 === 0;\n}\n// Salsa and Chacha block length is always 512-bit\nconst BLOCK_LEN = 64;\nconst BLOCK_LEN32 = 16;\n// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]\n// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]\nconst MAX_COUNTER = 2 ** 32 - 1;\nconst U32_EMPTY = new Uint32Array();\nfunction runCipher(core, sigma, key, nonce, data, output, counter, rounds) {\n    const len = data.length;\n    const block = new Uint8Array(BLOCK_LEN);\n    const b32 = u32(block);\n    // Make sure that buffers aligned to 4 bytes\n    const isAligned = isAligned32(data) && isAligned32(output);\n    const d32 = isAligned ? u32(data) : U32_EMPTY;\n    const o32 = isAligned ? u32(output) : U32_EMPTY;\n    for (let pos = 0; pos < len; counter++) {\n        core(sigma, key, nonce, b32, counter, rounds);\n        if (counter >= MAX_COUNTER)\n            throw new Error('arx: counter overflow');\n        const take = Math.min(BLOCK_LEN, len - pos);\n        // aligned to 4 bytes\n        if (isAligned && take === BLOCK_LEN) {\n            const pos32 = pos / 4;\n            if (pos % 4 !== 0)\n                throw new Error('arx: invalid block position');\n            for (let j = 0, posj; j < BLOCK_LEN32; j++) {\n                posj = pos32 + j;\n                o32[posj] = d32[posj] ^ b32[j];\n            }\n            pos += BLOCK_LEN;\n            continue;\n        }\n        for (let j = 0, posj; j < take; j++) {\n            posj = pos + j;\n            output[posj] = data[posj] ^ block[j];\n        }\n        pos += take;\n    }\n}\n/** Creates ARX-like (ChaCha, Salsa) cipher stream from core function. */\nexport function createCipher(core, opts) {\n    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);\n    if (typeof core !== 'function')\n        throw new Error('core must be a function');\n    anumber(counterLength);\n    anumber(rounds);\n    abool(counterRight);\n    abool(allowShortKeys);\n    return (key, nonce, data, output, counter = 0) => {\n        abytes(key);\n        abytes(nonce);\n        abytes(data);\n        const len = data.length;\n        if (output === undefined)\n            output = new Uint8Array(len);\n        abytes(output);\n        anumber(counter);\n        if (counter < 0 || counter >= MAX_COUNTER)\n            throw new Error('arx: counter overflow');\n        if (output.length < len)\n            throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);\n        const toClean = [];\n        // Key & sigma\n        // key=16 -> sigma16, k=key|key\n        // key=32 -> sigma32, k=key\n        let l = key.length;\n        let k;\n        let sigma;\n        if (l === 32) {\n            toClean.push((k = copyBytes(key)));\n            sigma = sigma32_32;\n        }\n        else if (l === 16 && allowShortKeys) {\n            k = new Uint8Array(32);\n            k.set(key);\n            k.set(key, 16);\n            sigma = sigma16_32;\n            toClean.push(k);\n        }\n        else {\n            throw new Error(`arx: invalid 32-byte key, got length=${l}`);\n        }\n        // Nonce\n        // salsa20:      8   (8-byte counter)\n        // chacha20orig: 8   (8-byte counter)\n        // chacha20:     12  (4-byte counter)\n        // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)\n        // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)\n        // Align nonce to 4 bytes\n        if (!isAligned32(nonce))\n            toClean.push((nonce = copyBytes(nonce)));\n        const k32 = u32(k);\n        // hsalsa & hchacha: handle extended nonce\n        if (extendNonceFn) {\n            if (nonce.length !== 24)\n                throw new Error(`arx: extended nonce must be 24 bytes`);\n            extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);\n            nonce = nonce.subarray(16);\n        }\n        // Handle nonce counter\n        const nonceNcLen = 16 - counterLength;\n        if (nonceNcLen !== nonce.length)\n            throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);\n        // Pad counter when nonce is 64 bit\n        if (nonceNcLen !== 12) {\n            const nc = new Uint8Array(12);\n            nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n            nonce = nc;\n            toClean.push(nonce);\n        }\n        const n32 = u32(nonce);\n        runCipher(core, sigma, k32, n32, data, output, counter, rounds);\n        clean(...toClean);\n        return output;\n    };\n}\n//# sourceMappingURL=_arx.js.map","/**\n * Poly1305 ([PDF](https://cr.yp.to/mac/poly1305-20050329.pdf),\n * [wiki](https://en.wikipedia.org/wiki/Poly1305))\n * is a fast and parallel secret-key message-authentication code suitable for\n * a wide variety of applications. It was standardized in\n * [RFC 8439](https://datatracker.ietf.org/doc/html/rfc8439) and is now used in TLS 1.3.\n *\n * Polynomial MACs are not perfect for every situation:\n * they lack Random Key Robustness: the MAC can be forged, and can't be used in PAKE schemes.\n * See [invisible salamanders attack](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/).\n * To combat invisible salamanders, `hash(key)` can be included in ciphertext,\n * however, this would violate ciphertext indistinguishability:\n * an attacker would know which key was used - so `HKDF(key, i)`\n * could be used instead.\n *\n * Check out [original website](https://cr.yp.to/mac.html).\n * @module\n */\nimport { abytes, aexists, aoutput } from './_assert.js';\nimport { Hash, clean, toBytes } from './utils.js';\n// Based on Public Domain poly1305-donna https://github.com/floodyberry/poly1305-donna\nconst u8to16 = (a, i) => (a[i++] & 0xff) | ((a[i++] & 0xff) << 8);\nclass Poly1305 {\n    constructor(key) {\n        this.blockLen = 16;\n        this.outputLen = 16;\n        this.buffer = new Uint8Array(16);\n        this.r = new Uint16Array(10);\n        this.h = new Uint16Array(10);\n        this.pad = new Uint16Array(8);\n        this.pos = 0;\n        this.finished = false;\n        key = toBytes(key);\n        abytes(key, 32);\n        const t0 = u8to16(key, 0);\n        const t1 = u8to16(key, 2);\n        const t2 = u8to16(key, 4);\n        const t3 = u8to16(key, 6);\n        const t4 = u8to16(key, 8);\n        const t5 = u8to16(key, 10);\n        const t6 = u8to16(key, 12);\n        const t7 = u8to16(key, 14);\n        // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n        this.r[0] = t0 & 0x1fff;\n        this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;\n        this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;\n        this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;\n        this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;\n        this.r[5] = (t4 >>> 1) & 0x1ffe;\n        this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;\n        this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;\n        this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;\n        this.r[9] = (t7 >>> 5) & 0x007f;\n        for (let i = 0; i < 8; i++)\n            this.pad[i] = u8to16(key, 16 + 2 * i);\n    }\n    process(data, offset, isLast = false) {\n        const hibit = isLast ? 0 : 1 << 11;\n        const { h, r } = this;\n        const r0 = r[0];\n        const r1 = r[1];\n        const r2 = r[2];\n        const r3 = r[3];\n        const r4 = r[4];\n        const r5 = r[5];\n        const r6 = r[6];\n        const r7 = r[7];\n        const r8 = r[8];\n        const r9 = r[9];\n        const t0 = u8to16(data, offset + 0);\n        const t1 = u8to16(data, offset + 2);\n        const t2 = u8to16(data, offset + 4);\n        const t3 = u8to16(data, offset + 6);\n        const t4 = u8to16(data, offset + 8);\n        const t5 = u8to16(data, offset + 10);\n        const t6 = u8to16(data, offset + 12);\n        const t7 = u8to16(data, offset + 14);\n        let h0 = h[0] + (t0 & 0x1fff);\n        let h1 = h[1] + (((t0 >>> 13) | (t1 << 3)) & 0x1fff);\n        let h2 = h[2] + (((t1 >>> 10) | (t2 << 6)) & 0x1fff);\n        let h3 = h[3] + (((t2 >>> 7) | (t3 << 9)) & 0x1fff);\n        let h4 = h[4] + (((t3 >>> 4) | (t4 << 12)) & 0x1fff);\n        let h5 = h[5] + ((t4 >>> 1) & 0x1fff);\n        let h6 = h[6] + (((t4 >>> 14) | (t5 << 2)) & 0x1fff);\n        let h7 = h[7] + (((t5 >>> 11) | (t6 << 5)) & 0x1fff);\n        let h8 = h[8] + (((t6 >>> 8) | (t7 << 8)) & 0x1fff);\n        let h9 = h[9] + ((t7 >>> 5) | hibit);\n        let c = 0;\n        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n        c = d0 >>> 13;\n        d0 &= 0x1fff;\n        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n        c += d0 >>> 13;\n        d0 &= 0x1fff;\n        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n        c = d1 >>> 13;\n        d1 &= 0x1fff;\n        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n        c += d1 >>> 13;\n        d1 &= 0x1fff;\n        let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n        c = d2 >>> 13;\n        d2 &= 0x1fff;\n        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n        c += d2 >>> 13;\n        d2 &= 0x1fff;\n        let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n        c = d3 >>> 13;\n        d3 &= 0x1fff;\n        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n        c += d3 >>> 13;\n        d3 &= 0x1fff;\n        let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n        c = d4 >>> 13;\n        d4 &= 0x1fff;\n        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n        c += d4 >>> 13;\n        d4 &= 0x1fff;\n        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n        c = d5 >>> 13;\n        d5 &= 0x1fff;\n        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n        c += d5 >>> 13;\n        d5 &= 0x1fff;\n        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n        c = d6 >>> 13;\n        d6 &= 0x1fff;\n        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n        c += d6 >>> 13;\n        d6 &= 0x1fff;\n        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n        c = d7 >>> 13;\n        d7 &= 0x1fff;\n        d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n        c += d7 >>> 13;\n        d7 &= 0x1fff;\n        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n        c = d8 >>> 13;\n        d8 &= 0x1fff;\n        d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n        c += d8 >>> 13;\n        d8 &= 0x1fff;\n        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n        c = d9 >>> 13;\n        d9 &= 0x1fff;\n        d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n        c += d9 >>> 13;\n        d9 &= 0x1fff;\n        c = ((c << 2) + c) | 0;\n        c = (c + d0) | 0;\n        d0 = c & 0x1fff;\n        c = c >>> 13;\n        d1 += c;\n        h[0] = d0;\n        h[1] = d1;\n        h[2] = d2;\n        h[3] = d3;\n        h[4] = d4;\n        h[5] = d5;\n        h[6] = d6;\n        h[7] = d7;\n        h[8] = d8;\n        h[9] = d9;\n    }\n    finalize() {\n        const { h, pad } = this;\n        const g = new Uint16Array(10);\n        let c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        for (let i = 2; i < 10; i++) {\n            h[i] += c;\n            c = h[i] >>> 13;\n            h[i] &= 0x1fff;\n        }\n        h[0] += c * 5;\n        c = h[0] >>> 13;\n        h[0] &= 0x1fff;\n        h[1] += c;\n        c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        h[2] += c;\n        g[0] = h[0] + 5;\n        c = g[0] >>> 13;\n        g[0] &= 0x1fff;\n        for (let i = 1; i < 10; i++) {\n            g[i] = h[i] + c;\n            c = g[i] >>> 13;\n            g[i] &= 0x1fff;\n        }\n        g[9] -= 1 << 13;\n        let mask = (c ^ 1) - 1;\n        for (let i = 0; i < 10; i++)\n            g[i] &= mask;\n        mask = ~mask;\n        for (let i = 0; i < 10; i++)\n            h[i] = (h[i] & mask) | g[i];\n        h[0] = (h[0] | (h[1] << 13)) & 0xffff;\n        h[1] = ((h[1] >>> 3) | (h[2] << 10)) & 0xffff;\n        h[2] = ((h[2] >>> 6) | (h[3] << 7)) & 0xffff;\n        h[3] = ((h[3] >>> 9) | (h[4] << 4)) & 0xffff;\n        h[4] = ((h[4] >>> 12) | (h[5] << 1) | (h[6] << 14)) & 0xffff;\n        h[5] = ((h[6] >>> 2) | (h[7] << 11)) & 0xffff;\n        h[6] = ((h[7] >>> 5) | (h[8] << 8)) & 0xffff;\n        h[7] = ((h[8] >>> 8) | (h[9] << 5)) & 0xffff;\n        let f = h[0] + pad[0];\n        h[0] = f & 0xffff;\n        for (let i = 1; i < 8; i++) {\n            f = (((h[i] + pad[i]) | 0) + (f >>> 16)) | 0;\n            h[i] = f & 0xffff;\n        }\n        clean(g);\n    }\n    update(data) {\n        aexists(this);\n        const { buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input\n            if (take === blockLen) {\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(data, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(buffer, 0, false);\n                this.pos = 0;\n            }\n        }\n        return this;\n    }\n    destroy() {\n        clean(this.h, this.r, this.buffer, this.pad);\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        const { buffer, h } = this;\n        let { pos } = this;\n        if (pos) {\n            buffer[pos++] = 1;\n            for (; pos < 16; pos++)\n                buffer[pos] = 0;\n            this.process(buffer, 0, true);\n        }\n        this.finalize();\n        let opos = 0;\n        for (let i = 0; i < 8; i++) {\n            out[opos++] = h[i] >>> 0;\n            out[opos++] = h[i] >>> 8;\n        }\n        return out;\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n}\nexport function wrapConstructorWithKey(hashCons) {\n    const hashC = (msg, key) => hashCons(key).update(toBytes(msg)).digest();\n    const tmp = hashCons(new Uint8Array(32));\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (key) => hashCons(key);\n    return hashC;\n}\n/** Poly1305 MAC from RFC 8439. */\nexport const poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));\n//# sourceMappingURL=_poly1305.js.map","/**\n * [ChaCha20](https://cr.yp.to/chacha.html) stream cipher, released\n * in 2008. Developed after Salsa20, ChaCha aims to increase diffusion per round.\n * It was standardized in [RFC 8439](https://datatracker.ietf.org/doc/html/rfc8439) and\n * is now used in TLS 1.3.\n *\n * [XChaCha20](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha)\n * extended-nonce variant is also provided. Similar to XSalsa, it's safe to use with\n * randomly-generated nonces.\n *\n * Check out [PDF](http://cr.yp.to/chacha/chacha-20080128.pdf) and\n * [wiki](https://en.wikipedia.org/wiki/Salsa20).\n * @module\n */\nimport { createCipher, rotl } from './_arx.js';\nimport { poly1305 } from './_poly1305.js';\nimport { clean, createView, equalBytes, getOutput, setBigUint64, wrapCipher, } from './utils.js';\n/**\n * ChaCha core function.\n */\n// prettier-ignore\nfunction chachaCore(s, k, n, out, cnt, rounds = 20) {\n    let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n    y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], // Key      Key     Key     Key\n    y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], // Key      Key     Key     Key\n    y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2]; // Counter  Counter\tNonce   Nonce\n    // Save state to temporary variables\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    for (let r = 0; r < rounds; r += 2) {\n        x00 = (x00 + x04) | 0;\n        x12 = rotl(x12 ^ x00, 16);\n        x08 = (x08 + x12) | 0;\n        x04 = rotl(x04 ^ x08, 12);\n        x00 = (x00 + x04) | 0;\n        x12 = rotl(x12 ^ x00, 8);\n        x08 = (x08 + x12) | 0;\n        x04 = rotl(x04 ^ x08, 7);\n        x01 = (x01 + x05) | 0;\n        x13 = rotl(x13 ^ x01, 16);\n        x09 = (x09 + x13) | 0;\n        x05 = rotl(x05 ^ x09, 12);\n        x01 = (x01 + x05) | 0;\n        x13 = rotl(x13 ^ x01, 8);\n        x09 = (x09 + x13) | 0;\n        x05 = rotl(x05 ^ x09, 7);\n        x02 = (x02 + x06) | 0;\n        x14 = rotl(x14 ^ x02, 16);\n        x10 = (x10 + x14) | 0;\n        x06 = rotl(x06 ^ x10, 12);\n        x02 = (x02 + x06) | 0;\n        x14 = rotl(x14 ^ x02, 8);\n        x10 = (x10 + x14) | 0;\n        x06 = rotl(x06 ^ x10, 7);\n        x03 = (x03 + x07) | 0;\n        x15 = rotl(x15 ^ x03, 16);\n        x11 = (x11 + x15) | 0;\n        x07 = rotl(x07 ^ x11, 12);\n        x03 = (x03 + x07) | 0;\n        x15 = rotl(x15 ^ x03, 8);\n        x11 = (x11 + x15) | 0;\n        x07 = rotl(x07 ^ x11, 7);\n        x00 = (x00 + x05) | 0;\n        x15 = rotl(x15 ^ x00, 16);\n        x10 = (x10 + x15) | 0;\n        x05 = rotl(x05 ^ x10, 12);\n        x00 = (x00 + x05) | 0;\n        x15 = rotl(x15 ^ x00, 8);\n        x10 = (x10 + x15) | 0;\n        x05 = rotl(x05 ^ x10, 7);\n        x01 = (x01 + x06) | 0;\n        x12 = rotl(x12 ^ x01, 16);\n        x11 = (x11 + x12) | 0;\n        x06 = rotl(x06 ^ x11, 12);\n        x01 = (x01 + x06) | 0;\n        x12 = rotl(x12 ^ x01, 8);\n        x11 = (x11 + x12) | 0;\n        x06 = rotl(x06 ^ x11, 7);\n        x02 = (x02 + x07) | 0;\n        x13 = rotl(x13 ^ x02, 16);\n        x08 = (x08 + x13) | 0;\n        x07 = rotl(x07 ^ x08, 12);\n        x02 = (x02 + x07) | 0;\n        x13 = rotl(x13 ^ x02, 8);\n        x08 = (x08 + x13) | 0;\n        x07 = rotl(x07 ^ x08, 7);\n        x03 = (x03 + x04) | 0;\n        x14 = rotl(x14 ^ x03, 16);\n        x09 = (x09 + x14) | 0;\n        x04 = rotl(x04 ^ x09, 12);\n        x03 = (x03 + x04) | 0;\n        x14 = rotl(x14 ^ x03, 8);\n        x09 = (x09 + x14) | 0;\n        x04 = rotl(x04 ^ x09, 7);\n    }\n    // Write output\n    let oi = 0;\n    out[oi++] = (y00 + x00) | 0;\n    out[oi++] = (y01 + x01) | 0;\n    out[oi++] = (y02 + x02) | 0;\n    out[oi++] = (y03 + x03) | 0;\n    out[oi++] = (y04 + x04) | 0;\n    out[oi++] = (y05 + x05) | 0;\n    out[oi++] = (y06 + x06) | 0;\n    out[oi++] = (y07 + x07) | 0;\n    out[oi++] = (y08 + x08) | 0;\n    out[oi++] = (y09 + x09) | 0;\n    out[oi++] = (y10 + x10) | 0;\n    out[oi++] = (y11 + x11) | 0;\n    out[oi++] = (y12 + x12) | 0;\n    out[oi++] = (y13 + x13) | 0;\n    out[oi++] = (y14 + x14) | 0;\n    out[oi++] = (y15 + x15) | 0;\n}\n/**\n * hchacha helper method, used primarily in xchacha, to hash\n * key and nonce into key' and nonce'.\n * Same as chachaCore, but there doesn't seem to be a way to move the block\n * out without 25% performance hit.\n */\n// prettier-ignore\nexport function hchacha(s, k, i, o32) {\n    let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];\n    for (let r = 0; r < 20; r += 2) {\n        x00 = (x00 + x04) | 0;\n        x12 = rotl(x12 ^ x00, 16);\n        x08 = (x08 + x12) | 0;\n        x04 = rotl(x04 ^ x08, 12);\n        x00 = (x00 + x04) | 0;\n        x12 = rotl(x12 ^ x00, 8);\n        x08 = (x08 + x12) | 0;\n        x04 = rotl(x04 ^ x08, 7);\n        x01 = (x01 + x05) | 0;\n        x13 = rotl(x13 ^ x01, 16);\n        x09 = (x09 + x13) | 0;\n        x05 = rotl(x05 ^ x09, 12);\n        x01 = (x01 + x05) | 0;\n        x13 = rotl(x13 ^ x01, 8);\n        x09 = (x09 + x13) | 0;\n        x05 = rotl(x05 ^ x09, 7);\n        x02 = (x02 + x06) | 0;\n        x14 = rotl(x14 ^ x02, 16);\n        x10 = (x10 + x14) | 0;\n        x06 = rotl(x06 ^ x10, 12);\n        x02 = (x02 + x06) | 0;\n        x14 = rotl(x14 ^ x02, 8);\n        x10 = (x10 + x14) | 0;\n        x06 = rotl(x06 ^ x10, 7);\n        x03 = (x03 + x07) | 0;\n        x15 = rotl(x15 ^ x03, 16);\n        x11 = (x11 + x15) | 0;\n        x07 = rotl(x07 ^ x11, 12);\n        x03 = (x03 + x07) | 0;\n        x15 = rotl(x15 ^ x03, 8);\n        x11 = (x11 + x15) | 0;\n        x07 = rotl(x07 ^ x11, 7);\n        x00 = (x00 + x05) | 0;\n        x15 = rotl(x15 ^ x00, 16);\n        x10 = (x10 + x15) | 0;\n        x05 = rotl(x05 ^ x10, 12);\n        x00 = (x00 + x05) | 0;\n        x15 = rotl(x15 ^ x00, 8);\n        x10 = (x10 + x15) | 0;\n        x05 = rotl(x05 ^ x10, 7);\n        x01 = (x01 + x06) | 0;\n        x12 = rotl(x12 ^ x01, 16);\n        x11 = (x11 + x12) | 0;\n        x06 = rotl(x06 ^ x11, 12);\n        x01 = (x01 + x06) | 0;\n        x12 = rotl(x12 ^ x01, 8);\n        x11 = (x11 + x12) | 0;\n        x06 = rotl(x06 ^ x11, 7);\n        x02 = (x02 + x07) | 0;\n        x13 = rotl(x13 ^ x02, 16);\n        x08 = (x08 + x13) | 0;\n        x07 = rotl(x07 ^ x08, 12);\n        x02 = (x02 + x07) | 0;\n        x13 = rotl(x13 ^ x02, 8);\n        x08 = (x08 + x13) | 0;\n        x07 = rotl(x07 ^ x08, 7);\n        x03 = (x03 + x04) | 0;\n        x14 = rotl(x14 ^ x03, 16);\n        x09 = (x09 + x14) | 0;\n        x04 = rotl(x04 ^ x09, 12);\n        x03 = (x03 + x04) | 0;\n        x14 = rotl(x14 ^ x03, 8);\n        x09 = (x09 + x14) | 0;\n        x04 = rotl(x04 ^ x09, 7);\n    }\n    let oi = 0;\n    o32[oi++] = x00;\n    o32[oi++] = x01;\n    o32[oi++] = x02;\n    o32[oi++] = x03;\n    o32[oi++] = x12;\n    o32[oi++] = x13;\n    o32[oi++] = x14;\n    o32[oi++] = x15;\n}\n/**\n * Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter.\n */\nexport const chacha20orig = /* @__PURE__ */ createCipher(chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    allowShortKeys: true,\n});\n/**\n * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nexport const chacha20 = /* @__PURE__ */ createCipher(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    allowShortKeys: false,\n});\n/**\n * XChaCha eXtended-nonce ChaCha. 24-byte nonce.\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n */\nexport const xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    extendNonceFn: hchacha,\n    allowShortKeys: false,\n});\n/**\n * Reduced 8-round chacha, described in original paper.\n */\nexport const chacha8 = /* @__PURE__ */ createCipher(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 8,\n});\n/**\n * Reduced 12-round chacha, described in original paper.\n */\nexport const chacha12 = /* @__PURE__ */ createCipher(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 12,\n});\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\n// Pad to digest size with zeros\nconst updatePadded = (h, msg) => {\n    h.update(msg);\n    const left = msg.length % 16;\n    if (left)\n        h.update(ZEROS16.subarray(left));\n};\nconst ZEROS32 = /* @__PURE__ */ new Uint8Array(32);\nfunction computeTag(fn, key, nonce, data, AAD) {\n    const authKey = fn(key, nonce, ZEROS32);\n    const h = poly1305.create(authKey);\n    if (AAD)\n        updatePadded(h, AAD);\n    updatePadded(h, data);\n    const num = new Uint8Array(16);\n    const view = createView(num);\n    setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);\n    setBigUint64(view, 8, BigInt(data.length), true);\n    h.update(num);\n    const res = h.digest();\n    clean(authKey, num);\n    return res;\n}\n/**\n * AEAD algorithm from RFC 8439.\n * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n * We could have composed them similar to:\n * https://github.com/paulmillr/scure-base/blob/b266c73dde977b1dd7ef40ef7a23cc15aab526b3/index.ts#L250\n * But it's hard because of authKey:\n * In salsa20, authKey changes position in salsa stream.\n * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n */\nexport const _poly1305_aead = (xorStream) => (key, nonce, AAD) => {\n    const tagLength = 16;\n    return {\n        encrypt(plaintext, output) {\n            const plength = plaintext.length;\n            output = getOutput(plength + tagLength, output, false);\n            output.set(plaintext);\n            const oPlain = output.subarray(0, -tagLength);\n            xorStream(key, nonce, oPlain, oPlain, 1);\n            const tag = computeTag(xorStream, key, nonce, oPlain, AAD);\n            output.set(tag, plength); // append tag\n            clean(tag);\n            return output;\n        },\n        decrypt(ciphertext, output) {\n            output = getOutput(ciphertext.length - tagLength, output, false);\n            const data = ciphertext.subarray(0, -tagLength);\n            const passedTag = ciphertext.subarray(-tagLength);\n            const tag = computeTag(xorStream, key, nonce, data, AAD);\n            if (!equalBytes(passedTag, tag))\n                throw new Error('invalid tag');\n            output.set(ciphertext.subarray(0, -tagLength));\n            xorStream(key, nonce, output, output, 1); // start stream with i=1\n            clean(tag);\n            return output;\n        },\n    };\n};\n/**\n * ChaCha20-Poly1305 from RFC 8439.\n *\n * Unsafe to use random nonces under the same key, due to collision chance.\n * Prefer XChaCha instead.\n */\nexport const chacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));\n/**\n * XChaCha20-Poly1305 extended-nonce chacha.\n *\n * Can be safely used with random nonces (CSPRNG).\n * See [IRTF draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha).\n */\nexport const xchacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));\n//# sourceMappingURL=chacha.js.map","/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash } from './_assert.js';\nimport { Hash, toBytes } from './utils.js';\nexport class HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        ahash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        aexists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        abytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","/**\n * HKDF (RFC 5869): extract + expand in one step.\n * See https://soatok.blog/2021/11/17/understanding-hkdf/.\n * @module\n */\nimport { ahash, anumber } from './_assert.js';\nimport { hmac } from './hmac.js';\nimport { toBytes } from './utils.js';\n/**\n * HKDF-extract from spec. Less important part. `HKDF-Extract(IKM, salt) -> PRK`\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n */\nexport function extract(hash, ikm, salt) {\n    ahash(hash);\n    // NOTE: some libraries treat zero-length array as 'not provided';\n    // we don't, since we have undefined as 'not provided'\n    // https://github.com/RustCrypto/KDFs/issues/15\n    if (salt === undefined)\n        salt = new Uint8Array(hash.outputLen);\n    return hmac(hash, toBytes(salt), toBytes(ikm));\n}\nconst HKDF_COUNTER = /* @__PURE__ */ new Uint8Array([0]);\nconst EMPTY_BUFFER = /* @__PURE__ */ new Uint8Array();\n/**\n * HKDF-expand from the spec. The most important part. `HKDF-Expand(PRK, info, L) -> OKM`\n * @param hash - hash function that would be used (e.g. sha256)\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in bytes\n */\nexport function expand(hash, prk, info, length = 32) {\n    ahash(hash);\n    anumber(length);\n    if (length > 255 * hash.outputLen)\n        throw new Error('Length should be <= 255*HashLen');\n    const blocks = Math.ceil(length / hash.outputLen);\n    if (info === undefined)\n        info = EMPTY_BUFFER;\n    // first L(ength) octets of T\n    const okm = new Uint8Array(blocks * hash.outputLen);\n    // Re-use HMAC instance between blocks\n    const HMAC = hmac.create(hash, prk);\n    const HMACTmp = HMAC._cloneInto();\n    const T = new Uint8Array(HMAC.outputLen);\n    for (let counter = 0; counter < blocks; counter++) {\n        HKDF_COUNTER[0] = counter + 1;\n        // T(0) = empty string (zero length)\n        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n            .update(info)\n            .update(HKDF_COUNTER)\n            .digestInto(T);\n        okm.set(T, hash.outputLen * counter);\n        HMAC._cloneInto(HMACTmp);\n    }\n    HMAC.destroy();\n    HMACTmp.destroy();\n    T.fill(0);\n    HKDF_COUNTER.fill(0);\n    return okm.slice(0, length);\n}\n/**\n * HKDF (RFC 5869): derive keys from an initial input.\n * Combines hkdf_extract + hkdf_expand in one step\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in bytes\n * @example\n * import { hkdf } from '@noble/hashes/hkdf';\n * import { sha256 } from '@noble/hashes/sha2';\n * import { randomBytes } from '@noble/hashes/utils';\n * const inputKey = randomBytes(32);\n * const salt = randomBytes(32);\n * const info = 'application-key';\n * const hk1 = hkdf(sha256, inputKey, salt, info, 32);\n */\nexport const hkdf = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);\n//# sourceMappingURL=hkdf.js.map","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { aexists, aoutput } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nexport function Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map","/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj } from './_md.js';\nimport { rotr, wrapConstructor } from './utils.js';\n/** Round constants: first 32 bits of fractional parts of the cube roots of the first 64 primes 2..311). */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Initial state: first 32 bits of fractional parts of the square roots of the first 8 primes 2..19. */\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n/**\n * Temporary buffer, not used to store anything between runs.\n * Named this way because it matches specification.\n */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n/**\n * Constants taken from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf.\n */\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/** SHA2-256 hash function */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\n/** SHA2-224 hash function */\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nexport function abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\nexport function abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexport function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nexport function inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */\nexport const notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map","/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitMask, bytesToNumberBE, bytesToNumberLE, ensureBytes, numberToBytesBE, numberToBytesLE, validateObject, } from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// prettier-ignore\nconst _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @todo use field version && remove\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num, power, modulo) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (modulo <= _0n)\n        throw new Error('invalid modulus');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++) {\n        // Crash instead of infinity loop, we cannot reasonable count until P.\n        if (Z > 1000)\n            throw new Error('Cannot find square root: likely non-prime P');\n    }\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\n/**\n * Square root for a finite field. It will try to check if optimizations are applicable and fall back to 4:\n *\n * 1. P ≡ 3 (mod 4)\n * 2. P ≡ 5 (mod 8)\n * 3. P ≡ 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P) {\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return validateObject(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nexport function FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n/**\n * Legendre symbol.\n * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ≡ 0    if a ≡ 0 (mod p)\n */\nexport function FpLegendre(order) {\n    const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n    return (f, x) => f.pow(x, legendreConst);\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(f) {\n    const legendre = FpLegendre(f.ORDER);\n    return (x) => {\n        const p = legendre(f, x);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = ensureBytes('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { nLength, validateField } from './modular.js';\nimport { bitLen, validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, bits) {\n    validateW(W, bits);\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return { windows, windowSize };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport function wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes(elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n, p = c.ZERO) {\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = calcWOpts(W, bits);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */\n        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                if (n === _0n)\n                    break; // No need to go over empty scalar\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                if (wbits === 0)\n                    continue;\n                let curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero\n                if (wbits < 0)\n                    curr = curr.negate();\n                // NOTE: by re-using acc, we can save a lot of additions in case of MSM\n                acc = acc.add(curr);\n            }\n            return acc;\n        },\n        getPrecomputes(W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1)\n                    pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached(P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe(P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1)\n                return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize(P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        },\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nexport function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    if (points.length !== scalars.length)\n        throw new Error('arrays of points and scalars must have equal length');\n    const zero = c.ZERO;\n    const wbits = bitLen(BigInt(points.length));\n    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n    const MASK = (1 << windowSize) - 1;\n    const buckets = new Array(MASK + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < scalars.length; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & BigInt(MASK));\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar × 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 × 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 × 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = BigInt((1 << windowSize) - 1);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nexport function validateBasic(curve) {\n    validateField(curve.Fp);\n    validateObject(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...nLength(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map","/**\n * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².\n * For design rationale of types / exports, see weierstrass module documentation.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { pippenger, validateBasic, wNAF, } from './curve.js';\nimport { Field, mod } from './modular.js';\nimport * as ut from './utils.js';\nimport { abool, ensureBytes, memoized } from './utils.js';\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(curve, {\n        hash: 'function',\n        a: 'bigint',\n        d: 'bigint',\n        randomBytes: 'function',\n    }, {\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        uvRatio: 'function',\n        mapToCurve: 'function',\n    });\n    // Set defaults\n    return Object.freeze({ ...opts });\n}\n/**\n * Creates Twisted Edwards curve with EdDSA signatures.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, d, p, n, Gx, Gy, h\n * const curve = twistedEdwards({ a, d, Fp: Field(p), n, Gx, Gy, h })\n */\nexport function twistedEdwards(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor, } = CURVE;\n    // Important:\n    // There are some places where Fp.BYTES is used instead of nByteLength.\n    // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n    // TODO: test and find curves which behave otherwise.\n    const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n    const modP = Fp.create; // Function overrides\n    const Fn = Field(CURVE.n, CURVE.nBitLength);\n    // sqrt(u/v)\n    const uvRatio = CURVE.uvRatio ||\n        ((u, v) => {\n            try {\n                return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n            }\n            catch (e) {\n                return { isValid: false, value: _0n };\n            }\n        });\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes); // NOOP\n    const domain = CURVE.domain ||\n        ((data, ctx, phflag) => {\n            abool('phflag', phflag);\n            if (ctx.length || phflag)\n                throw new Error('Contexts/pre-hash are not supported');\n            return data;\n        }); // NOOP\n    // 0 <= n < MASK\n    // Coordinates larger than Fp.ORDER are allowed for zip215\n    function aCoordinate(title, n) {\n        ut.aInRange('coordinate ' + title, n, _0n, MASK);\n    }\n    function assertPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ExtendedPoint expected');\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    const toAffineMemo = memoized((p, iz) => {\n        const { ex: x, ey: y, ez: z } = p;\n        const is0 = p.is0();\n        if (iz == null)\n            iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n        const ax = modP(x * iz);\n        const ay = modP(y * iz);\n        const zz = modP(z * iz);\n        if (is0)\n            return { x: _0n, y: _1n };\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    const assertValidMemo = memoized((p) => {\n        const { a, d } = CURVE;\n        if (p.is0())\n            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n        const { ex: X, ey: Y, ez: Z, et: T } = p;\n        const X2 = modP(X * X); // X²\n        const Y2 = modP(Y * Y); // Y²\n        const Z2 = modP(Z * Z); // Z²\n        const Z4 = modP(Z2 * Z2); // Z⁴\n        const aX2 = modP(X2 * a); // aX²\n        const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n        if (left !== right)\n            throw new Error('bad point: equation left != right (1)');\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        const XY = modP(X * Y);\n        const ZT = modP(Z * T);\n        if (XY !== ZT)\n            throw new Error('bad point: equation left != right (2)');\n        return true;\n    });\n    // Extended Point works in extended coordinates: (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(ex, ey, ez, et) {\n            this.ex = ex;\n            this.ey = ey;\n            this.ez = ez;\n            this.et = et;\n            aCoordinate('x', ex);\n            aCoordinate('y', ey);\n            aCoordinate('z', ez);\n            aCoordinate('t', et);\n            Object.freeze(this);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point)\n                throw new Error('extended point not allowed');\n            const { x, y } = p || {};\n            aCoordinate('x', x);\n            aCoordinate('y', y);\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.ez));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return pippenger(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // Not required for fromHex(), which always creates valid points.\n        // Could be useful for fromAffine().\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        // Compare one point to another.\n        equals(other) {\n            assertPoint(other);\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            assertPoint(other);\n            const { a, d } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n            // Faster algo for adding 2 Extended Points when curve's a=-1.\n            // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n            // Cost: 8M + 8add + 2*2.\n            // Note: It does not check whether the `other` point is valid.\n            if (a === BigInt(-1)) {\n                const A = modP((Y1 - X1) * (Y2 + X2));\n                const B = modP((Y1 + X1) * (Y2 - X2));\n                const F = modP(B - A);\n                if (F === _0n)\n                    return this.double(); // Same point. Tests say it doesn't affect timing\n                const C = modP(Z1 * _2n * T2);\n                const D = modP(T1 * _2n * Z2);\n                const E = D + C;\n                const G = B + A;\n                const H = D - C;\n                const X3 = modP(E * F);\n                const Y3 = modP(G * H);\n                const T3 = modP(E * H);\n                const Z3 = modP(F * G);\n                return new Point(X3, Y3, Z3, T3);\n            }\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            const n = scalar;\n            ut.aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n            const { p, f } = this.wNAF(n);\n            return Point.normalizeZ([p, f])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n        multiplyUnsafe(scalar, acc = Point.ZERO) {\n            const n = scalar;\n            ut.aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n            if (n === _0n)\n                return I;\n            if (this.is0() || n === _1n)\n                return this;\n            return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        clearCofactor() {\n            const { h: cofactor } = CURVE;\n            if (cofactor === _1n)\n                return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        // Converts hash string or Uint8Array to Point.\n        // Uses algo from RFC8032 5.1.3.\n        static fromHex(hex, zip215 = false) {\n            const { d, a } = CURVE;\n            const len = Fp.BYTES;\n            hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n            abool('zip215', zip215);\n            const normed = hex.slice(); // copy again, we'll manipulate it\n            const lastByte = hex[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = ut.bytesToNumberLE(normed);\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // RFC8032 prohibits >= p, but ZIP215 doesn't\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            const max = zip215 ? MASK : Fp.ORDER;\n            ut.aInRange('pointHex.y', y, _0n, max);\n            // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n            // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y² - 1\n            const v = modP(d * y2 - a); // v = d y² + 1.\n            let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n            if (!isValid)\n                throw new Error('Point.fromHex: invalid y coordinate');\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd)\n                // if x=0 and x_0 = 1, fail\n                throw new Error('Point.fromHex: x=0 and x_0=1');\n            if (isLastByteOdd !== isXOdd)\n                x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({ x, y });\n        }\n        static fromPrivateKey(privKey) {\n            return getExtendedPublicKey(privKey).point;\n        }\n        toRawBytes() {\n            const { x, y } = this.toAffine();\n            const bytes = ut.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n            return bytes; // and use the last byte to encode sign of x\n        }\n        toHex() {\n            return ut.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    const { BASE: G, ZERO: I } = Point;\n    const wnaf = wNAF(Point, nByteLength * 8);\n    function modN(a) {\n        return mod(a, CURVE_ORDER);\n    }\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return modN(ut.bytesToNumberLE(hash));\n    }\n    /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n    function getExtendedPublicKey(key) {\n        const len = Fp.BYTES;\n        key = ensureBytes('private key', key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        const point = G.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toRawBytes(); // Uint8Array representation\n        return { head, prefix, scalar, point, pointBytes };\n    }\n    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n    function getPublicKey(privKey) {\n        return getExtendedPublicKey(privKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {\n        const msg = ut.concatBytes(...msgs);\n        return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */\n    function sign(msg, privKey, options = {}) {\n        msg = ensureBytes('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = G.multiply(r).toRawBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = modN(r + k * scalar); // S = (r + k * s) mod L\n        ut.aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n        const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));\n        return ensureBytes('result', res, Fp.BYTES * 2); // 64-byte signature\n    }\n    const verifyOpts = VERIFY_DEFAULT;\n    /**\n     * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n     * An extended group equation is checked.\n     */\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n        sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n        msg = ensureBytes('message', msg);\n        publicKey = ensureBytes('publicKey', publicKey, len);\n        if (zip215 !== undefined)\n            abool('zip215', zip215);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph, etc\n        const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));\n        let A, R, SB;\n        try {\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            A = Point.fromHex(publicKey, zip215);\n            R = Point.fromHex(sig.slice(0, len), zip215);\n            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n        }\n        catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder())\n            return false;\n        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // Extended group equation\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n    }\n    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    const utils = {\n        getExtendedPublicKey,\n        // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n        randomPrivateKey: () => randomBytes(Fp.BYTES),\n        /**\n         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n         * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n         * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n         * @param windowSize 2, 4, 8, 16\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3));\n            return point;\n        },\n    };\n    return {\n        CURVE,\n        getPublicKey,\n        sign,\n        verify,\n        ExtendedPoint: Point,\n        utils,\n    };\n}\n//# sourceMappingURL=edwards.js.map","/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { mod, pow } from './modular.js';\nimport { aInRange, bytesToNumberLE, ensureBytes, numberToBytesLE, validateObject, } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction validateOpts(curve) {\n    validateObject(curve, {\n        a: 'bigint',\n    }, {\n        montgomeryBits: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        powPminus2: 'function',\n        Gu: 'bigint',\n    });\n    // Set defaults\n    return Object.freeze({ ...curve });\n}\n// Uses only one coordinate instead of two\nexport function montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P } = CURVE;\n    const modP = (n) => mod(n, P);\n    const montgomeryBits = CURVE.montgomeryBits;\n    const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n    const fieldLen = CURVE.nByteLength;\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);\n    const powPminus2 = CURVE.powPminus2 || ((x) => pow(x, P - BigInt(2), P));\n    // cswap from RFC7748. But it is not from RFC7748!\n    /*\n      cswap(swap, x_2, x_3):\n           dummy = mask(swap) AND (x_2 XOR x_3)\n           x_2 = x_2 XOR dummy\n           x_3 = x_3 XOR dummy\n           Return (x_2, x_3)\n    Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n     and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    */\n    function cswap(swap, x_2, x_3) {\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy);\n        x_3 = modP(x_3 + dummy);\n        return [x_2, x_3];\n    }\n    // x25519 from 4\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n    const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n    /**\n     *\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */\n    function montgomeryLadder(u, scalar) {\n        aInRange('u', u, _0n, P);\n        aInRange('scalar', scalar, _0n, P);\n        // Section 5: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.\n        const k = scalar;\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        let sw;\n        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n            const k_t = (k >> t) & _1n;\n            swap ^= k_t;\n            sw = cswap(swap, x_2, x_3);\n            x_2 = sw[0];\n            x_3 = sw[1];\n            sw = cswap(swap, z_2, z_3);\n            z_2 = sw[0];\n            z_3 = sw[1];\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        // (x_2, x_3) = cswap(swap, x_2, x_3)\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        // (z_2, z_3) = cswap(swap, z_2, z_3)\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        // z_2^(p - 2)\n        const z2 = powPminus2(z_2);\n        // Return x_2 * (z_2^(p - 2))\n        return modP(x_2 * z2);\n    }\n    function encodeUCoordinate(u) {\n        return numberToBytesLE(modP(u), montgomeryBytes);\n    }\n    function decodeUCoordinate(uEnc) {\n        // Section 5: When receiving such an array, implementations of X25519\n        // MUST mask the most significant bit in the final byte.\n        const u = ensureBytes('u coordinate', uEnc, montgomeryBytes);\n        if (fieldLen === 32)\n            u[31] &= 127; // 0b0111_1111\n        return bytesToNumberLE(u);\n    }\n    function decodeScalar(n) {\n        const bytes = ensureBytes('scalar', n);\n        const len = bytes.length;\n        if (len !== montgomeryBytes && len !== fieldLen) {\n            let valid = '' + montgomeryBytes + ' or ' + fieldLen;\n            throw new Error('invalid scalar, expected ' + valid + ' bytes, got ' + len);\n        }\n        return bytesToNumberLE(adjustScalarBytes(bytes));\n    }\n    function scalarMult(scalar, u) {\n        const pointU = decodeUCoordinate(u);\n        const _scalar = decodeScalar(scalar);\n        const pu = montgomeryLadder(pointU, _scalar);\n        // The result was not contributory\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n)\n            throw new Error('invalid private or public key received');\n        return encodeUCoordinate(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    const GuBytes = encodeUCoordinate(CURVE.Gu);\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    return {\n        scalarMult,\n        scalarMultBase,\n        getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),\n        getPublicKey: (privateKey) => scalarMultBase(privateKey),\n        utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },\n        GuBytes: GuBytes,\n    };\n}\n//# sourceMappingURL=montgomery.js.map","/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha512';\nimport { concatBytes, randomBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { pippenger } from './abstract/curve.js';\nimport { twistedEdwards } from './abstract/edwards.js';\nimport { createHasher, expand_message_xmd, } from './abstract/hash-to-curve.js';\nimport { Field, FpSqrtEven, isNegativeLE, mod, pow2 } from './abstract/modular.js';\nimport { montgomery } from './abstract/montgomery.js';\nimport { bytesToHex, bytesToNumberLE, ensureBytes, equalBytes, numberToBytesLE, } from './abstract/utils.js';\nconst ED25519_P = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949');\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\nfunction ed25519_pow_2_252_3(x) {\n    // prettier-ignore\n    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n    const P = ED25519_P;\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P; // x^3, 11\n    const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n    const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n    const b10 = (pow2(b5, _5n, P) * b5) % P;\n    const b20 = (pow2(b10, _10n, P) * b10) % P;\n    const b40 = (pow2(b20, _20n, P) * b20) % P;\n    const b80 = (pow2(b40, _40n, P) * b40) % P;\n    const b160 = (pow2(b80, _80n, P) * b80) % P;\n    const b240 = (pow2(b160, _80n, P) * b80) % P;\n    const b250 = (pow2(b240, _10n, P) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ED25519_P;\n    const v3 = mod(v * v * v, P); // v³\n    const v7 = mod(v3 * v3 * v, P); // v⁷\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow, P); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = mod(v * x * x, P); // vx²\n    const root1 = x; // First root candidate\n    const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u, P); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx² = -u√(-1)\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if (isNegativeLE(x, P))\n        x = mod(-x, P);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\n// Just in case\nexport const ED25519_TORSION_SUBGROUP = [\n    '0100000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n    '0000000000000000000000000000000000000000000000000000000000000080',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n    '0000000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\nconst Fp = /* @__PURE__ */ (() => Field(ED25519_P, undefined, true))();\nconst ed25519Defaults = /* @__PURE__ */ (() => ({\n    // Param: a\n    a: BigInt(-1), // Fp.create(-1) is proper; our way still works and is faster\n    // d is equal to -121665/121666 over finite field.\n    // Negative number is P - number, and division is invert(number, P)\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n\n    Fp,\n    // Subgroup order: how many points curve has\n    // 2n**252n + 27742317777372353535851937790883648493n;\n    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n    // Cofactor\n    h: _8n,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n    hash: sha512,\n    randomBytes,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/√v\n    uvRatio,\n}))();\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * import { ed25519 } from '@noble/curves/ed25519';\n * const priv = ed25519.utils.randomPrivateKey();\n * const pub = ed25519.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = ed25519.sign(msg, priv);\n * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215\n * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5\n */\nexport const ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255)\n        throw new Error('Context is too big');\n    return concatBytes(utf8ToBytes('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);\n}\nexport const ed25519ctx = /* @__PURE__ */ (() => twistedEdwards({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n}))();\nexport const ed25519ph = /* @__PURE__ */ (() => twistedEdwards(Object.assign({}, ed25519Defaults, {\n    domain: ed25519_domain,\n    prehash: sha512,\n})))();\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * import { x25519 } from '@noble/curves/ed25519';\n * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\n * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\n * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\n * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\n * x25519.getPublicKey(x25519.utils.randomPrivateKey());\n */\nexport const x25519 = /* @__PURE__ */ (() => montgomery({\n    P: ED25519_P,\n    a: BigInt(486662),\n    montgomeryBits: 255, // n is 253 bits\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: (x) => {\n        const P = ED25519_P;\n        // x^(p-2) aka x^(2^255-21)\n        const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n        return mod(pow2(pow_p_5_8, _3n, P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes,\n}))();\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nexport function edwardsToMontgomeryPub(edwardsPub) {\n    const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n    const _1n = BigInt(1);\n    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nexport const edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nexport function edwardsToMontgomeryPriv(edwardsPriv) {\n    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n    const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n    const ELL2_J = BigInt(486662);\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const inv = Fp.invertBatch([xd, yd]); // batch division\n    return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)\n}\nconst htf = /* @__PURE__ */ (() => createHasher(ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {\n    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha512,\n}))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistPoint))\n        throw new Error('RistrettoPoint expected');\n}\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// √(ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\n// 1 / √(a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\n// 1-d²\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\n// (d-1)²\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n// Calculates 1/√(number)\nconst invertSqrt = (number) => uvRatio(_1n, number);\nconst MAX_255B = /* @__PURE__ */ BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nconst bytes255ToNumberLE = (bytes) => ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!isNegativeLE(s_, P))\n        s_ = mod(-s_);\n    if (!Ns_D_is_sq)\n        s = s_; // 7\n    if (!Ns_D_is_sq)\n        c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */\nclass RistPoint {\n    // Private property to discourage combining ExtendedPoint + RistrettoPoint\n    // Always use Ristretto encoding/decoding instead.\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static fromAffine(ap) {\n        return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n    }\n    /**\n     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n     * The hash-to-group operation applies Elligator twice and adds the results.\n     * **Note:** this is one-way map, there is no conversion from point to hash.\n     * https://ristretto.group/formulas/elligator.html\n     * @param hex 64-byte output of a hash function\n     */\n    static hashToCurve(hex) {\n        hex = ensureBytes('ristrettoHash', hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = calcElligatorRistrettoMap(r2);\n        return new RistPoint(R1.add(R2));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * https://ristretto.group/formulas/decoding.html\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */\n    static fromHex(hex) {\n        hex = ensureBytes('ristrettoHex', hex, 32);\n        const { a, d } = ed25519.CURVE;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!equalBytes(numberToBytesLE(s, 32), hex) || isNegativeLE(s, P))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if (isNegativeLE(x, P))\n            x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || isNegativeLE(t, P) || y === _0n)\n            throw new Error(emsg);\n        return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n    }\n    static msm(points, scalars) {\n        const Fn = Field(ed25519.CURVE.n, ed25519.CURVE.nBitLength);\n        return pippenger(RistPoint, Fn, points, scalars);\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * https://ristretto.group/formulas/encoding.html\n     */\n    toRawBytes() {\n        let { ex: x, ey: y, ez: z, et: t } = this.ep;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const u1 = mod(mod(z + y) * mod(z - y)); // 1\n        const u2 = mod(x * y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * t); // 6\n        let D; // 7\n        if (isNegativeLE(t * zInv, P)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2; // 8\n        }\n        if (isNegativeLE(x * zInv, P))\n            y = mod(-y); // 9\n        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n        if (isNegativeLE(s, P))\n            s = mod(-s);\n        return numberToBytesLE(s, 32); // 11\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    // Compare one point to another.\n    equals(other) {\n        assertRstPoint(other);\n        const { ex: X1, ey: Y1 } = this.ep;\n        const { ex: X2, ey: Y2 } = other.ep;\n        const mod = ed25519.CURVE.Fp.create;\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistPoint(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return new RistPoint(this.ep.double());\n    }\n    negate() {\n        return new RistPoint(this.ep.negate());\n    }\n}\nexport const RistrettoPoint = /* @__PURE__ */ (() => {\n    if (!RistPoint.BASE)\n        RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n    if (!RistPoint.ZERO)\n        RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n    return RistPoint;\n})();\n// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B\nexport const hashToRistretto255 = (msg, options) => {\n    const d = options.DST;\n    const DST = typeof d === 'string' ? utf8ToBytes(d) : d;\n    const uniform_bytes = expand_message_xmd(msg, DST, 64, sha512);\n    const P = RistPoint.hashToCurve(uniform_bytes);\n    return P;\n};\nexport const hash_to_ristretto255 = hashToRistretto255; // legacy\n//# sourceMappingURL=ed25519.js.map","/**\n * Short Weierstrass curve methods. The formula is: y² = x³ + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { pippenger, validateBasic, wNAF, } from './curve.js';\nimport { Field, getMinHashLength, invert, mapHashToField, mod, validateField, } from './modular.js';\nimport * as ut from './utils.js';\nimport { abool, ensureBytes, memoized } from './utils.js';\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined)\n        abool('lowS', opts.lowS);\n    if (opts.prehash !== undefined)\n        abool('prehash', opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('invalid endomorphism, can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('invalid endomorphism, expected beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexport class DERErr extends Error {\n    constructor(m = '') {\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = ut.numberToHexUnpadded(dataLen);\n            if ((len.length / 2) & 128)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? ut.numberToHexUnpadded((len.length / 2) | 128) : '';\n            const t = ut.numberToHexUnpadded(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = ut.numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = DER;\n            if (data[0] & 128)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return b2n(data);\n        },\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        ut.abytes(data);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nexport function weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = Field(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return ut.inRange(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (ut.isBytes(key))\n                key = ut.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('invalid private key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error('invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key);\n        }\n        if (wrapPrivateKey)\n            num = mod(num, N); // disabled by default, enabled for BLS\n        ut.aInRange('private key', num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ∋ (x=x/z, y=y/z)\n    const toAffineMemo = memoized((p, iz) => {\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE))\n            return { x, y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = memoized((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not FE');\n        const left = Fp.sqr(y); // y²\n        const right = weierstrassEquation(x); // x³ + ax + b\n        if (!Fp.eql(left, right))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n            Object.freeze(this);\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return pippenger(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo, n: N } = CURVE;\n            ut.aInRange('scalar', sc, _0n, N);\n            const I = Point.ZERO;\n            if (sc === _0n)\n                return I;\n            if (this.is0() || sc === _1n)\n                return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this))\n                return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            ut.aInRange('scalar', scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            abool('isCompressed', isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            abool('isCompressed', isCompressed);\n            return ut.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */\nexport function weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = ut.concatBytes;\n            abool('isCompressed', isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = ut.bytesToNumberBE(tail);\n                if (!ut.inRange(x, _1n, Fp.ORDER))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error('invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len);\n            }\n        },\n    });\n    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = ensureBytes('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig(ensureBytes('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            ut.aInRange('r', this.r, _1n, CURVE_ORDER); // r in [1..N]\n            ut.aInRange('s', this.s, _1n, CURVE_ORDER); // s in [1..N]\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return ut.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return ut.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = getMinHashLength(CURVE.n);\n            return mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = ut.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // Our custom check \"just in case\"\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        ut.aInRange('num < 2^' + CURVE.nBitLength, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return ut.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = ensureBytes('msgHash', msgHash);\n        validateSigVerOpts(opts);\n        if (prehash)\n            msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n        }\n        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = ensureBytes('msgHash', msgHash);\n        publicKey = ensureBytes('publicKey', publicKey);\n        const { lowS, prehash, format } = opts;\n        // Verify opts, deduce signature format\n        validateSigVerOpts(opts);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        if (format !== undefined && format !== 'compact' && format !== 'der')\n            throw new Error('format must be compact or der');\n        const isHex = typeof sg === 'string' || ut.isBytes(sg);\n        const isObj = !isHex &&\n            !format &&\n            typeof sg === 'object' &&\n            sg !== null &&\n            typeof sg.r === 'bigint' &&\n            typeof sg.s === 'bigint';\n        if (!isHex && !isObj)\n            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj)\n                _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== 'compact')\n                        _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                }\n                if (!_sig && format !== 'der')\n                    _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n        if (!_sig)\n            return false;\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n    validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map","/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport { weierstrass } from './abstract/weierstrass.js';\n/** connects noble-curves to noble-hashes */\nexport function getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => hmac(hash, key, concatBytes(...msgs)),\n        randomBytes,\n    };\n}\nexport function createCurve(curveDef, defHash) {\n    const create = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });\n    return { ...create(defHash), create };\n}\n//# sourceMappingURL=_shortw_utils.js.map","/**\n * NIST secp256r1 aka p256.\n * https://www.secg.org/sec2-v2.pdf, https://neuromancer.sk/std/nist/P-256\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { createCurve } from './_shortw_utils.js';\nimport { createHasher } from './abstract/hash-to-curve.js';\nimport { Field } from './abstract/modular.js';\nimport { mapToCurveSimpleSWU } from './abstract/weierstrass.js';\nconst Fp256 = Field(BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'));\nconst CURVE_A = Fp256.create(BigInt('-3'));\nconst CURVE_B = BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b');\n/** secp256r1 curve, ECDSA and ECDH methods. */\n// prettier-ignore\nexport const p256 = createCurve({\n    a: CURVE_A, // Equation params: a, b\n    b: CURVE_B,\n    Fp: Fp256, // Field: 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n\n    // Curve order, total count of valid points in the field\n    n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n    // Base (generator) point (x, y)\n    Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n    Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n    h: BigInt(1),\n    lowS: false,\n}, sha256);\n/** Alias to p256. */\nexport const secp256r1 = p256;\nconst mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fp256, {\n    A: CURVE_A,\n    B: CURVE_B,\n    Z: Fp256.create(BigInt('-10')),\n}))();\nconst htf = /* @__PURE__ */ (() => createHasher(secp256r1.ProjectivePoint, (scalars) => mapSWU(scalars[0]), {\n    DST: 'P256_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'P256_XMD:SHA-256_SSWU_NU_',\n    p: Fp256.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n}))();\n/** secp256r1 hash-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\n/** secp256r1 encode-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=p256.js.map","import { chacha20poly1305 } from \"@noble/ciphers/chacha\";\nimport { hkdf } from \"@noble/hashes/hkdf\";\nimport { randomBytes } from \"@noble/hashes/utils\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { x25519 } from \"@noble/curves/ed25519\";\nimport { p256 } from \"@noble/curves/p256\";\nimport { CryptoTypes } from \"@walletconnect/types\";\nimport { decodeJWT } from \"@walletconnect/relay-auth\";\nimport { concat, fromString, toString } from \"uint8arrays\";\n\nexport const BASE10 = \"base10\";\nexport const BASE16 = \"base16\";\nexport const BASE64 = \"base64pad\";\nexport const BASE64URL = \"base64url\";\nexport const UTF8 = \"utf8\";\n\nexport const TYPE_0 = 0;\nexport const TYPE_1 = 1;\nexport const TYPE_2 = 2;\n\nexport type P256KeyDataType = {\n  crv: \"P-256\" | string;\n  ext: true | boolean;\n  key_ops: [\"verify\"] | string[];\n  kty: string;\n  x: string;\n  y: string;\n};\n\nconst ZERO_INDEX = 0;\nconst TYPE_LENGTH = 1;\nconst IV_LENGTH = 12;\nconst KEY_LENGTH = 32;\n\nexport function generateKeyPair(): CryptoTypes.KeyPair {\n  const privateKey = x25519.utils.randomPrivateKey();\n  const publicKey = x25519.getPublicKey(privateKey);\n  return {\n    privateKey: toString(privateKey, BASE16),\n    publicKey: toString(publicKey, BASE16),\n  };\n}\n\nexport function generateRandomBytes32(): string {\n  const random = randomBytes(KEY_LENGTH);\n  return toString(random, BASE16);\n}\n\nexport function deriveSymKey(privateKeyA: string, publicKeyB: string): string {\n  const sharedKey = x25519.getSharedSecret(\n    fromString(privateKeyA, BASE16),\n    fromString(publicKeyB, BASE16),\n  );\n  const symKey = hkdf(sha256, sharedKey, undefined, undefined, KEY_LENGTH);\n  return toString(symKey, BASE16);\n}\n\nexport function hashKey(key: string): string {\n  const result = sha256(fromString(key, BASE16));\n  return toString(result, BASE16);\n}\n\nexport function hashMessage(message: string): string {\n  const result = sha256(fromString(message, UTF8));\n  return toString(result, BASE16);\n}\n\nexport function encodeTypeByte(type: number): Uint8Array {\n  return fromString(`${type}`, BASE10);\n}\n\nexport function decodeTypeByte(byte: Uint8Array): number {\n  return Number(toString(byte, BASE10));\n}\n\nfunction toBase64URL(base64: string): string {\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\n\nfunction fromBase64URL(base64url: string): string {\n  const base64 = base64url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const padding = (4 - (base64.length % 4)) % 4;\n  return base64 + \"=\".repeat(padding);\n}\n\nexport function encrypt(params: CryptoTypes.EncryptParams): string {\n  const type = encodeTypeByte(typeof params.type !== \"undefined\" ? params.type : TYPE_0);\n  if (decodeTypeByte(type) === TYPE_1 && typeof params.senderPublicKey === \"undefined\") {\n    throw new Error(\"Missing sender public key for type 1 envelope\");\n  }\n  const senderPublicKey =\n    typeof params.senderPublicKey !== \"undefined\"\n      ? fromString(params.senderPublicKey, BASE16)\n      : undefined;\n\n  const iv =\n    typeof params.iv !== \"undefined\" ? fromString(params.iv, BASE16) : randomBytes(IV_LENGTH);\n  const key = fromString(params.symKey, BASE16);\n  const box = chacha20poly1305(key, iv);\n  const sealed = box.encrypt(fromString(params.message, UTF8));\n  const result = serialize({ type, sealed, iv, senderPublicKey });\n  return params.encoding === BASE64URL ? toBase64URL(result) : result;\n}\n\nexport function decrypt(params: CryptoTypes.DecryptParams): string {\n  const key = fromString(params.symKey, BASE16);\n  const { sealed, iv } = deserialize({ encoded: params.encoded, encoding: params.encoding });\n  const box = chacha20poly1305(key, iv);\n  const message = box.decrypt(sealed);\n  if (message === null) throw new Error(\"Failed to decrypt\");\n  return toString(message, UTF8);\n}\n\nexport function encodeTypeTwoEnvelope(\n  message: string,\n  encoding?: CryptoTypes.EncodingType,\n): string {\n  const type = encodeTypeByte(TYPE_2);\n  // iv is not used in type 2 envelopes\n  const iv = randomBytes(IV_LENGTH);\n  const sealed = fromString(message, UTF8);\n  const result = serialize({ type, sealed, iv });\n  return encoding === BASE64URL ? toBase64URL(result) : result;\n}\n\nexport function decodeTypeTwoEnvelope(\n  encoded: string,\n  encoding?: CryptoTypes.EncodingType,\n): string {\n  const { sealed } = deserialize({ encoded, encoding });\n  return toString(sealed, UTF8);\n}\n\nexport function serialize(params: CryptoTypes.EncodingParams): string {\n  if (decodeTypeByte(params.type) === TYPE_2) {\n    return toString(concat([params.type, params.sealed]), BASE64);\n  }\n  if (decodeTypeByte(params.type) === TYPE_1) {\n    if (typeof params.senderPublicKey === \"undefined\") {\n      throw new Error(\"Missing sender public key for type 1 envelope\");\n    }\n    return toString(\n      concat([params.type, params.senderPublicKey, params.iv, params.sealed]),\n      BASE64,\n    );\n  }\n  // default to type 0 envelope\n  return toString(concat([params.type, params.iv, params.sealed]), BASE64);\n}\n\nexport function deserialize(params: CryptoTypes.DecodingParams): CryptoTypes.EncodingParams {\n  const encoding = params.encoding || BASE64;\n  const normalizedEncoded = encoding === BASE64URL ? fromBase64URL(params.encoded) : params.encoded;\n  const bytes = fromString(normalizedEncoded, BASE64);\n  const type = bytes.slice(ZERO_INDEX, TYPE_LENGTH);\n  const slice1 = TYPE_LENGTH;\n  if (decodeTypeByte(type) === TYPE_1) {\n    const slice2 = slice1 + KEY_LENGTH;\n    const slice3 = slice2 + IV_LENGTH;\n    const senderPublicKey = bytes.slice(slice1, slice2);\n    const iv = bytes.slice(slice2, slice3);\n    const sealed = bytes.slice(slice3);\n    return { type, sealed, iv, senderPublicKey };\n  }\n  if (decodeTypeByte(type) === TYPE_2) {\n    const sealed = bytes.slice(slice1);\n    // iv is not used in type 2 envelopes\n    const iv = randomBytes(IV_LENGTH);\n    return { type, sealed, iv };\n  }\n  // default to type 0 envelope\n  const slice2 = slice1 + IV_LENGTH;\n  const iv = bytes.slice(slice1, slice2);\n  const sealed = bytes.slice(slice2);\n  return { type, sealed, iv };\n}\n\nexport function validateDecoding(\n  encoded: string,\n  opts?: CryptoTypes.DecodeOptions,\n): CryptoTypes.EncodingValidation {\n  const deserialized = deserialize({ encoded, encoding: opts?.encoding });\n  return validateEncoding({\n    type: decodeTypeByte(deserialized.type),\n    senderPublicKey:\n      typeof deserialized.senderPublicKey !== \"undefined\"\n        ? toString(deserialized.senderPublicKey, BASE16)\n        : undefined,\n    receiverPublicKey: opts?.receiverPublicKey,\n  });\n}\n\nexport function validateEncoding(opts?: CryptoTypes.EncodeOptions): CryptoTypes.EncodingValidation {\n  const type = opts?.type || TYPE_0;\n  if (type === TYPE_1) {\n    if (typeof opts?.senderPublicKey === \"undefined\") {\n      throw new Error(\"missing sender public key\");\n    }\n    if (typeof opts?.receiverPublicKey === \"undefined\") {\n      throw new Error(\"missing receiver public key\");\n    }\n  }\n  return {\n    type,\n    senderPublicKey: opts?.senderPublicKey,\n    receiverPublicKey: opts?.receiverPublicKey,\n  };\n}\n\nexport function isTypeOneEnvelope(\n  result: CryptoTypes.EncodingValidation,\n): result is CryptoTypes.TypeOneParams {\n  return (\n    result.type === TYPE_1 &&\n    typeof result.senderPublicKey === \"string\" &&\n    typeof result.receiverPublicKey === \"string\"\n  );\n}\n\nexport function isTypeTwoEnvelope(\n  result: CryptoTypes.EncodingValidation,\n): result is CryptoTypes.TypeOneParams {\n  return result.type === TYPE_2;\n}\n\nexport function getCryptoKeyFromKeyData(keyData: P256KeyDataType): Uint8Array {\n  const xBuffer = Buffer.from(keyData.x, \"base64\");\n  const yBuffer = Buffer.from(keyData.y, \"base64\");\n\n  // Concatenate x and y coordinates with 0x04 prefix (uncompressed point format)\n  return concat([new Uint8Array([0x04]), xBuffer, yBuffer]);\n}\n\nexport function verifyP256Jwt<T>(token: string, keyData: P256KeyDataType) {\n  const [headerBase64Url, payloadBase64Url, signatureBase64Url] = token.split(\".\");\n\n  // Decode the signature\n  const signatureBuffer = Buffer.from(fromBase64URL(signatureBase64Url), \"base64\");\n\n  // Check if signature length is correct (64 bytes for P-256)\n  if (signatureBuffer.length !== 64) {\n    throw new Error(\"Invalid signature length\");\n  }\n\n  // Extract r and s from the signature\n  const r = signatureBuffer.slice(0, 32);\n  const s = signatureBuffer.slice(32, 64);\n\n  // Create the signing input\n  const signingInput = `${headerBase64Url}.${payloadBase64Url}`;\n\n  // Hash the signing input\n  const messageHash = sha256(signingInput);\n\n  // Get the public key in uncompressed point format\n  const publicKey = getCryptoKeyFromKeyData(keyData);\n\n  // Verify the signature using noble/curves p256\n  const isValid = p256.verify(\n    concat([r, s]), // signature bytes\n    messageHash, // message hash\n    publicKey, // public key in uncompressed format\n  );\n\n  if (!isValid) {\n    throw new Error(\"Invalid signature\");\n  }\n\n  const data = decodeJWT(token) as unknown as { payload: T };\n  return data.payload;\n}\n","import { RELAY_JSONRPC } from \"@walletconnect/relay-api\";\nimport { RelayerTypes } from \"@walletconnect/types\";\n\nexport const RELAYER_DEFAULT_PROTOCOL = \"irn\";\n\nexport function getRelayProtocolName(\n  opts?: RelayerTypes.RequestOptions,\n): RelayerTypes.ProtocolOptions {\n  return opts?.relay || { protocol: RELAYER_DEFAULT_PROTOCOL };\n}\n\nexport function getRelayProtocolApi(protocol: string) {\n  const jsonrpc = RELAY_JSONRPC[protocol];\n  if (typeof jsonrpc === \"undefined\") {\n    throw new Error(`Relay Protocol not supported: ${protocol}`);\n  }\n  return jsonrpc;\n}\n","import { EngineTypes, RelayerTypes } from \"@walletconnect/types\";\nimport { fromBase64 } from \"./misc\";\n\n// -- uri -------------------------------------------------- //\n\nexport function parseRelayParams(params: any, delimiter = \"-\"): RelayerTypes.ProtocolOptions {\n  const relay: any = {};\n  const prefix = \"relay\" + delimiter;\n  Object.keys(params).forEach((key) => {\n    if (key.startsWith(prefix)) {\n      const name = key.replace(prefix, \"\");\n      const value = params[key];\n      relay[name] = value;\n    }\n  });\n  return relay;\n}\n\nexport function parseUri(str: string): EngineTypes.UriParameters {\n  if (!str.includes(\"wc:\")) {\n    const parsed = fromBase64(str);\n    if (parsed?.includes(\"wc:\")) {\n      str = parsed;\n    }\n  }\n\n  // remove android schema prefix\n  str = str.includes(\"wc://\") ? str.replace(\"wc://\", \"\") : str;\n  // remove ios schema prefix\n  str = str.includes(\"wc:\") ? str.replace(\"wc:\", \"\") : str;\n  const pathStart: number = str.indexOf(\":\");\n  const pathEnd: number | undefined = str.indexOf(\"?\") !== -1 ? str.indexOf(\"?\") : undefined;\n  const protocol: string = str.substring(0, pathStart);\n  const path: string = str.substring(pathStart + 1, pathEnd);\n  const requiredValues = path.split(\"@\");\n  const queryString: string = typeof pathEnd !== \"undefined\" ? str.substring(pathEnd) : \"\";\n  const urlSearchParams = new URLSearchParams(queryString);\n  const queryParams: Record<string, string> = {};\n  urlSearchParams.forEach((value, key) => {\n    queryParams[key] = value;\n  });\n  const methods =\n    typeof queryParams.methods === \"string\" ? queryParams.methods.split(\",\") : undefined;\n  const result = {\n    protocol,\n    topic: parseTopic(requiredValues[0]),\n    version: parseInt(requiredValues[1], 10),\n    symKey: queryParams.symKey as string,\n    relay: parseRelayParams(queryParams),\n    methods,\n    expiryTimestamp: queryParams.expiryTimestamp\n      ? parseInt(queryParams.expiryTimestamp as string, 10)\n      : undefined,\n  };\n  return result;\n}\n\nexport function parseTopic(topic: string): string {\n  return topic.startsWith(\"//\") ? topic.substring(2) : topic;\n}\n\nexport function formatRelayParams(relay: RelayerTypes.ProtocolOptions, delimiter = \"-\") {\n  const prefix = \"relay\";\n  const params: any = {};\n  Object.keys(relay).forEach((key) => {\n    const typedKey = key as keyof typeof relay;\n    const k = prefix + delimiter + typedKey;\n    if (relay[typedKey]) {\n      params[k] = relay[typedKey];\n    }\n  });\n  return params;\n}\n\nexport function formatUri(params: EngineTypes.UriParameters): string {\n  const urlSearchParams = new URLSearchParams();\n\n  const relayParams = formatRelayParams(params.relay);\n  Object.keys(relayParams)\n    .sort()\n    .forEach((key) => {\n      urlSearchParams.set(key, relayParams[key]);\n    });\n\n  urlSearchParams.set(\"symKey\", params.symKey);\n  if (params.expiryTimestamp)\n    urlSearchParams.set(\"expiryTimestamp\", params.expiryTimestamp.toString());\n\n  if (params.methods) {\n    urlSearchParams.set(\"methods\", params.methods.join(\",\"));\n  }\n\n  const queryString = urlSearchParams.toString();\n  return `${params.protocol}:${params.topic}@${params.version}?${queryString}`;\n}\n\nexport function getLinkModeURL(\n  universalLink: string,\n  topic: string,\n  encodedEnvelope: string,\n): string {\n  return `${universalLink}?wc_ev=${encodedEnvelope}&topic=${topic}`;\n}\n","import { ProposalTypes, SessionTypes } from \"@walletconnect/types\";\nimport { mergeArrays } from \"./misc\";\nimport { isConformingNamespaces, isValidNamespaces, isValidObject } from \"./validators\";\n\nexport function getAccountsChains(accounts: SessionTypes.Namespace[\"accounts\"]) {\n  const chains: string[] = [];\n  accounts.forEach((account) => {\n    const [chain, chainId] = account.split(\":\");\n    chains.push(`${chain}:${chainId}`);\n  });\n\n  return chains;\n}\n\nexport function getNamespacesChains(namespaces: SessionTypes.Namespaces) {\n  const chains: string[] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    chains.push(...getAccountsChains(namespace.accounts));\n  });\n\n  return chains;\n}\n\nexport function getNamespacesMethodsForChainId(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n) {\n  const methods: SessionTypes.Namespace[\"methods\"] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    const chains = getAccountsChains(namespace.accounts);\n    if (chains.includes(chainId)) methods.push(...namespace.methods);\n  });\n\n  return methods;\n}\n\nexport function getNamespacesEventsForChainId(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n) {\n  const events: SessionTypes.Namespace[\"events\"] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    const chains = getAccountsChains(namespace.accounts);\n    if (chains.includes(chainId)) events.push(...namespace.events);\n  });\n\n  return events;\n}\n\nexport function getRequiredNamespacesFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  caller: string,\n): ProposalTypes.RequiredNamespaces {\n  const validNamespacesError = isValidNamespaces(namespaces, caller);\n  if (validNamespacesError) throw new Error(validNamespacesError.message);\n\n  const required: ProposalTypes.RequiredNamespaces = {};\n  for (const [namespace, values] of Object.entries(namespaces)) {\n    required[namespace] = {\n      methods: values.methods,\n      events: values.events,\n      chains: values.accounts.map((account) => `${account.split(\":\")[0]}:${account.split(\":\")[1]}`),\n    };\n  }\n  return required;\n}\n\nexport type BuildApprovedNamespacesParams = {\n  proposal: ProposalTypes.Struct;\n  supportedNamespaces: Record<\n    string,\n    { chains: string[]; methods: string[]; events: string[]; accounts: string[] }\n  >;\n};\n\n/**\n * util designed for Wallets that builds namespaces structure by provided supported chains, methods, events & accounts.\n * It takes required & optional namespaces provided in the session proposal\n * along with the supported chains/methods/events/accounts by the wallet and returns a structured namespaces object\n * @param {BuildApprovedNamespacesParams} params\n * @returns {SessionTypes.Namespaces}\n */\nexport function buildApprovedNamespaces(\n  params: BuildApprovedNamespacesParams,\n): SessionTypes.Namespaces {\n  const {\n    proposal: { requiredNamespaces, optionalNamespaces = {} },\n    supportedNamespaces,\n  } = params;\n  const normalizedRequired = normalizeNamespaces(requiredNamespaces);\n  const normalizedOptional = normalizeNamespaces(optionalNamespaces);\n\n  // build approved namespaces\n  const namespaces: SessionTypes.Namespaces = {};\n  Object.keys(supportedNamespaces).forEach((namespace) => {\n    const supportedChains = supportedNamespaces[namespace].chains;\n    const supportedMethods = supportedNamespaces[namespace].methods;\n    const supportedEvents = supportedNamespaces[namespace].events;\n    const supportedAccounts = supportedNamespaces[namespace].accounts;\n\n    supportedChains.forEach((chain) => {\n      if (!supportedAccounts.some((account) => account.includes(chain))) {\n        throw new Error(`No accounts provided for chain ${chain} in namespace ${namespace}`);\n      }\n    });\n\n    namespaces[namespace] = {\n      chains: supportedChains,\n      methods: supportedMethods,\n      events: supportedEvents,\n      accounts: supportedAccounts,\n    };\n  });\n\n  // verify all required namespaces are supported\n  const err = isConformingNamespaces(requiredNamespaces, namespaces, \"approve()\");\n  if (err) throw new Error(err.message);\n\n  const approvedNamespaces: SessionTypes.Namespaces = {};\n\n  // if both required & optional namespaces are empty, return all supported namespaces by the wallet\n  if (!Object.keys(requiredNamespaces).length && !Object.keys(optionalNamespaces).length)\n    return namespaces;\n\n  // assign accounts for the required namespaces\n  Object.keys(normalizedRequired).forEach((requiredNamespace) => {\n    const chains = supportedNamespaces[requiredNamespace].chains.filter((chain) =>\n      normalizedRequired[requiredNamespace]?.chains?.includes(chain),\n    );\n    const methods = supportedNamespaces[requiredNamespace].methods.filter((method) =>\n      normalizedRequired[requiredNamespace]?.methods?.includes(method),\n    );\n    const events = supportedNamespaces[requiredNamespace].events.filter((event) =>\n      normalizedRequired[requiredNamespace]?.events?.includes(event),\n    );\n\n    const accounts = chains\n      .map((chain: string) =>\n        supportedNamespaces[requiredNamespace].accounts.filter((account: string) =>\n          account.includes(`${chain}:`),\n        ),\n      )\n      .flat();\n\n    approvedNamespaces[requiredNamespace] = {\n      chains,\n      methods,\n      events,\n      accounts,\n    };\n  });\n\n  // add optional namespaces\n  Object.keys(normalizedOptional).forEach((optionalNamespace) => {\n    if (!supportedNamespaces[optionalNamespace]) return;\n\n    const chainsToAdd = normalizedOptional[optionalNamespace]?.chains?.filter((chain) =>\n      supportedNamespaces[optionalNamespace].chains.includes(chain),\n    );\n    const methodsToAdd = supportedNamespaces[optionalNamespace].methods.filter((method) =>\n      normalizedOptional[optionalNamespace]?.methods?.includes(method),\n    );\n    const eventsToAdd = supportedNamespaces[optionalNamespace].events.filter((event) =>\n      normalizedOptional[optionalNamespace]?.events?.includes(event),\n    );\n\n    const accountsToAdd = chainsToAdd\n      ?.map((chain: string) =>\n        supportedNamespaces[optionalNamespace].accounts.filter((account: string) =>\n          account.includes(`${chain}:`),\n        ),\n      )\n      .flat();\n\n    approvedNamespaces[optionalNamespace] = {\n      chains: mergeArrays(approvedNamespaces[optionalNamespace]?.chains, chainsToAdd),\n      methods: mergeArrays(approvedNamespaces[optionalNamespace]?.methods, methodsToAdd),\n      events: mergeArrays(approvedNamespaces[optionalNamespace]?.events, eventsToAdd),\n      accounts: mergeArrays(approvedNamespaces[optionalNamespace]?.accounts, accountsToAdd),\n    };\n  });\n\n  return approvedNamespaces;\n}\n\nexport function isCaipNamespace(namespace: string): boolean {\n  return namespace.includes(\":\");\n}\n\nexport function parseNamespaceKey(namespace: string) {\n  return isCaipNamespace(namespace) ? namespace.split(\":\")[0] : namespace;\n}\n\n/**\n * Converts\n * ```\n * {\n *  \"eip155:1\": {...},\n *  \"eip155:2\": {...},\n * }\n * ```\n * into\n * ```\n * {\n *  \"eip155\": {\n *      chains: [\"eip155:1\", \"eip155:2\"],\n *      ...\n *    }\n * }\n *```\n */\nexport function normalizeNamespaces(\n  namespaces: ProposalTypes.RequiredNamespaces,\n): ProposalTypes.RequiredNamespaces {\n  const normalizedNamespaces = {} as ProposalTypes.RequiredNamespaces;\n  if (!isValidObject(namespaces)) return normalizedNamespaces;\n  for (const [key, values] of Object.entries(namespaces)) {\n    const chains = isCaipNamespace(key) ? [key] : values.chains;\n    const methods = values.methods || [];\n    const events = values.events || [];\n    const normalizedKey = parseNamespaceKey(key);\n    normalizedNamespaces[normalizedKey] = {\n      ...normalizedNamespaces[normalizedKey],\n      chains: mergeArrays(chains, normalizedNamespaces[normalizedKey]?.chains),\n      methods: mergeArrays(methods, normalizedNamespaces[normalizedKey]?.methods),\n      events: mergeArrays(events, normalizedNamespaces[normalizedKey]?.events),\n    };\n  }\n  return normalizedNamespaces;\n}\n\nexport function getNamespacesFromAccounts(accounts: string[]) {\n  const namespaces: SessionTypes.Namespaces = {};\n  accounts?.forEach((account) => {\n    const [namespace, chainId] = account.split(\":\");\n    if (!namespaces[namespace]) {\n      namespaces[namespace] = {\n        accounts: [],\n        chains: [],\n        events: [],\n        methods: [],\n      };\n    }\n    namespaces[namespace].accounts.push(account);\n    namespaces[namespace].chains?.push(`${namespace}:${chainId}`);\n  });\n\n  return namespaces;\n}\n\nexport function buildNamespacesFromAuth(methods: string[], accounts: string[]) {\n  accounts = accounts.map((account) => account.replace(\"did:pkh:\", \"\"));\n\n  const namespaces = getNamespacesFromAccounts(accounts);\n\n  for (const [_, values] of Object.entries(namespaces) as [string, SessionTypes.Namespace][]) {\n    if (!values.methods) {\n      values.methods = methods;\n    } else {\n      values.methods = mergeArrays(values.methods, methods);\n    }\n    values.events = [\"chainChanged\", \"accountsChanged\"];\n  }\n  return namespaces;\n}\n\nexport function mergeRequiredAndOptionalNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  optionalNamespaces: ProposalTypes.OptionalNamespaces,\n) {\n  const normalizedRequired = normalizeNamespaces(requiredNamespaces);\n  const normalizedOptional = normalizeNamespaces(optionalNamespaces);\n\n  const mergedNamespaces: ProposalTypes.OptionalNamespaces = {};\n\n  const combinedNamespaces = Object.keys(normalizedRequired).concat(\n    Object.keys(normalizedOptional),\n  );\n\n  for (const namespace of combinedNamespaces) {\n    mergedNamespaces[namespace] = {\n      chains: mergeArrays(\n        normalizedRequired[namespace]?.chains,\n        normalizedOptional[namespace]?.chains,\n      ),\n      methods: mergeArrays(\n        normalizedRequired[namespace]?.methods,\n        normalizedOptional[namespace]?.methods,\n      ),\n      events: mergeArrays(\n        normalizedRequired[namespace]?.events,\n        normalizedOptional[namespace]?.events,\n      ),\n    };\n  }\n\n  return mergedNamespaces;\n}\n","/**\n * Types\n */\nexport type SdkErrorKey = keyof typeof SDK_ERRORS;\nexport type InternalErrorKey = keyof typeof INTERNAL_ERRORS;\n\n/**\n * Constants\n */\nexport const SDK_ERRORS = {\n  /* ----- INVALID (1xxx) ----- */\n  INVALID_METHOD: {\n    message: \"Invalid method.\",\n    code: 1001,\n  },\n  INVALID_EVENT: {\n    message: \"Invalid event.\",\n    code: 1002,\n  },\n  INVALID_UPDATE_REQUEST: {\n    message: \"Invalid update request.\",\n    code: 1003,\n  },\n  INVALID_EXTEND_REQUEST: {\n    message: \"Invalid extend request.\",\n    code: 1004,\n  },\n  INVALID_SESSION_SETTLE_REQUEST: {\n    message: \"Invalid session settle request.\",\n    code: 1005,\n  },\n  /* ----- UNAUTHORIZED (3xxx) ----- */\n  UNAUTHORIZED_METHOD: {\n    message: \"Unauthorized method.\",\n    code: 3001,\n  },\n  UNAUTHORIZED_EVENT: {\n    message: \"Unauthorized event.\",\n    code: 3002,\n  },\n  UNAUTHORIZED_UPDATE_REQUEST: {\n    message: \"Unauthorized update request.\",\n    code: 3003,\n  },\n  UNAUTHORIZED_EXTEND_REQUEST: {\n    message: \"Unauthorized extend request.\",\n    code: 3004,\n  },\n  /* ----- REJECTED (5xxx) ----- */\n  USER_REJECTED: {\n    message: \"User rejected.\",\n    code: 5000,\n  },\n  USER_REJECTED_CHAINS: {\n    message: \"User rejected chains.\",\n    code: 5001,\n  },\n  USER_REJECTED_METHODS: {\n    message: \"User rejected methods.\",\n    code: 5002,\n  },\n  USER_REJECTED_EVENTS: {\n    message: \"User rejected events.\",\n    code: 5003,\n  },\n  UNSUPPORTED_CHAINS: {\n    message: \"Unsupported chains.\",\n    code: 5100,\n  },\n  UNSUPPORTED_METHODS: {\n    message: \"Unsupported methods.\",\n    code: 5101,\n  },\n  UNSUPPORTED_EVENTS: {\n    message: \"Unsupported events.\",\n    code: 5102,\n  },\n  UNSUPPORTED_ACCOUNTS: {\n    message: \"Unsupported accounts.\",\n    code: 5103,\n  },\n  UNSUPPORTED_NAMESPACE_KEY: {\n    message: \"Unsupported namespace key.\",\n    code: 5104,\n  },\n  /* ----- REASON (6xxx) ----- */\n  USER_DISCONNECTED: {\n    message: \"User disconnected.\",\n    code: 6000,\n  },\n  /* ----- FAILURE (7xxx) ----- */\n  SESSION_SETTLEMENT_FAILED: {\n    message: \"Session settlement failed.\",\n    code: 7000,\n  },\n  /* ----- PAIRING (10xxx) ----- */\n  WC_METHOD_UNSUPPORTED: {\n    message: \"Unsupported wc_ method.\",\n    code: 10001,\n  },\n};\n\nexport const INTERNAL_ERRORS = {\n  NOT_INITIALIZED: {\n    message: \"Not initialized.\",\n    code: 1,\n  },\n  NO_MATCHING_KEY: {\n    message: \"No matching key.\",\n    code: 2,\n  },\n  RESTORE_WILL_OVERRIDE: {\n    message: \"Restore will override.\",\n    code: 3,\n  },\n  RESUBSCRIBED: {\n    message: \"Resubscribed.\",\n    code: 4,\n  },\n  MISSING_OR_INVALID: {\n    message: \"Missing or invalid.\",\n    code: 5,\n  },\n  EXPIRED: {\n    message: \"Expired.\",\n    code: 6,\n  },\n  UNKNOWN_TYPE: {\n    message: \"Unknown type.\",\n    code: 7,\n  },\n  MISMATCHED_TOPIC: {\n    message: \"Mismatched topic.\",\n    code: 8,\n  },\n  NON_CONFORMING_NAMESPACES: {\n    message: \"Non conforming namespaces.\",\n    code: 9,\n  },\n};\n\n/**\n * Utilities\n */\nexport function getInternalError(key: InternalErrorKey, context?: string | number) {\n  const { message, code } = INTERNAL_ERRORS[key];\n  return {\n    message: context ? `${message} ${context}` : message,\n    code,\n  };\n}\n\nexport function getSdkError(key: SdkErrorKey, context?: string | number) {\n  const { message, code } = SDK_ERRORS[key];\n  return {\n    message: context ? `${message} ${context}` : message,\n    code,\n  };\n}\n","import { SessionTypes, ProposalTypes, RelayerTypes, EngineTypes } from \"@walletconnect/types\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport {\n  getNamespacesChains,\n  getNamespacesMethodsForChainId,\n  getNamespacesEventsForChainId,\n  getAccountsChains,\n} from \"./namespaces\";\nimport { getSdkError, getInternalError } from \"./errors\";\nimport { fromBase64, hasOverlap } from \"./misc\";\nimport { getChainsFromNamespace } from \"./caip\";\n\nexport type ErrorObject = { message: string; code: number } | null;\n\n// -- types validation ----------------------------------------------------- //\n\nexport function isValidArray(arr: any, itemCondition?: (item: any) => boolean) {\n  if (Array.isArray(arr)) {\n    if (typeof itemCondition !== \"undefined\" && arr.length) {\n      return arr.every(itemCondition);\n    } else {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isValidObject(obj: any) {\n  return Object.getPrototypeOf(obj) === Object.prototype && Object.keys(obj).length;\n}\n\nexport function isUndefined(input: any): input is undefined {\n  return typeof input === \"undefined\";\n}\n\nexport function isValidString(input: any, optional: boolean): input is string {\n  if (optional && isUndefined(input)) return true;\n\n  return typeof input === \"string\" && Boolean(input.trim().length);\n}\n\nexport function isValidNumber(input: any, optional: boolean) {\n  if (optional && isUndefined(input)) return true;\n\n  return typeof input === \"number\" && !isNaN(input);\n}\n\n// -- protocol validation -------------------------------------------------- //\n\nexport function isSessionCompatible(session: SessionTypes.Struct, params: EngineTypes.FindParams) {\n  const { requiredNamespaces } = params;\n  const sessionKeys = Object.keys(session.namespaces);\n  const paramsKeys = Object.keys(requiredNamespaces);\n  let compatible = true;\n\n  if (!hasOverlap(paramsKeys, sessionKeys)) return false;\n\n  sessionKeys.forEach((key) => {\n    const { accounts, methods, events } = session.namespaces[key];\n    const chains = getAccountsChains(accounts);\n    const requiredNamespace = requiredNamespaces[key];\n    if (\n      !hasOverlap(getChainsFromNamespace(key, requiredNamespace), chains) ||\n      !hasOverlap(requiredNamespace.methods, methods) ||\n      !hasOverlap(requiredNamespace.events, events)\n    ) {\n      compatible = false;\n    }\n  });\n\n  return compatible;\n}\n\nexport function isValidChainId(value: any) {\n  if (isValidString(value, false) && value.includes(\":\")) {\n    const split = value.split(\":\");\n    return split.length === 2;\n  }\n  return false;\n}\n\nexport function isValidAccountId(value: any) {\n  if (isValidString(value, false) && value.includes(\":\")) {\n    const split = value.split(\":\");\n    if (split.length === 3) {\n      const chainId = split[0] + \":\" + split[1];\n      return !!split[2] && isValidChainId(chainId);\n    }\n  }\n  return false;\n}\n\nexport function isValidUrl(value: any) {\n  function validateUrl(blob: string) {\n    try {\n      const url = new URL(blob);\n      return typeof url !== \"undefined\";\n    } catch (e) {\n      return false;\n    }\n  }\n  try {\n    if (isValidString(value, false)) {\n      const isValid = validateUrl(value);\n      if (isValid) return true;\n\n      const decoded = fromBase64(value);\n      return validateUrl(decoded);\n    }\n  } catch (e) {}\n  return false;\n}\n\nexport function isProposalStruct(input: any): input is ProposalTypes.Struct {\n  return input?.proposer?.publicKey;\n}\n\nexport function isSessionStruct(input: any): input is SessionTypes.Struct {\n  return input?.topic;\n}\n\nexport function isValidController(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (!isValidString(input?.publicKey, false)) {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method} controller public key should be a string`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceMethodsOrEvents(input: any): input is string {\n  let valid = true;\n  if (isValidArray(input)) {\n    if (input.length) {\n      valid = input.every((item: any) => isValidString(item, false));\n    }\n  } else {\n    valid = false;\n  }\n\n  return valid;\n}\n\nexport function isValidChains(key: string, chains: any, context: string) {\n  let error: ErrorObject = null;\n\n  if (isValidArray(chains) && chains.length) {\n    chains.forEach((chain: any) => {\n      if (error) return;\n      if (!isValidChainId(chain)) {\n        error = getSdkError(\n          \"UNSUPPORTED_CHAINS\",\n          `${context}, chain ${chain} should be a string and conform to \"namespace:chainId\" format`,\n        );\n      }\n    });\n  } else if (!isValidChainId(key)) {\n    error = getSdkError(\n      \"UNSUPPORTED_CHAINS\",\n      `${context}, chains must be defined as \"namespace:chainId\" e.g. \"eip155:1\": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: [\"eip155:1\", \"eip155:5\"] }`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceChains(namespaces: any, method: string, type: string) {\n  let error: ErrorObject = null;\n  Object.entries(namespaces).forEach(([key, namespace]: [string, any]) => {\n    if (error) return;\n    const validChainsError = isValidChains(\n      key,\n      getChainsFromNamespace(key, namespace),\n      `${method} ${type}`,\n    );\n    if (validChainsError) {\n      error = validChainsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidAccounts(accounts: any, context: string) {\n  let error: ErrorObject = null;\n  if (isValidArray(accounts)) {\n    accounts.forEach((account: any) => {\n      if (error) return;\n      if (!isValidAccountId(account)) {\n        error = getSdkError(\n          \"UNSUPPORTED_ACCOUNTS\",\n          `${context}, account ${account} should be a string and conform to \"namespace:chainId:address\" format`,\n        );\n      }\n    });\n  } else {\n    error = getSdkError(\n      \"UNSUPPORTED_ACCOUNTS\",\n      `${context}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceAccounts(input: any, method: string) {\n  let error: ErrorObject = null;\n  Object.values(input).forEach((namespace: any) => {\n    if (error) return;\n    const validAccountsError = isValidAccounts(namespace?.accounts, `${method} namespace`);\n    if (validAccountsError) {\n      error = validAccountsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidActions(namespace: any, context: string) {\n  let error: ErrorObject = null;\n  if (!isValidNamespaceMethodsOrEvents(namespace?.methods)) {\n    error = getSdkError(\n      \"UNSUPPORTED_METHODS\",\n      `${context}, methods should be an array of strings or empty array for no methods`,\n    );\n  } else if (!isValidNamespaceMethodsOrEvents(namespace?.events)) {\n    error = getSdkError(\n      \"UNSUPPORTED_EVENTS\",\n      `${context}, events should be an array of strings or empty array for no events`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceActions(input: any, method: string) {\n  let error: ErrorObject = null;\n  Object.values(input).forEach((namespace: any) => {\n    if (error) return;\n    const validActionsError = isValidActions(namespace, `${method}, namespace`);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidRequiredNamespaces(input: any, method: string, type: string) {\n  let error: ErrorObject = null;\n  if (input && isValidObject(input)) {\n    const validActionsError = isValidNamespaceActions(input, method);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n    const validChainsError = isValidNamespaceChains(input, method, type);\n    if (validChainsError) {\n      error = validChainsError;\n    }\n  } else {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method}, ${type} should be an object with data`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaces(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (input && isValidObject(input)) {\n    const validActionsError = isValidNamespaceActions(input, method);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n    const validAccountsError = isValidNamespaceAccounts(input, method);\n    if (validAccountsError) {\n      error = validAccountsError;\n    }\n  } else {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method}, namespaces should be an object with data`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidRelay(input: any): input is RelayerTypes.ProtocolOptions {\n  return isValidString(input.protocol, true);\n}\n\nexport function isValidRelays(\n  input: any,\n  optional: boolean,\n): input is RelayerTypes.ProtocolOptions[] {\n  let valid = false;\n\n  if (optional && !input) valid = true;\n  else if (input && isValidArray(input) && input.length) {\n    input.forEach((relay: RelayerTypes.ProtocolOptions) => {\n      valid = isValidRelay(relay);\n    });\n  }\n\n  return valid;\n}\n\nexport function isValidId(input: any) {\n  return typeof input === \"number\";\n}\n\nexport function isValidParams(input: any) {\n  // eslint-disable-next-line valid-typeof\n  return typeof input !== \"undefined\" && typeof input !== null;\n}\n\nexport function isValidErrorReason(input: any): input is ErrorResponse {\n  if (!input) return false;\n  if (typeof input !== \"object\") return false;\n  if (!input.code || !isValidNumber(input.code, false)) return false;\n  if (!input.message || !isValidString(input.message, false)) return false;\n\n  return true;\n}\n\nexport function isValidRequest(request: any) {\n  if (isUndefined(request)) return false;\n  if (!isValidString(request.method, false)) return false;\n  return true;\n}\n\nexport function isValidResponse(response: any) {\n  if (isUndefined(response)) return false;\n  if (isUndefined(response.result) && isUndefined(response.error)) return false;\n  if (!isValidNumber(response.id, false)) return false;\n  if (!isValidString(response.jsonrpc, false)) return false;\n  return true;\n}\n\nexport function isValidEvent(event: any) {\n  if (isUndefined(event)) return false;\n  if (!isValidString(event.name, false)) return false;\n  return true;\n}\n\nexport function isValidNamespacesChainId(namespaces: SessionTypes.Namespaces, chainId: string) {\n  if (!isValidChainId(chainId)) return false;\n  const chains = getNamespacesChains(namespaces);\n  if (!chains.includes(chainId)) return false;\n\n  return true;\n}\n\nexport function isValidNamespacesRequest(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n  method: string,\n) {\n  if (!isValidString(method, false)) return false;\n  const methods = getNamespacesMethodsForChainId(namespaces, chainId);\n  return methods.includes(method);\n}\n\nexport function isValidNamespacesEvent(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n  eventName: string,\n) {\n  if (!isValidString(eventName, false)) return false;\n  const events = getNamespacesEventsForChainId(namespaces, chainId);\n  return events.includes(eventName);\n}\n\nexport function isConformingNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  namespaces: SessionTypes.Namespaces,\n  context: string,\n) {\n  let error: ErrorObject = null;\n\n  const parsedRequired = parseNamespaces(requiredNamespaces);\n  const parsedApproved = parseApprovedNamespaces(namespaces);\n  const requiredChains = Object.keys(parsedRequired);\n  const approvedChains = Object.keys(parsedApproved);\n\n  const uniqueRequired = filterDuplicateNamespaces(Object.keys(requiredNamespaces));\n  const uniqueApproved = filterDuplicateNamespaces(Object.keys(namespaces));\n  const missingRequiredNamespaces = uniqueRequired.filter(\n    (namespace) => !uniqueApproved.includes(namespace),\n  );\n\n  if (missingRequiredNamespaces.length) {\n    error = getInternalError(\n      \"NON_CONFORMING_NAMESPACES\",\n      `${context} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${missingRequiredNamespaces.toString()}\n      Received: ${Object.keys(namespaces).toString()}`,\n    );\n  }\n\n  if (!hasOverlap(requiredChains, approvedChains)) {\n    error = getInternalError(\n      \"NON_CONFORMING_NAMESPACES\",\n      `${context} namespaces chains don't satisfy required namespaces.\n      Required: ${requiredChains.toString()}\n      Approved: ${approvedChains.toString()}`,\n    );\n  }\n\n  // validate inline defined chains with approved accounts\n  Object.keys(namespaces).forEach((chain) => {\n    if (!chain.includes(\":\")) return;\n    if (error) return;\n    const chains = getAccountsChains(namespaces[chain].accounts);\n    if (!chains.includes(chain)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces accounts don't satisfy namespace accounts for ${chain}\n        Required: ${chain}\n        Approved: ${chains.toString()}`,\n      );\n    }\n  });\n\n  requiredChains.forEach((chain) => {\n    if (error) return;\n\n    if (!hasOverlap(parsedRequired[chain].methods, parsedApproved[chain].methods)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces methods don't satisfy namespace methods for ${chain}`,\n      );\n    } else if (!hasOverlap(parsedRequired[chain].events, parsedApproved[chain].events)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces events don't satisfy namespace events for ${chain}`,\n      );\n    }\n  });\n\n  return error;\n}\n\nfunction parseNamespaces(namespaces: ProposalTypes.RequiredNamespaces) {\n  const parsed: ProposalTypes.RequiredNamespaces = {};\n  Object.keys(namespaces).forEach((key) => {\n    // e.g. `eip155:1`\n    const isInlineChainDefinition = key.includes(\":\");\n\n    if (isInlineChainDefinition) {\n      parsed[key] = namespaces[key];\n    } else {\n      namespaces[key].chains?.forEach((chain) => {\n        parsed[chain] = {\n          methods: namespaces[key].methods,\n          events: namespaces[key].events,\n        };\n      });\n    }\n  });\n  return parsed;\n}\n\nfunction filterDuplicateNamespaces(namespaces: string[]) {\n  return [\n    ...new Set(\n      namespaces.map((namespace) =>\n        namespace.includes(\":\") ? namespace.split(\":\")[0] : namespace,\n      ),\n    ),\n  ];\n}\n\nfunction parseApprovedNamespaces(namespaces: SessionTypes.Namespaces) {\n  const parsed: SessionTypes.Namespaces = {};\n  Object.keys(namespaces).forEach((key) => {\n    const isInlineChainDefinition = key.includes(\":\");\n    if (isInlineChainDefinition) {\n      parsed[key] = namespaces[key];\n    } else {\n      const chains = getAccountsChains(namespaces[key].accounts);\n      chains?.forEach((chain) => {\n        parsed[chain] = {\n          accounts: namespaces[key].accounts.filter((account: string) =>\n            account.includes(`${chain}:`),\n          ),\n          methods: namespaces[key].methods,\n          events: namespaces[key].events,\n        };\n      });\n    }\n  });\n  return parsed;\n}\n\nexport function isValidRequestExpiry(expiry: number, boundaries: { min: number; max: number }) {\n  return isValidNumber(expiry, false) && expiry <= boundaries.max && expiry >= boundaries.min;\n}\n","import { getDocument } from \"@walletconnect/window-getters\";\nimport { getEnvironment, ENV_MAP, isBrowser, isReactNative } from \"./misc\";\n\nexport function isOnline(): Promise<boolean> {\n  const env = getEnvironment();\n  return new Promise((resolve) => {\n    switch (env) {\n      case ENV_MAP.browser:\n        resolve(getBrowserOnlineStatus());\n        break;\n      case ENV_MAP.reactNative:\n        resolve(getReactNativeOnlineStatus());\n        break;\n      case ENV_MAP.node:\n        resolve(getNodeOnlineStatus());\n        break;\n      default:\n        resolve(true);\n    }\n  });\n}\n\nexport function getBrowserOnlineStatus() {\n  return isBrowser() && navigator?.onLine;\n}\n\nexport async function getReactNativeOnlineStatus(): Promise<boolean> {\n  // global.NetInfo is set in react-native-compat\n  if (isReactNative() && typeof global !== \"undefined\" && (global as any)?.NetInfo) {\n    const state = await (global as any)?.NetInfo.fetch();\n    return state?.isConnected;\n  }\n  // fallback to true if global.NetInfo is undefined, meaning an older version of react-native-compat is used\n  return true;\n}\n\nexport function getNodeOnlineStatus() {\n  /**\n   * TODO: need to implement\n   */\n  return true;\n}\n\nexport function subscribeToNetworkChange(callbackHandler: (connected: boolean) => void) {\n  const env = getEnvironment();\n  switch (env) {\n    case ENV_MAP.browser:\n      subscribeToBrowserNetworkChange(callbackHandler);\n      break;\n    case ENV_MAP.reactNative:\n      subscribeToReactNativeNetworkChange(callbackHandler);\n      break;\n    case ENV_MAP.node:\n      // wip: need to implement\n      break;\n    default:\n      break;\n  }\n}\n\nexport function subscribeToBrowserNetworkChange(callbackHandler: (connected: boolean) => void) {\n  if (!isReactNative() && isBrowser()) {\n    window.addEventListener(\"online\", () => callbackHandler(true));\n    window.addEventListener(\"offline\", () => callbackHandler(false));\n  }\n}\n\n// global.NetInfo is set in react-native-compat\nexport function subscribeToReactNativeNetworkChange(callbackHandler: (connected: boolean) => void) {\n  if (isReactNative() && typeof global !== \"undefined\" && (global as any)?.NetInfo) {\n    (global as any)?.NetInfo.addEventListener((state: any) => callbackHandler(state?.isConnected));\n  }\n}\n\nexport function isAppVisible(): boolean {\n  if (isBrowser() && getDocument()) {\n    return getDocument()?.visibilityState === \"visible\";\n  }\n  // TODO: implement reliable visibility check for react-native\n  // node.js does not have a visibilityState\n  return true;\n}\n","const memoryStore: Record<string, any> = {};\n\nexport abstract class MemoryStore {\n  static get<T = unknown>(key: string) {\n    return memoryStore[key] as T | undefined;\n  }\n\n  static set(key: string, value: unknown) {\n    memoryStore[key] = value;\n  }\n\n  static delete(key: string) {\n    delete memoryStore[key];\n  }\n}\n"],"names":["CAIP_DELIMITER","chain","namespace","reference","params","account","address","array","parser","unique","str","value","accounts","namespaces","keys","key","ns","chains","requiredNamespaces","namespaceProps","getDocument","getNavigator","_a","e","queryString","newQueryParams","urlSearchParams","metadata","_b","appMetadata","icon","__spreadProps","__spreadValues","error","getWindowMetadata","protocol","version","env","getLocation","OS","Version","info","detect","os","sdkVersion","id","relayUrl","auth","projectId","useOnCloseEvent","bundleId","packageName","splitUrl","ua","url","domain","obj","type","context","depth","a","b","x","arr","map","cb","res","word","c","w","expiry","FIVE_MINUTES","expireErrorMessage","timeout","toMiliseconds","cacheResolve","cacheReject","cacheTimeout","result","promiseResolve","promiseReject","err","promise","resolve","reject","topic","target","parsed","ttl","now","fromMiliseconds","event","wcDeepLink","json","deeplink","link","requestId","sessionTopic","payload","startApp","storage","arr1","arr2","param","index","r","input","removePadding","encoded","encodedString","ms","anumber","isBytes","abytes","aexists","aoutput","crypto","u32","createView","isLE","utf8ToBytes","toBytes","concatBytes","_0n","_1n","_2n","DEFAULT_RPC_URL","message","prefix","prefixedMessage","keccak_256","reconstructedMessage","cacaoSignature","chainId","baseRpcUrl","signature","recoverAddress","parsedChain","parseChainId","eip1271MagicValue","dynamicTypeOffset","dynamicTypeLength","nonPrefixedSignature","nonPrefixedHashedMessage","data","response","generateJsonRpcId","solanaTransaction","binary","bytes","i","signatureCount","signatureEndPos","signatureBuffer","bs58","didPrefix","iss","segments","cacao","reconstructed","walletAddress","verifySignature","header","statement","uri","nonce","issuedAt","expirationTime","notBefore","resources","resource","recap","decoded","val","requestPayload","authPayload","methods","requested","supportedChains","getCommonValuesInArrays","requestedRecaps","updatedResources","actions","supportedActions","formattedActions","updatedRecap","action","abilities","ability","resourceAbilities","limits","limit","baseRecap","recap1","recap2","decoded1","decoded2","merged","mergedRecap","base","statementForRecap","currentCounter","uniqueAbilities","recapStatemet","recapStatement","abool","equalBytes","isAligned32","setBigUint64","_3n","_5n","validateOpts","ut.validateObject","ut.numberToHexUnpadded","ut.abytes","ut.concatBytes","ut.inRange","ut.isBytes","ut.bytesToHex","ut.bytesToNumberBE","ut.aInRange","ut.numberToBytesBE","ut.hexToBytes","ut.bitMask","ut.createHmacDrbg","ZERO_INDEX","TYPE_LENGTH","IV_LENGTH","KEY_LENGTH","privateKey","x25519","publicKey","toString","random","randomBytes","privateKeyA","publicKeyB","sharedKey","fromString","symKey","hkdf","sha256","byte","toBase64URL","base64","fromBase64URL","base64url","padding","senderPublicKey","iv","sealed","chacha20poly1305","encoding","concat","normalizedEncoded","slice1","slice2","slice3","opts","deserialized","keyData","xBuffer","yBuffer","token","headerBase64Url","payloadBase64Url","signatureBase64Url","s","signingInput","messageHash","p256","decodeJWT","jsonrpc","RELAY_JSONRPC","delimiter","relay","name","fromBase64","pathStart","pathEnd","requiredValues","queryParams","typedKey","k","relayParams","universalLink","encodedEnvelope","events","caller","validNamespacesError","isValidNamespaces","required","values","optionalNamespaces","supportedNamespaces","normalizedRequired","normalizedOptional","supportedMethods","supportedEvents","supportedAccounts","isConformingNamespaces","approvedNamespaces","requiredNamespace","method","optionalNamespace","_c","_d","_e","_f","chainsToAdd","methodsToAdd","eventsToAdd","accountsToAdd","mergeArrays","normalizedNamespaces","isValidObject","normalizedKey","_","mergedNamespaces","combinedNamespaces","code","itemCondition","optional","session","sessionKeys","paramsKeys","compatible","hasOverlap","getAccountsChains","getChainsFromNamespace","split","validateUrl","blob","getInternalError","valid","item","getSdkError","validChainsError","validAccountsError","validActionsError","request","getNamespacesChains","getNamespacesMethodsForChainId","eventName","getNamespacesEventsForChainId","parsedRequired","parseNamespaces","parsedApproved","parseApprovedNamespaces","requiredChains","approvedChains","uniqueRequired","filterDuplicateNamespaces","uniqueApproved","missingRequiredNamespaces","boundaries","getEnvironment","ENV_MAP","isBrowser","isReactNative","state","callbackHandler","memoryStore"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAWA,MAAMA,EAAiB,GAEhB,CAAA,SAAS,aAAaC,CAA8B,CAAA,CACzD,KAAM,CAACC,CAAAA,CAAWC,CAAS,CAAA,CAAIF,EAAM,KAAMD,CAAAA,CAAc,EACzD,OAAO,CAAE,UAAAE,CAAW,CAAA,SAAA,CAAAC,CAAU,CAChC,CAEgB,SAAA,aAAA,CAAcC,EAA+B,CAC3D,KAAM,CAAE,SAAAF,CAAAA,CAAAA,CAAW,SAAAC,CAAAA,CAAU,EAAIC,CACjC,CAAA,OAAO,CAACF,CAAWC,CAAAA,CAAS,EAAE,IAAKH,CAAAA,CAAc,CACnD,UAEgB,cAAeK,CAAAA,CAAAA,CAAkC,CAC/D,KAAM,CAACH,EAAWC,CAAWG,CAAAA,CAAO,CAAID,CAAAA,CAAAA,CAAQ,MAAML,CAAc,CAAA,CACpE,OAAO,CAAE,SAAA,CAAAE,EAAW,SAAAC,CAAAA,CAAAA,CAAW,OAAAG,CAAAA,CAAQ,CACzC,CAEO,SAAS,gBAAgBF,CAAiC,CAAA,CAC/D,KAAM,CAAE,SAAA,CAAAF,EAAW,SAAAC,CAAAA,CAAAA,CAAW,QAAAG,CAAQ,CAAA,CAAIF,EAC1C,OAAO,CAACF,EAAWC,CAAWG,CAAAA,CAAO,CAAE,CAAA,IAAA,CAAKN,CAAc,CAC5D,UAEgB,eAAgBO,CAAAA,CAAAA,CAAiBC,EAA2C,CAC1F,MAAMC,CAAmB,CAAA,GACzB,OAAAF,CAAAA,CAAM,QAASG,CAAQ,EAAA,CACrB,MAAMC,CAAQH,CAAAA,CAAAA,CAAOE,CAAG,CAAA,CACnBD,EAAO,QAASE,CAAAA,CAAK,GAAGF,CAAO,CAAA,IAAA,CAAKE,CAAK,EAChD,CAAC,EACMF,CACT,UAEgB,qBAAsBJ,CAAAA,CAAAA,CAAiB,CACrD,KAAM,CAAE,QAAAC,CAAQ,CAAA,CAAI,cAAeD,CAAAA,CAAO,EAC1C,OAAOC,CACT,CAEgB,SAAA,mBAAA,CAAoBD,EAAiB,CACnD,KAAM,CAAE,SAAA,CAAAH,EAAW,SAAAC,CAAAA,CAAU,EAAI,cAAeE,CAAAA,CAAO,EAEvD,OADc,aAAA,CAAc,CAAE,SAAA,CAAAH,EAAW,SAAAC,CAAAA,CAAU,CAAC,CAEtD,UAEgB,sBAAuBG,CAAAA,CAAAA,CAAiBL,EAAe,CACrE,KAAM,CAAE,SAAAC,CAAAA,CAAAA,CAAW,UAAAC,CAAU,CAAA,CAAI,aAAaF,CAAK,CAAA,CAEnD,OADgB,eAAA,CAAgB,CAAE,SAAAC,CAAAA,CAAAA,CAAW,UAAAC,CAAW,CAAA,OAAA,CAAAG,CAAQ,CAAC,CAEnE,CAEO,SAAS,yBAAyBM,CAAoB,CAAA,CAC3D,OAAO,eAAgBA,CAAAA,CAAAA,CAAU,qBAAqB,CACxD,CAEgB,SAAA,qBAAA,CAAsBA,EAAoB,CACxD,OAAO,gBAAgBA,CAAU,CAAA,mBAAmB,CACtD,CAEO,SAAS,0BACdC,CACAC,CAAAA,CAAAA,CAAiB,EACP,CAAA,CACV,MAAMF,CAAqB,CAAA,GAC3B,OAAO,MAAA,CAAA,IAAA,CAAKC,CAAU,CAAA,CAAE,QAASE,CAAQ,EAAA,CACvC,GAAID,CAAK,CAAA,MAAA,EAAU,CAACA,CAAK,CAAA,QAAA,CAASC,CAAG,CAAA,CAAG,OACxC,MAAMC,CAAAA,CAAKH,EAAWE,CAAG,CAAA,CACzBH,EAAS,IAAK,CAAA,GAAGI,CAAG,CAAA,QAAQ,EAC9B,CAAC,CAAA,CACMJ,CACT,CAEO,SAAS,wBACdC,CACAC,CAAAA,CAAAA,CAAiB,EACP,CAAA,CACV,MAAMG,CAAmB,CAAA,GACzB,OAAO,MAAA,CAAA,IAAA,CAAKJ,CAAU,CAAE,CAAA,OAAA,CAASE,CAAQ,EAAA,CACvC,GAAID,CAAK,CAAA,MAAA,EAAU,CAACA,CAAK,CAAA,QAAA,CAASC,CAAG,CAAG,CAAA,OACxC,MAAMC,CAAAA,CAAKH,EAAWE,CAAG,CAAA,CACzBE,EAAO,IAAK,CAAA,GAAG,sBAAsBD,CAAG,CAAA,QAAQ,CAAC,EACnD,CAAC,CACMC,CAAAA,CACT,CAEgB,SAAA,+BAAA,CACdC,EACAJ,CAAiB,CAAA,GACP,CACV,MAAMG,EAAmB,EAAC,CAC1B,cAAO,IAAKC,CAAAA,CAAkB,EAAE,OAASH,CAAAA,CAAAA,EAAQ,CAC/C,GAAID,EAAK,MAAU,EAAA,CAACA,EAAK,QAASC,CAAAA,CAAG,EAAG,OACxC,MAAMC,CAAKE,CAAAA,CAAAA,CAAmBH,CAAG,CACjCE,CAAAA,CAAAA,CAAO,KAAK,GAAG,sBAAA,CAAuBF,EAAKC,CAAE,CAAC,EAChD,CAAC,EACMC,CACT,UAEgB,sBACdf,CAAAA,CAAAA,CACAiB,EACA,CAEA,OAAOjB,EAAU,QAAS,CAAA,GAAG,EAAI,CAACA,CAAS,EAAIiB,CAAe,CAAA,MAAA,EAAU,EAC1E","debugId":null}},
    {"offset": {"line": 7155, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/types/dist/index.es.js","sources":["file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/types/src/core/core.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/types/src/core/crypto.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/types/src/core/history.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/types/src/core/messages.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/types/src/core/publisher.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/types/src/core/relayer.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/types/src/core/store.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/types/src/core/subscriber.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/types/src/core/keychain.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/types/src/core/expirer.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/types/src/core/pairing.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/types/src/core/verify.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/types/src/core/echo.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/types/src/core/events.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/types/src/sign-client/client.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/types/src/sign-client/engine.ts"],"sourcesContent":["import { IEvents } from \"@walletconnect/events\";\nimport { IHeartBeat } from \"@walletconnect/heartbeat\";\nimport { IKeyValueStorage, KeyValueStorageOptions } from \"@walletconnect/keyvaluestorage\";\n\nimport { ICrypto } from \"./crypto\";\nimport { IRelayer } from \"./relayer\";\nimport { IKeyChain } from \"./keychain\";\nimport { IJsonRpcHistory } from \"./history\";\nimport { IExpirer } from \"./expirer\";\nimport { IPairing } from \"./pairing\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { IVerify } from \"./verify\";\nimport { IEchoClient } from \"./echo\";\nimport { IEventClient } from \"./events\";\nexport declare namespace CoreTypes {\n  interface Options {\n    projectId?: string;\n    name?: string;\n    relayUrl?: string;\n    logger?: string | Logger;\n    keychain?: IKeyChain;\n    storage?: IKeyValueStorage;\n    storageOptions?: KeyValueStorageOptions;\n    maxLogBlobSizeInBytes?: number;\n    customStoragePrefix?: string;\n    telemetryEnabled?: boolean;\n  }\n\n  interface Metadata {\n    name: string;\n    description: string;\n    url: string;\n    icons: string[];\n    verifyUrl?: string;\n    redirect?: {\n      native?: string;\n      universal?: string;\n      linkMode?: boolean;\n    };\n  }\n}\n\nexport abstract class ICore extends IEvents {\n  public readonly protocol = \"wc\";\n  public readonly version = 2;\n\n  public abstract readonly name: string;\n  public abstract readonly context: string;\n  public abstract readonly relayUrl?: string;\n  public abstract readonly projectId?: string;\n  public abstract readonly customStoragePrefix: string;\n\n  public abstract logger: Logger;\n  public abstract heartbeat: IHeartBeat;\n  public abstract crypto: ICrypto;\n  public abstract relayer: IRelayer;\n  public abstract storage: IKeyValueStorage;\n  public abstract history: IJsonRpcHistory;\n  public abstract expirer: IExpirer;\n  public abstract pairing: IPairing;\n  public abstract verify: IVerify;\n  public abstract echoClient: IEchoClient;\n  public abstract linkModeSupportedApps: string[];\n  public abstract eventClient: IEventClient;\n\n  constructor(public opts?: CoreTypes.Options) {\n    super();\n  }\n\n  public abstract start(): Promise<void>;\n  public abstract dispatchEnvelope(params: {\n    topic: string;\n    message: string;\n    sessionExists: boolean;\n  }): void;\n\n  public abstract addLinkModeSupportedApp(universalLink: string): void;\n}\n","import { JsonRpcPayload } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\nimport { IKeyChain } from \"./keychain\";\n\nexport declare namespace CryptoTypes {\n  export type EncodingType = \"base64pad\" | \"base64url\";\n\n  export interface Participant {\n    publicKey: string;\n  }\n\n  export interface KeyPair {\n    privateKey: string;\n    publicKey: string;\n  }\n\n  export interface EncryptParams {\n    message: string;\n    symKey: string;\n    type?: number;\n    iv?: string;\n    senderPublicKey?: string;\n    encoding?: EncodingType;\n  }\n\n  export interface DecryptParams {\n    symKey: string;\n    encoded: string;\n    encoding?: EncodingType;\n  }\n\n  export interface EncodingParams {\n    type: Uint8Array;\n    sealed: Uint8Array;\n    iv: Uint8Array;\n    senderPublicKey?: Uint8Array;\n    encoding?: EncodingType;\n  }\n\n  export interface DecodingParams {\n    encoded: string;\n    encoding?: EncodingType;\n  }\n\n  export interface EncodeOptions {\n    type?: number;\n    senderPublicKey?: string;\n    receiverPublicKey?: string;\n    encoding?: EncodingType;\n  }\n\n  export interface DecodeOptions {\n    receiverPublicKey?: string;\n    encoding?: EncodingType;\n  }\n\n  export interface EncodingValidation {\n    type: number;\n    senderPublicKey?: string;\n    receiverPublicKey?: string;\n  }\n\n  export interface TypeOneParams {\n    type: 1;\n    senderPublicKey: string;\n    receiverPublicKey: string;\n  }\n}\n\nexport abstract class ICrypto {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  public abstract keychain: IKeyChain;\n\n  public abstract readonly randomSessionIdentifier: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    // @ts-ignore\n    keychain?: IKeyChain,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract hasKeys(tag: string): boolean;\n\n  public abstract getClientId(): Promise<string>;\n\n  public abstract generateKeyPair(): Promise<string>;\n\n  public abstract generateSharedKey(\n    selfPublicKey: string,\n    peerPublicKey: string,\n    overrideTopic?: string,\n  ): Promise<string>;\n\n  public abstract setSymKey(symKey: string, overrideTopic?: string): Promise<string>;\n\n  public abstract deleteKeyPair(publicKey: string): Promise<void>;\n\n  public abstract deleteSymKey(topic: string): Promise<void>;\n\n  public abstract encode(\n    topic: string,\n    payload: JsonRpcPayload,\n    opts?: CryptoTypes.EncodeOptions,\n  ): Promise<string>;\n\n  public abstract decode(\n    topic: string,\n    encoded: string,\n    opts?: CryptoTypes.DecodeOptions,\n  ): Promise<JsonRpcPayload>;\n\n  public abstract signJWT(aud: string): Promise<string>;\n  public abstract getPayloadType(encoded: string, encoding?: CryptoTypes.EncodingType): number;\n  public abstract getPayloadSenderPublicKey(\n    encoded: string,\n    encoding?: CryptoTypes.EncodingType,\n  ): string | undefined;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport {\n  ErrorResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  RequestArguments,\n} from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\n\nexport interface JsonRpcRecord {\n  id: number;\n  topic: string;\n  request: RequestArguments;\n  chainId?: string;\n  response?: { result: any } | { error: ErrorResponse };\n  expiry?: number;\n}\n\nexport interface RequestEvent {\n  topic: string;\n  request: JsonRpcRequest;\n  chainId?: string;\n}\n\nexport abstract class IJsonRpcHistory extends IEvents {\n  public records = new Map<number, JsonRpcRecord>();\n\n  public abstract readonly context: string;\n\n  public abstract readonly size: number;\n\n  public abstract readonly keys: number[];\n\n  public abstract readonly values: JsonRpcRecord[];\n\n  public abstract readonly pending: RequestEvent[];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(topic: string, request: JsonRpcRequest, chainId?: string): void;\n\n  public abstract get(topic: string, id: number): Promise<JsonRpcRecord>;\n\n  public abstract resolve(response: JsonRpcResponse): Promise<void>;\n\n  public abstract delete(topic: string, id?: number): void;\n\n  public abstract exists(topic: string, id: number): Promise<boolean>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport type MessageRecord = Record<string, string>;\n\nexport abstract class IMessageTracker {\n  public abstract messages: Map<string, MessageRecord>;\n  public abstract messagesWithoutClientAck: Map<string, MessageRecord>;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(\n    public logger: Logger,\n    public core: ICore,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(\n    topic: string,\n    message: string,\n    direction?: \"inbound\" | \"outbound\",\n  ): Promise<string>;\n\n  public abstract get(topic: string): MessageRecord;\n\n  public abstract getWithoutAck(topics: string[]): Record<string, string[]>;\n\n  public abstract has(topic: string, message: string): boolean;\n\n  public abstract del(topic: string): Promise<void>;\n\n  public abstract ack(topic: string, message: string): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { IRelayer, RelayerTypes } from \"./relayer\";\n\nexport declare namespace PublisherTypes {\n  export interface Params {\n    topic: string;\n    message: string;\n    opts: Omit<RelayerTypes.PublishOptions, \"internal\">;\n  }\n}\n\nexport abstract class IPublisher extends IEvents {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(\n    public relayer: IRelayer,\n    public logger: Logger,\n  ) {\n    super();\n  }\n\n  public abstract publish(\n    topic: string,\n    message: string,\n    opts?: RelayerTypes.PublishOptions,\n  ): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { IJsonRpcProvider, JsonRpcPayload, RequestArguments } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\nimport { IMessageTracker } from \"./messages\";\nimport { IPublisher } from \"./publisher\";\nimport { ISubscriber } from \"./subscriber\";\n\nexport declare namespace RelayerTypes {\n  export interface ProtocolOptions {\n    protocol: string;\n    data?: string;\n  }\n  export interface PublishOptions {\n    relay?: ProtocolOptions;\n    ttl?: number;\n    prompt?: boolean;\n    tag?: number;\n    id?: number;\n    internal?: {\n      throwOnFailedPublish?: boolean;\n    };\n    tvf?: ITVF;\n    attestation?: string;\n  }\n\n  export type TransportType = \"relay\" | \"link_mode\";\n\n  export interface SubscribeOptions {\n    relay?: ProtocolOptions;\n    transportType?: TransportType;\n    internal?: {\n      throwOnFailedPublish?: boolean;\n    };\n  }\n\n  export interface UnsubscribeOptions {\n    id?: string;\n    relay: ProtocolOptions;\n  }\n\n  export type RequestOptions = PublishOptions | SubscribeOptions | UnsubscribeOptions;\n\n  export interface PublishPayload {\n    topic: string;\n    message: string;\n    opts?: RelayerTypes.PublishOptions;\n  }\n  export interface MessageEvent {\n    topic: string;\n    message: string;\n    publishedAt: number;\n    transportType?: TransportType;\n    attestation?: string;\n  }\n\n  export interface RpcUrlParams {\n    protocol: string;\n    version: number;\n    auth: string;\n    relayUrl: string;\n    sdkVersion: string;\n    projectId?: string;\n    useOnCloseEvent?: boolean;\n    bundleId?: string;\n    packageName?: string;\n  }\n\n  export interface ITVF {\n    correlationId?: number;\n    rpcMethods?: string[];\n    chainId?: string;\n    txHashes?: string[];\n    contractAddresses?: string[];\n  }\n\n  export type MessageDirection = \"inbound\" | \"outbound\";\n}\n\nexport interface RelayerOptions {\n  core: ICore;\n  logger?: string | Logger;\n  relayUrl?: string;\n  projectId?: string;\n}\n\nexport interface RelayerClientMetadata {\n  protocol: string;\n  version: number;\n  env: string;\n  host?: string;\n}\n\nexport abstract class IRelayer extends IEvents {\n  public abstract protocol: string;\n\n  public abstract version: number;\n\n  public abstract core: ICore;\n\n  public abstract logger: Logger;\n\n  public abstract subscriber: ISubscriber;\n\n  public abstract publisher: IPublisher;\n\n  public abstract messages: IMessageTracker;\n\n  public abstract provider: IJsonRpcProvider;\n\n  public abstract name: string;\n\n  public abstract transportExplicitlyClosed: boolean;\n\n  public abstract readonly context: string;\n\n  public abstract readonly connected: boolean;\n\n  public abstract readonly connecting: boolean;\n\n  constructor(\n    // @ts-ignore\n    opts: RelayerOptions,\n  ) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract publish(\n    topic: string,\n    message: string,\n    opts?: RelayerTypes.PublishOptions,\n  ): Promise<void>;\n\n  public abstract request(request: RequestArguments): Promise<JsonRpcPayload>;\n\n  public abstract subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions): Promise<string>;\n\n  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;\n  public abstract transportClose(): Promise<void>;\n  public abstract transportOpen(relayUrl?: string): Promise<void>;\n  public abstract restartTransport(relayUrl?: string): Promise<void>;\n  public abstract confirmOnlineStateOrThrow(): Promise<void>;\n  public abstract handleBatchMessageEvents(messages: RelayerTypes.MessageEvent[]): Promise<void>;\n  public abstract onLinkMessageEvent(\n    messageEvent: RelayerTypes.MessageEvent,\n    opts?: { sessionExists?: boolean },\n  ): Promise<void>;\n}\n","import { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport abstract class IStore<Key, Value> {\n  public abstract map: Map<Key, Value>;\n\n  public abstract readonly context: string;\n\n  public abstract readonly length: number;\n\n  public abstract readonly keys: Key[];\n\n  public abstract readonly values: Value[];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public name: string,\n    // @ts-ignore\n    storagePrefix?: string,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(key: Key, value: Value): Promise<void>;\n\n  public abstract get(key: Key): Value;\n\n  public abstract getAll(filter?: Partial<Value>): Value[];\n\n  public abstract update(key: Key, update: Partial<Value>): Promise<void>;\n\n  public abstract delete(key: Key, reason: ErrorResponse): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { IRelayer, RelayerTypes } from \"./relayer\";\n\nexport declare namespace SubscriberTypes {\n  export interface Params extends RelayerTypes.SubscribeOptions {\n    topic: string;\n  }\n\n  export interface Active extends Params {\n    id: string;\n  }\n}\n\nexport declare namespace SubscriberEvents {\n  export type Created = SubscriberTypes.Active;\n\n  export interface Deleted extends SubscriberTypes.Active {\n    reason: ErrorResponse;\n  }\n\n  export type Expired = Deleted;\n}\n\nexport abstract class ISubscriberTopicMap {\n  public map = new Map<string, string[]>();\n\n  public abstract readonly topics: string[];\n\n  public abstract set(topic: string, id: string): void;\n\n  public abstract get(topic: string): string[];\n\n  public abstract exists(topic: string, id: string): boolean;\n\n  public abstract delete(topic: string, id?: string): void;\n\n  public abstract clear(): void;\n}\n\nexport abstract class ISubscriber extends IEvents {\n  public abstract subscriptions: Map<string, SubscriberTypes.Active>;\n\n  public abstract topicMap: ISubscriberTopicMap;\n\n  public abstract pending: Map<string, SubscriberTypes.Params>;\n\n  public abstract readonly length: number;\n\n  public abstract readonly ids: string[];\n\n  public abstract readonly values: SubscriberTypes.Active[];\n\n  public abstract readonly topics: string[];\n\n  public abstract readonly hasAnyTopics: boolean;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(\n    public relayer: IRelayer,\n    public logger: Logger,\n  ) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract subscribe(\n    topic: string,\n    opts?: RelayerTypes.SubscribeOptions,\n  ): Promise<string | null>;\n\n  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;\n\n  public abstract isSubscribed(topic: string): Promise<boolean>;\n\n  public abstract isKnownTopic(topic: string): Promise<boolean>;\n\n  public abstract start(): Promise<void>;\n\n  public abstract stop(): Promise<void>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport abstract class IKeyChain {\n  public abstract keychain: Map<string, string>;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract has(tag: string, opts?: any): boolean;\n\n  public abstract set(tag: string, key: string, opts?: any): Promise<void>;\n\n  public abstract get(tag: string, opts?: any): string;\n\n  public abstract del(tag: string, opts?: any): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\n\nexport declare namespace ExpirerTypes {\n  interface Expiration {\n    target: string;\n    expiry: number;\n  }\n\n  interface Created {\n    target: string;\n    expiration: Expiration;\n  }\n\n  interface Deleted {\n    target: string;\n    expiration: Expiration;\n  }\n\n  interface Expired {\n    target: string;\n    expiration: Expiration;\n  }\n}\n\nexport abstract class IExpirer extends IEvents {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  public abstract readonly length: number;\n\n  public abstract readonly keys: string[];\n\n  public abstract readonly values: ExpirerTypes.Expiration[];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract has(key: string | number): boolean;\n\n  public abstract set(key: string | number, expiry: number): void;\n\n  public abstract get(key: string | number): ExpirerTypes.Expiration;\n\n  public abstract del(key: string | number): void;\n}\n","import {\n  ErrorResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  JsonRpcResult,\n  JsonRpcError,\n} from \"@walletconnect/jsonrpc-types\";\nimport EventEmitter from \"events\";\n\nimport { ICore, CoreTypes } from \"./core\";\nimport { IStore } from \"./store\";\n\nimport { RelayerTypes } from \"../core/relayer\";\nimport { Logger } from \"@walletconnect/logger\";\n\nexport declare namespace PairingTypes {\n  interface Struct {\n    topic: string;\n    expiry: number;\n    relay: RelayerTypes.ProtocolOptions;\n    active: boolean;\n    peerMetadata?: CoreTypes.Metadata;\n    methods?: string[];\n  }\n}\n\nexport declare namespace PairingJsonRpcTypes {\n  // -- core ------------------------------------------------------- //\n  type DefaultResponse = true | ErrorResponse;\n\n  type WcMethod = \"wc_pairingDelete\" | \"wc_pairingPing\";\n\n  type Error = ErrorResponse;\n\n  // -- requests --------------------------------------------------- //\n\n  interface RequestParams {\n    wc_pairingDelete: {\n      code: number;\n      message: string;\n    };\n    wc_pairingPing: Record<string, unknown>;\n  }\n\n  // -- responses -------------------------------------------------- //\n  interface Results {\n    wc_pairingDelete: true;\n    wc_pairingPing: true;\n  }\n\n  // -- events ----------------------------------------------------- //\n  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {\n    topic: string;\n    payload: T;\n  }\n}\n\nexport type IPairingStore = IStore<string, PairingTypes.Struct>;\n\nexport abstract class IPairing {\n  public abstract name: string;\n  public abstract readonly context: string;\n  public abstract events: EventEmitter;\n  public abstract pairings: IPairingStore;\n\n  constructor(\n    public logger: Logger,\n    public core: ICore,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract pair(params: {\n    uri: string;\n    activatePairing?: boolean;\n  }): Promise<PairingTypes.Struct>;\n\n  // for proposer to create inactive pairing\n  public abstract create(params?: {\n    methods?: string[];\n    transportType?: RelayerTypes.SubscribeOptions[\"transportType\"];\n  }): Promise<{ topic: string; uri: string }>;\n\n  // for either to activate a previously created pairing\n  public abstract activate(params: { topic: string }): Promise<void>;\n\n  // for both to subscribe on methods requests\n  public abstract register(params: { methods: string[] }): void;\n\n  // for either to update the expiry of an existing pairing.\n  public abstract updateExpiry(params: { topic: string; expiry: number }): Promise<void>;\n\n  // for either to update the metadata of an existing pairing.\n  public abstract updateMetadata(params: {\n    topic: string;\n    metadata: CoreTypes.Metadata;\n  }): Promise<void>;\n\n  // query pairings\n  public abstract getPairings(): PairingTypes.Struct[];\n\n  // for either to ping a peer\n  public abstract ping(params: { topic: string }): Promise<void>;\n\n  // for either peer to disconnect a pairing\n  public abstract disconnect(params: { topic: string }): Promise<void>;\n\n  public abstract formatUriFromPairing(pairing: PairingTypes.Struct): string;\n}\n\nexport interface IPairingPrivate {\n  sendRequest<M extends PairingJsonRpcTypes.WcMethod>(\n    topic: string,\n    method: M,\n    params: PairingJsonRpcTypes.RequestParams[M],\n  ): Promise<number>;\n\n  sendResult<M extends PairingJsonRpcTypes.WcMethod>(\n    id: number,\n    topic: string,\n    result: PairingJsonRpcTypes.Results[M],\n  ): Promise<void>;\n\n  sendError(id: number, topic: string, error: PairingJsonRpcTypes.Error): Promise<void>;\n\n  onRelayEventRequest(event: PairingJsonRpcTypes.EventCallback<JsonRpcRequest>): Promise<void>;\n\n  onRelayEventResponse(event: PairingJsonRpcTypes.EventCallback<JsonRpcResponse>): Promise<void>;\n\n  onPairingPingRequest(\n    topic: string,\n    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams[\"wc_pairingPing\"]>,\n  ): Promise<void>;\n\n  onPairingPingResponse(\n    topic: string,\n    payload: JsonRpcResult<PairingJsonRpcTypes.Results[\"wc_pairingPing\"]> | JsonRpcError,\n  ): void;\n\n  onPairingDeleteRequest(\n    topic: string,\n    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams[\"wc_pairingDelete\"]>,\n  ): Promise<void>;\n\n  onUnknownRpcMethodRequest(topic: string, payload: JsonRpcRequest): Promise<void>;\n\n  onUnknownRpcMethodResponse(method: string): void;\n\n  deletePairing(topic: string, expirerHasDeleted?: boolean): Promise<void>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { IKeyValueStorage } from \"@walletconnect/keyvaluestorage\";\nimport { ICore } from \"./core\";\n\nexport declare namespace Verify {\n  export interface Context {\n    verified: {\n      origin: string;\n      validation: \"UNKNOWN\" | \"VALID\" | \"INVALID\";\n      verifyUrl: string;\n      isScam?: boolean;\n    };\n  }\n}\n\nexport abstract class IVerify {\n  public abstract readonly context: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public store: IKeyValueStorage,\n  ) {}\n\n  public abstract register(params: {\n    id: string;\n    decryptedId: string;\n  }): Promise<string | undefined>;\n\n  public abstract resolve(params: {\n    attestationId?: string;\n    hash?: string;\n    encryptedId?: string;\n    verifyUrl?: string;\n  }): Promise<{ origin: string; isScam?: boolean }>;\n}\n","import { Logger } from \"@walletconnect/logger\";\n\nexport declare namespace EchoClientTypes {\n  type RegisterDeviceTokenParams = {\n    clientId: string;\n    token: string;\n    notificationType: \"fcm\" | \"apns\" | \"apns-sandbox\" | \"noop\";\n    enableEncrypted?: boolean;\n  };\n}\nexport abstract class IEchoClient {\n  public abstract readonly context: string;\n  constructor(\n    public projectId: string,\n    public logger: Logger,\n  ) {}\n\n  public abstract registerDeviceToken(\n    params: EchoClientTypes.RegisterDeviceTokenParams,\n  ): Promise<void>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport declare namespace EventClientTypes {\n  export interface Event {\n    eventId: string;\n    bundleId: string;\n    timestamp: number;\n    props: Props;\n    addTrace: (trace: string) => void;\n    setError: (error: string) => void;\n  }\n\n  export interface Props {\n    event: string;\n    type: string;\n    properties: Properties;\n  }\n\n  export interface Properties {\n    topic: string;\n    trace: Trace;\n  }\n\n  export type Trace = string[];\n}\n\nexport abstract class IEventClient {\n  public abstract readonly context: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public telemetryEnabled: boolean,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract createEvent(params: {\n    event?: \"ERROR\";\n    type?: string;\n    properties: {\n      topic: string;\n      trace: EventClientTypes.Trace;\n    };\n  }): EventClientTypes.Event;\n\n  public abstract getEvent(params: {\n    eventId?: string;\n    topic?: string;\n  }): EventClientTypes.Event | undefined;\n\n  public abstract deleteEvent(params: { eventId: string }): void;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport EventEmmiter from \"events\";\nimport { CoreTypes, ICore } from \"../core/core\";\nimport { IEngine } from \"./engine\";\nimport { IPendingRequest } from \"./pendingRequest\";\nimport { IProposal, ProposalTypes } from \"./proposal\";\nimport { ISession, SessionTypes } from \"./session\";\nimport { Verify } from \"../core/verify\";\nimport { IAuth, AuthTypes } from \"./auth\";\nimport { RelayerTypes } from \"../core\";\n\nexport declare namespace SignClientTypes {\n  type Event =\n    | \"session_proposal\"\n    | \"session_update\"\n    | \"session_extend\"\n    | \"session_ping\"\n    | \"session_delete\"\n    | \"session_expire\"\n    | \"session_request\"\n    | \"session_request_sent\"\n    | \"session_event\"\n    | \"session_authenticate\"\n    | \"proposal_expire\"\n    | \"session_request_expire\"\n    | \"session_connect\";\n\n  interface BaseEventArgs<T = unknown> {\n    id: number;\n    topic: string;\n    params: T;\n  }\n  interface EventArguments {\n    session_proposal: {\n      verifyContext: Verify.Context;\n    } & Omit<BaseEventArgs<ProposalTypes.Struct>, \"topic\">;\n    session_update: BaseEventArgs<{ namespaces: SessionTypes.Namespaces }>;\n    session_extend: Omit<BaseEventArgs, \"params\">;\n    session_ping: Omit<BaseEventArgs, \"params\">;\n    session_delete: Omit<BaseEventArgs, \"params\">;\n    session_expire: { topic: string };\n    session_request: {\n      verifyContext: Verify.Context;\n    } & BaseEventArgs<{\n      request: { method: string; params: any; expiryTimestamp?: number };\n      chainId: string;\n    }>;\n    session_request_sent: {\n      request: { method: string; params: any };\n      topic: string;\n      chainId: string;\n      id: number;\n    };\n    session_event: BaseEventArgs<{\n      event: { name: string; data: any };\n      chainId: string;\n    }>;\n    session_authenticate: {\n      verifyContext: Verify.Context;\n      transportType?: RelayerTypes.TransportType;\n    } & BaseEventArgs<AuthTypes.AuthRequestEventArgs>;\n    proposal_expire: { id: number };\n    session_request_expire: { id: number };\n    session_connect: { session: SessionTypes.Struct };\n  }\n\n  type Metadata = CoreTypes.Metadata;\n\n  type SignConfig = {\n    disableRequestQueue?: boolean;\n  };\n\n  interface Options extends CoreTypes.Options {\n    core?: ICore;\n    metadata?: Metadata;\n    signConfig?: SignConfig;\n  }\n}\n\nexport abstract class ISignClientEvents extends EventEmmiter {\n  constructor() {\n    super();\n  }\n\n  public abstract emit: <E extends SignClientTypes.Event>(\n    event: E,\n    args: SignClientTypes.EventArguments[E],\n  ) => boolean;\n\n  public abstract on: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract once: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract off: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract removeListener: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract removeAllListeners: <E extends SignClientTypes.Event>(event: E) => this;\n}\n\nexport abstract class ISignClient {\n  public readonly protocol = \"wc\";\n  public readonly version = 2;\n\n  public abstract readonly name: string;\n  public abstract readonly context: string;\n  public abstract readonly metadata: SignClientTypes.Metadata;\n\n  public abstract core: ICore;\n  public abstract logger: Logger;\n  public abstract events: ISignClientEvents;\n  public abstract engine: IEngine;\n  public abstract session: ISession;\n  public abstract proposal: IProposal;\n  public abstract pendingRequest: IPendingRequest;\n  public abstract auth: IAuth;\n  public abstract signConfig?: SignClientTypes.SignConfig;\n\n  constructor(public opts?: SignClientTypes.Options) {}\n\n  public abstract connect: IEngine[\"connect\"];\n  public abstract pair: IEngine[\"pair\"];\n  public abstract approve: IEngine[\"approve\"];\n  public abstract reject: IEngine[\"reject\"];\n  public abstract update: IEngine[\"update\"];\n  public abstract extend: IEngine[\"extend\"];\n  public abstract request: IEngine[\"request\"];\n  public abstract respond: IEngine[\"respond\"];\n  public abstract ping: IEngine[\"ping\"];\n  public abstract emit: IEngine[\"emit\"];\n  public abstract disconnect: IEngine[\"disconnect\"];\n  public abstract find: IEngine[\"find\"];\n  public abstract getPendingSessionRequests: IEngine[\"getPendingSessionRequests\"];\n  public abstract authenticate: IEngine[\"authenticate\"];\n  public abstract formatAuthMessage: IEngine[\"formatAuthMessage\"];\n  public abstract approveSessionAuthenticate: IEngine[\"approveSessionAuthenticate\"];\n  public abstract rejectSessionAuthenticate: IEngine[\"rejectSessionAuthenticate\"];\n}\n","import {\n  JsonRpcResponse,\n  JsonRpcRequest,\n  ErrorResponse,\n  JsonRpcResult,\n  JsonRpcError,\n} from \"@walletconnect/jsonrpc-types\";\nimport { ISignClient } from \"./client\";\nimport { RelayerTypes } from \"../core/relayer\";\nimport { SessionTypes } from \"./session\";\nimport { ProposalTypes } from \"./proposal\";\nimport { PairingTypes } from \"../core/pairing\";\nimport { JsonRpcTypes } from \"./jsonrpc\";\nimport { EventEmitter } from \"events\";\nimport { PendingRequestTypes } from \"./pendingRequest\";\nimport { AuthTypes } from \"./auth\";\nimport { CryptoTypes } from \"../core\";\n\nexport declare namespace EngineTypes {\n  type Event =\n    | \"session_connect\"\n    | \"session_approve\"\n    | \"session_update\"\n    | \"session_extend\"\n    | \"session_ping\"\n    | \"pairing_ping\"\n    | \"session_request\";\n\n  interface EventArguments {\n    session_connect: {\n      error?: ErrorResponse;\n      session?: SessionTypes.Struct;\n    };\n    session_approve: { error?: ErrorResponse };\n    session_update: { error?: ErrorResponse };\n    session_extend: { error?: ErrorResponse };\n    session_ping: { error?: ErrorResponse };\n    pairing_ping: { error?: ErrorResponse };\n    session_request: { error?: ErrorResponse; result?: any };\n  }\n\n  interface UriParameters {\n    protocol: string;\n    version: number;\n    topic: string;\n    symKey: string;\n    relay: RelayerTypes.ProtocolOptions;\n    methods?: string[];\n    expiryTimestamp?: number;\n  }\n\n  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {\n    topic: string;\n    payload: T;\n    transportType?: RelayerTypes.MessageEvent[\"transportType\"];\n    attestation?: string;\n    encryptedId?: string;\n  }\n\n  interface ConnectParams {\n    /**\n     * @deprecated Use `optionalNamespaces` instead.\n     */\n    requiredNamespaces?: ProposalTypes.RequiredNamespaces;\n    optionalNamespaces?: ProposalTypes.OptionalNamespaces;\n    sessionProperties?: ProposalTypes.SessionProperties;\n    scopedProperties?: ProposalTypes.ScopedProperties;\n    pairingTopic?: string;\n    relays?: RelayerTypes.ProtocolOptions[];\n  }\n\n  interface PairParams {\n    uri: string;\n  }\n\n  interface ApproveParams {\n    id: number;\n    namespaces: SessionTypes.Namespaces;\n    sessionProperties?: ProposalTypes.SessionProperties;\n    scopedProperties?: ProposalTypes.ScopedProperties;\n    sessionConfig?: SessionTypes.SessionConfig;\n    relayProtocol?: string;\n  }\n\n  interface RejectParams {\n    id: number;\n    reason: ErrorResponse;\n  }\n\n  interface UpdateParams {\n    topic: string;\n    namespaces: SessionTypes.Namespaces;\n  }\n\n  interface ExtendParams {\n    topic: string;\n  }\n\n  interface RequestParams {\n    topic: string;\n    request: {\n      method: string;\n      params: any;\n    };\n    chainId: string;\n    expiry?: number;\n  }\n\n  interface RespondParams {\n    topic: string;\n    response: JsonRpcResponse;\n  }\n\n  interface EmitParams {\n    topic: string;\n    event: {\n      name: string;\n      data: any;\n    };\n    chainId: string;\n  }\n\n  interface PingParams {\n    topic: string;\n  }\n\n  interface DisconnectParams {\n    topic: string;\n    reason: ErrorResponse;\n  }\n\n  interface FindParams {\n    requiredNamespaces: ProposalTypes.RequiredNamespaces;\n  }\n\n  type AcknowledgedPromise = Promise<{ acknowledged: () => Promise<void> }>;\n\n  type SessionAuthenticateResponsePromise = {\n    uri: string;\n    response: () => Promise<AuthTypes.AuthenticateResponseResult>;\n  };\n\n  interface RpcOpts {\n    req: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n    res: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n    reject?: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n    autoReject?: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n  }\n\n  type RpcOptsMap = Record<JsonRpcTypes.WcMethod, RpcOpts>;\n\n  type EngineQueue<T> = {\n    state: \"IDLE\" | \"ACTIVE\";\n    queue: T[];\n  };\n}\n\nexport abstract class IEngineEvents extends EventEmitter {\n  constructor() {\n    super();\n  }\n\n  public abstract emit: <E extends EngineTypes.Event>(\n    event: string,\n    args: EngineTypes.EventArguments[E],\n  ) => boolean;\n\n  public abstract once: <E extends EngineTypes.Event>(\n    event: string,\n    listener: (args: EngineTypes.EventArguments[E]) => any,\n  ) => this;\n}\n\n// -- private method interface -------------------------------------- //\n\nexport interface EnginePrivate {\n  sendRequest<M extends JsonRpcTypes.WcMethod>(args: {\n    topic: string;\n    method: M;\n    params: JsonRpcTypes.RequestParams[M];\n    expiry?: number;\n    relayRpcId?: number;\n    clientRpcId?: number;\n    throwOnFailedPublish?: boolean;\n    appLink?: string;\n    tvf?: RelayerTypes.ITVF;\n  }): Promise<number>;\n\n  sendResult<M extends JsonRpcTypes.WcMethod>(args: {\n    id: number;\n    topic: string;\n    result: JsonRpcTypes.Results[M];\n    throwOnFailedPublish?: boolean;\n    encodeOpts?: CryptoTypes.EncodeOptions;\n    appLink?: string;\n  }): Promise<void>;\n\n  sendError(params: {\n    id: number;\n    topic: string;\n    error: JsonRpcTypes.Error;\n    encodeOpts?: CryptoTypes.EncodeOptions;\n    rpcOpts?: RelayerTypes.PublishOptions;\n    appLink?: string;\n  }): Promise<void>;\n\n  onRelayEventRequest(event: EngineTypes.EventCallback<JsonRpcRequest>): Promise<void>;\n\n  onRelayEventResponse(event: EngineTypes.EventCallback<JsonRpcResponse>): Promise<void>;\n\n  onRelayEventUnknownPayload(event: EngineTypes.EventCallback<any>): Promise<void>;\n\n  shouldIgnorePairingRequest(params: { topic: string; requestMethod: string }): boolean;\n\n  deleteSession(params: {\n    topic: string;\n    expirerHasDeleted?: boolean;\n    id?: number;\n    emitEvent?: boolean;\n  }): Promise<void>;\n\n  deleteProposal(id: number, expirerHasDeleted?: boolean): Promise<void>;\n\n  setExpiry(topic: string, expiry: number): Promise<void>;\n\n  setProposal(id: number, proposal: ProposalTypes.Struct): Promise<void>;\n\n  setAuthRequest(\n    id: number,\n    params: {\n      request: AuthTypes.SessionAuthenticateRequest;\n      pairingTopic: string;\n      transportType?: RelayerTypes.MessageEvent[\"transportType\"];\n    },\n  ): Promise<void>;\n\n  setPendingSessionRequest(pendingRequest: PendingRequestTypes.Struct): Promise<void>;\n\n  deletePendingSessionRequest(\n    id: number,\n    reason: ErrorResponse,\n    expirerHasDeleted?: boolean,\n  ): Promise<void>;\n\n  deletePendingAuthRequest(\n    id: number,\n    reason: ErrorResponse,\n    expirerHasDeleted?: boolean,\n  ): Promise<void>;\n\n  cleanupDuplicatePairings(session: SessionTypes.Struct): Promise<void>;\n\n  cleanup(): Promise<void>;\n\n  onSessionProposeRequest(params: {\n    topic: string;\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionPropose\"]>;\n    attestation?: string;\n    encryptedId?: string;\n  }): Promise<void>;\n\n  onSessionProposeResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionPropose\"]> | JsonRpcError,\n    transportType?: RelayerTypes.MessageEvent[\"transportType\"],\n  ): Promise<void>;\n\n  onSessionSettleRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionSettle\"]>,\n  ): Promise<void>;\n\n  onSessionSettleResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionSettle\"]> | JsonRpcError,\n  ): Promise<void>;\n\n  onSessionUpdateRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionUpdate\"]>,\n  ): Promise<void>;\n\n  onSessionUpdateResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionUpdate\"]> | JsonRpcError,\n  ): void;\n\n  onSessionExtendRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionExtend\"]>,\n  ): Promise<void>;\n\n  onSessionExtendResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionExtend\"]> | JsonRpcError,\n  ): void;\n\n  onSessionPingRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionPing\"]>,\n  ): Promise<void>;\n\n  onSessionPingResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionPing\"]> | JsonRpcError,\n  ): void;\n\n  onSessionDeleteRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionDelete\"]>,\n  ): Promise<void>;\n\n  onSessionRequest(params: {\n    topic: string;\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionRequest\"]>;\n    transportType?: RelayerTypes.MessageEvent[\"transportType\"];\n    attestation?: string;\n    encryptedId?: string;\n  }): Promise<void>;\n\n  onSessionRequestResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionRequest\"]> | JsonRpcError,\n  ): void;\n\n  onSessionEventRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionEvent\"]>,\n  ): Promise<void>;\n\n  onSessionAuthenticateRequest(params: {\n    topic: string;\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionAuthenticate\"]>;\n    transportType?: RelayerTypes.MessageEvent[\"transportType\"];\n    attestation?: string;\n    encryptedId?: string;\n  }): Promise<void>;\n\n  onSessionAuthenticateResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionAuthenticate\"]> | JsonRpcError,\n  ): void;\n\n  // -- Validators ---------------------------------------------------- //\n  isValidConnect(params: EngineTypes.ConnectParams): Promise<void>;\n\n  isValidSessionSettleRequest(params: JsonRpcTypes.RequestParams[\"wc_sessionSettle\"]): void;\n\n  isValidApprove(params: EngineTypes.ApproveParams): Promise<void>;\n\n  isValidReject(params: EngineTypes.RejectParams): Promise<void>;\n\n  isValidUpdate(params: EngineTypes.UpdateParams): Promise<void>;\n\n  isValidExtend(params: EngineTypes.ExtendParams): Promise<void>;\n\n  isValidRequest(params: EngineTypes.RequestParams): Promise<void>;\n\n  isValidRespond(params: EngineTypes.RespondParams): Promise<void>;\n\n  isValidPing(params: EngineTypes.PingParams): Promise<void>;\n\n  isValidEmit(params: EngineTypes.EmitParams): Promise<void>;\n\n  isValidDisconnect(params: EngineTypes.DisconnectParams): Promise<void>;\n}\n\n// -- class interface ----------------------------------------------- //\n\nexport abstract class IEngine {\n  constructor(public client: ISignClient) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract connect(\n    params: EngineTypes.ConnectParams,\n  ): Promise<{ uri?: string; approval: () => Promise<SessionTypes.Struct> }>;\n\n  public abstract pair(params: EngineTypes.PairParams): Promise<PairingTypes.Struct>;\n\n  public abstract approve(\n    params: EngineTypes.ApproveParams,\n  ): Promise<{ topic: string; acknowledged: () => Promise<SessionTypes.Struct> }>;\n\n  public abstract reject(params: EngineTypes.RejectParams): Promise<void>;\n\n  public abstract update(params: EngineTypes.UpdateParams): EngineTypes.AcknowledgedPromise;\n\n  public abstract extend(params: EngineTypes.ExtendParams): EngineTypes.AcknowledgedPromise;\n\n  public abstract request<T>(params: EngineTypes.RequestParams): Promise<T>;\n\n  public abstract respond(params: EngineTypes.RespondParams): Promise<void>;\n\n  public abstract emit(params: EngineTypes.EmitParams): Promise<void>;\n\n  public abstract ping(params: EngineTypes.PingParams): Promise<void>;\n\n  public abstract disconnect(params: EngineTypes.DisconnectParams): Promise<void>;\n\n  public abstract find: (params: EngineTypes.FindParams) => SessionTypes.Struct[];\n\n  public abstract getPendingSessionRequests: () => PendingRequestTypes.Struct[];\n\n  public abstract authenticate: (\n    params: AuthTypes.SessionAuthenticateParams,\n    walletUniversalLink?: string,\n  ) => Promise<EngineTypes.SessionAuthenticateResponsePromise>;\n\n  public abstract approveSessionAuthenticate: (\n    params: AuthTypes.ApproveSessionAuthenticateParams,\n  ) => Promise<{ session: SessionTypes.Struct | undefined }>;\n\n  public abstract formatAuthMessage: (params: {\n    request: AuthTypes.BaseAuthRequestParams;\n    iss: string;\n  }) => string;\n\n  public abstract rejectSessionAuthenticate(params: EngineTypes.RejectParams): Promise<void>;\n\n  public abstract processRelayMessageCache(): void;\n}\n"],"names":["IEvents","opts","__publicField","core","logger","keychain","relayer","name","storagePrefix","store","projectId","telemetryEnabled","EventEmmiter","EventEmitter","client"],"mappings":"","debugId":null}},
    {"offset": {"line": 7308, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/jsonrpc-ws-connection/node_modules/ws/browser.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function () {\n  throw new Error(\n    'ws does not work in the browser. Browser clients must use the native ' +\n      'WebSocket object'\n  );\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG;IACf,MAAM,IAAI,MACR,0EACE;AAEN","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7315, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js","sources":["file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/jsonrpc-ws-connection/src/utils.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/jsonrpc-ws-connection/src/ws.ts"],"sourcesContent":["export const resolveWebSocketImplementation = () => {\n  if (typeof WebSocket !== \"undefined\") {\n    return WebSocket;\n  } else if (typeof global !== \"undefined\" && typeof global.WebSocket !== \"undefined\") {\n    return global.WebSocket;\n  } else if (typeof window !== \"undefined\" && typeof window.WebSocket !== \"undefined\") {\n    return window.WebSocket;\n  } else if (typeof self !== \"undefined\" && typeof self.WebSocket !== \"undefined\") {\n    return self.WebSocket;\n  }\n\n  return require(\"ws\");\n};\n\nexport const hasBuiltInWebSocket = () =>\n  typeof WebSocket !== \"undefined\" ||\n  (typeof global !== \"undefined\" && typeof global.WebSocket !== \"undefined\") ||\n  (typeof window !== \"undefined\" && typeof window.WebSocket !== \"undefined\") ||\n  (typeof self !== \"undefined\" && typeof self.WebSocket !== \"undefined\");\n\nexport const isBrowser = () => typeof window !== \"undefined\";\n\nexport const truncateQuery = (wssUrl: string) => wssUrl.split(\"?\")[0];\n","import { EventEmitter } from \"events\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport {\n  formatJsonRpcError,\n  IJsonRpcConnection,\n  JsonRpcPayload,\n  isReactNative,\n  isWsUrl,\n  isLocalhostUrl,\n  parseConnectionError,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { truncateQuery, resolveWebSocketImplementation, hasBuiltInWebSocket } from \"./utils\";\n\n// Source: https://nodejs.org/api/events.html#emittersetmaxlistenersn\nconst EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;\n\nconst WS = resolveWebSocketImplementation();\n\nexport class WsConnection implements IJsonRpcConnection {\n  public events = new EventEmitter();\n\n  private socket: WebSocket | undefined;\n\n  private registering = false;\n\n  constructor(public url: string) {\n    if (!isWsUrl(url)) {\n      throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);\n    }\n    this.url = url;\n  }\n\n  get connected(): boolean {\n    return typeof this.socket !== \"undefined\";\n  }\n\n  get connecting(): boolean {\n    return this.registering;\n  }\n\n  public on(event: string, listener: any): void {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any): void {\n    this.events.once(event, listener);\n  }\n\n  public off(event: string, listener: any): void {\n    this.events.off(event, listener);\n  }\n\n  public removeListener(event: string, listener: any): void {\n    this.events.removeListener(event, listener);\n  }\n\n  public async open(url: string = this.url): Promise<void> {\n    await this.register(url);\n  }\n\n  public async close(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      if (typeof this.socket === \"undefined\") {\n        reject(new Error(\"Connection already closed\"));\n        return;\n      }\n\n      this.socket.onclose = (event) => {\n        this.onClose(event);\n        resolve();\n      };\n\n      this.socket.close();\n    });\n  }\n\n  public async send(payload: JsonRpcPayload): Promise<void> {\n    if (typeof this.socket === \"undefined\") {\n      this.socket = await this.register();\n    }\n    try {\n      this.socket.send(safeJsonStringify(payload));\n    } catch (e) {\n      this.onError(payload.id, e as Error);\n    }\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private register(url = this.url): Promise<WebSocket> {\n    if (!isWsUrl(url)) {\n      throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);\n    }\n    if (this.registering) {\n      const currentMaxListeners = this.events.getMaxListeners();\n      if (\n        this.events.listenerCount(\"register_error\") >= currentMaxListeners ||\n        this.events.listenerCount(\"open\") >= currentMaxListeners\n      ) {\n        this.events.setMaxListeners(currentMaxListeners + 1);\n      }\n      return new Promise((resolve, reject) => {\n        this.events.once(\"register_error\", (error) => {\n          this.resetMaxListeners();\n          reject(error);\n        });\n        this.events.once(\"open\", () => {\n          this.resetMaxListeners();\n          if (typeof this.socket === \"undefined\") {\n            return reject(new Error(\"WebSocket connection is missing or invalid\"));\n          }\n          resolve(this.socket);\n        });\n      });\n    }\n    this.url = url;\n    this.registering = true;\n\n    return new Promise((resolve, reject) => {\n      const opts = !isReactNative() ? { rejectUnauthorized: !isLocalhostUrl(url) } : undefined;\n      const socket: WebSocket = new WS(url, [], opts);\n      if (hasBuiltInWebSocket()) {\n        socket.onerror = (event: Event) => {\n          const errorEvent = event as ErrorEvent;\n          reject(this.emitError(errorEvent.error));\n        };\n      } else {\n        (socket as any).on(\"error\", (errorEvent: any) => {\n          reject(this.emitError(errorEvent));\n        });\n      }\n      socket.onopen = () => {\n        this.onOpen(socket);\n        resolve(socket);\n      };\n    });\n  }\n\n  private onOpen(socket: WebSocket) {\n    socket.onmessage = (event: MessageEvent) => this.onPayload(event);\n    socket.onclose = (event) => this.onClose(event);\n    this.socket = socket;\n    this.registering = false;\n    this.events.emit(\"open\");\n  }\n\n  private onClose(event: CloseEvent) {\n    this.socket = undefined;\n    this.registering = false;\n    this.events.emit(\"close\", event);\n  }\n\n  private onPayload(e: { data: any }) {\n    if (typeof e.data === \"undefined\") return;\n    const payload: JsonRpcPayload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n    this.events.emit(\"payload\", payload);\n  }\n\n  private onError(id: number, e: Error) {\n    const error = this.parseError(e);\n    const message = error.message || error.toString();\n    const payload = formatJsonRpcError(id, message);\n    this.events.emit(\"payload\", payload);\n  }\n\n  private parseError(e: Error, url = this.url) {\n    return parseConnectionError(e, truncateQuery(url), \"WS\");\n  }\n\n  private resetMaxListeners() {\n    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {\n      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);\n    }\n  }\n\n  private emitError(errorEvent: Error) {\n    const error = this.parseError(\n      new Error(\n        errorEvent?.message || `WebSocket connection failed for host: ${truncateQuery(this.url)}`,\n      ),\n    );\n    this.events.emit(\"register_error\", error);\n    return error;\n  }\n}\n\nexport default WsConnection;\n"],"names":["wssUrl","EVENT_EMITTER_MAX_LISTENERS_DEFAULT","WS","resolveWebSocketImplementation","url","EventEmitter","isWsUrl","event","listener","resolve","reject","payload","safeJsonStringify","e","currentMaxListeners","error","opts","isReactNative","isLocalhostUrl","socket","hasBuiltInWebSocket","errorEvent","safeJsonParse","id","message","formatJsonRpcError","parseConnectionError","truncateQuery"],"mappings":"","debugId":null}},
    {"offset": {"line": 7437, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/core/dist/index.es.js","sources":["file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/constants/core.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/constants/crypto.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/constants/keychain.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/constants/messages.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/constants/publisher.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/constants/relayer.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/constants/store.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/constants/subscriber.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/constants/pairing.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/constants/history.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/constants/expirer.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/constants/verify.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/constants/echo.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/constants/events.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/vendor/base-x.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bytes.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/identity.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base2.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base8.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base10.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base16.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base32.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base36.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base58.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base64.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/bases/base256emoji.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/vendor/varint.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/varint.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/hashes/digest.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/hashes/hasher.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/hashes/sha2-browser.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/hashes/identity.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/codecs/json.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/multiformats/esm/src/basics.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/uint8arrays/esm/src/alloc.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/uint8arrays/esm/src/util/bases.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/uint8arrays/esm/src/from-string.js","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/controllers/keychain.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/controllers/crypto.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/controllers/messages.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/controllers/publisher.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/controllers/topicmap.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/controllers/subscriber.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/controllers/relayer.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/function/noop.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/predicate/isPlainObject.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/compat/_internal/getTag.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/compat/_internal/tags.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/compat/util/eq.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/predicate/isEqualWith.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/predicate/isEqual.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/controllers/store.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/controllers/pairing.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/controllers/history.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/controllers/expirer.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/controllers/verify.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/controllers/echo.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/controllers/events.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/core.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/core/src/index.ts"],"sourcesContent":["export const CORE_PROTOCOL = \"wc\";\nexport const CORE_VERSION = 2;\nexport const CORE_CONTEXT = \"core\";\n\nexport const CORE_STORAGE_PREFIX = `${CORE_PROTOCOL}@${CORE_VERSION}:${CORE_CONTEXT}:`;\n\nexport const CORE_DEFAULT = {\n  name: CORE_CONTEXT,\n  logger: \"error\",\n};\n\nexport const CORE_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n","import { ONE_DAY } from \"@walletconnect/time\";\n\nexport const CRYPTO_CONTEXT = \"crypto\";\n\nexport const CRYPTO_CLIENT_SEED = \"client_ed25519_seed\";\n\nexport const CRYPTO_JWT_TTL = ONE_DAY;\n","export const KEYCHAIN_CONTEXT = \"keychain\";\n\nexport const KEYCHAIN_STORAGE_VERSION = \"0.3\";\n","export const MESSAGES_CONTEXT = \"messages\";\n\nexport const MESSAGES_STORAGE_VERSION = \"0.3\";\n","import { SIX_HOURS } from \"@walletconnect/time\";\n\nexport const PUBLISHER_DEFAULT_TTL = SIX_HOURS;\n\nexport const PUBLISHER_CONTEXT = \"publisher\";\n","export const RELAYER_DEFAULT_PROTOCOL = \"irn\";\n\nexport const RELAYER_DEFAULT_LOGGER = \"error\";\n\nexport const RELAYER_DEFAULT_RELAY_URL = \"wss://relay.walletconnect.org\";\n\nexport const RELAYER_CONTEXT = \"relayer\";\n\nexport const RELAYER_EVENTS = {\n  message: \"relayer_message\",\n  message_ack: \"relayer_message_ack\",\n  connect: \"relayer_connect\",\n  disconnect: \"relayer_disconnect\",\n  error: \"relayer_error\",\n  connection_stalled: \"relayer_connection_stalled\",\n  transport_closed: \"relayer_transport_closed\",\n  publish: \"relayer_publish\",\n};\n\nexport const RELAYER_SUBSCRIBER_SUFFIX = \"_subscription\";\n\nexport const RELAYER_PROVIDER_EVENTS = {\n  payload: \"payload\",\n  connect: \"connect\",\n  disconnect: \"disconnect\",\n  error: \"error\",\n};\n\nexport const RELAYER_RECONNECT_TIMEOUT = 0.1;\n\nexport const RELAYER_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n\n// Updated automatically via `new-version` npm script.\n\nexport const RELAYER_SDK_VERSION = \"2.21.1\";\n\n// delay to wait before closing the transport connection after init if not active\nexport const RELAYER_TRANSPORT_CUTOFF = 10_000;\n\nexport const TRANSPORT_TYPES = {\n  link_mode: \"link_mode\",\n  relay: \"relay\",\n} as const;\n\nexport const MESSAGE_DIRECTION = {\n  inbound: \"inbound\",\n  outbound: \"outbound\",\n} as const;\n","export const STORE_STORAGE_VERSION = \"0.3\";\n\nexport const WALLETCONNECT_CLIENT_ID = \"WALLETCONNECT_CLIENT_ID\";\nexport const WALLETCONNECT_LINK_MODE_APPS = \"WALLETCONNECT_LINK_MODE_APPS\";\n","import { THIRTY_DAYS, FIVE_SECONDS } from \"@walletconnect/time\";\n\nexport const SUBSCRIBER_EVENTS = {\n  created: \"subscription_created\",\n  deleted: \"subscription_deleted\",\n  expired: \"subscription_expired\",\n  disabled: \"subscription_disabled\",\n  sync: \"subscription_sync\",\n  resubscribed: \"subscription_resubscribed\",\n};\n\nexport const SUBSCRIBER_DEFAULT_TTL = THIRTY_DAYS;\n\nexport const SUBSCRIBER_CONTEXT = \"subscription\";\n\nexport const SUBSCRIBER_STORAGE_VERSION = \"0.3\";\n\nexport const PENDING_SUB_RESOLUTION_TIMEOUT = FIVE_SECONDS * 1000;\n","import { THIRTY_DAYS, ONE_DAY, THIRTY_SECONDS } from \"@walletconnect/time\";\nimport { RelayerTypes, PairingJsonRpcTypes } from \"@walletconnect/types\";\n\nexport const PAIRING_CONTEXT = \"pairing\";\n\nexport const PAIRING_STORAGE_VERSION = \"0.3\";\n\nexport const PAIRING_DEFAULT_TTL = THIRTY_DAYS;\n\nexport const PAIRING_RPC_OPTS: Record<\n  PairingJsonRpcTypes.WcMethod | \"unregistered_method\",\n  {\n    req: RelayerTypes.PublishOptions;\n    res: RelayerTypes.PublishOptions;\n  }\n> = {\n  wc_pairingDelete: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1000,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1001,\n    },\n  },\n  wc_pairingPing: {\n    req: {\n      ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1002,\n    },\n    res: {\n      ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1003,\n    },\n  },\n  unregistered_method: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 0,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 0,\n    },\n  },\n};\n\nexport const PAIRING_EVENTS = {\n  create: \"pairing_create\",\n  expire: \"pairing_expire\",\n  delete: \"pairing_delete\",\n  ping: \"pairing_ping\",\n};\n","export const HISTORY_EVENTS = {\n  created: \"history_created\",\n  updated: \"history_updated\",\n  deleted: \"history_deleted\",\n  sync: \"history_sync\",\n};\n\nexport const HISTORY_CONTEXT = \"history\";\n\nexport const HISTORY_STORAGE_VERSION = \"0.3\";\n","import { ONE_DAY } from \"@walletconnect/time\";\n\nexport const EXPIRER_CONTEXT = \"expirer\";\n\nexport const EXPIRER_EVENTS = {\n  created: \"expirer_created\",\n  deleted: \"expirer_deleted\",\n  expired: \"expirer_expired\",\n  sync: \"expirer_sync\",\n};\n\nexport const EXPIRER_STORAGE_VERSION = \"0.3\";\n\nexport const EXPIRER_DEFAULT_TTL = ONE_DAY;\n","export const VERIFY_CONTEXT = \"verify-api\";\n\nconst VERIFY_SERVER_COM = \"https://verify.walletconnect.com\";\nconst VERIFY_SERVER_ORG = \"https://verify.walletconnect.org\";\nexport const VERIFY_SERVER = VERIFY_SERVER_ORG;\nexport const VERIFY_SERVER_V3 = `${VERIFY_SERVER}/v3`;\n\nexport const TRUSTED_VERIFY_URLS = [VERIFY_SERVER_COM, VERIFY_SERVER_ORG];\n","export const ECHO_CONTEXT = \"echo\";\n\nexport const ECHO_URL = \"https://echo.walletconnect.com\";\n","export const EVENT_CLIENT_CONTEXT = \"event-client\";\n\nexport const EVENT_CLIENT_PAIRING_TRACES = {\n  pairing_started: \"pairing_started\",\n  pairing_uri_validation_success: \"pairing_uri_validation_success\",\n  pairing_uri_not_expired: \"pairing_uri_not_expired\",\n  store_new_pairing: \"store_new_pairing\",\n  subscribing_pairing_topic: \"subscribing_pairing_topic\",\n  subscribe_pairing_topic_success: \"subscribe_pairing_topic_success\",\n  existing_pairing: \"existing_pairing\",\n  pairing_not_expired: \"pairing_not_expired\",\n  emit_inactive_pairing: \"emit_inactive_pairing\",\n  emit_session_proposal: \"emit_session_proposal\",\n  subscribing_to_pairing_topic: \"subscribing_to_pairing_topic\",\n};\n\nexport const EVENT_CLIENT_PAIRING_ERRORS = {\n  no_wss_connection: \"no_wss_connection\",\n  no_internet_connection: \"no_internet_connection\",\n  malformed_pairing_uri: \"malformed_pairing_uri\",\n  active_pairing_already_exists: \"active_pairing_already_exists\",\n  subscribe_pairing_topic_failure: \"subscribe_pairing_topic_failure\",\n  pairing_expired: \"pairing_expired\",\n  proposal_expired: \"proposal_expired\",\n  proposal_listener_not_found: \"proposal_listener_not_found\",\n};\n\nexport const EVENT_CLIENT_SESSION_TRACES = {\n  session_approve_started: \"session_approve_started\",\n  proposal_not_expired: \"proposal_not_expired\",\n  session_namespaces_validation_success: \"session_namespaces_validation_success\",\n  create_session_topic: \"create_session_topic\",\n  subscribing_session_topic: \"subscribing_session_topic\",\n  subscribe_session_topic_success: \"subscribe_session_topic_success\",\n  publishing_session_approve: \"publishing_session_approve\",\n  session_approve_publish_success: \"session_approve_publish_success\",\n  store_session: \"store_session\",\n  publishing_session_settle: \"publishing_session_settle\",\n  session_settle_publish_success: \"session_settle_publish_success\",\n};\n\nexport const EVENT_CLIENT_SESSION_ERRORS = {\n  no_internet_connection: \"no_internet_connection\",\n  no_wss_connection: \"no_wss_connection\",\n  proposal_expired: \"proposal_expired\",\n  subscribe_session_topic_failure: \"subscribe_session_topic_failure\",\n  session_approve_publish_failure: \"session_approve_publish_failure\",\n  session_settle_publish_failure: \"session_settle_publish_failure\",\n  session_approve_namespace_validation_failure: \"session_approve_namespace_validation_failure\",\n  proposal_not_found: \"proposal_not_found\",\n};\n\nexport const EVENT_CLIENT_AUTHENTICATE_TRACES = {\n  authenticated_session_approve_started: \"authenticated_session_approve_started\",\n  authenticated_session_not_expired: \"authenticated_session_not_expired\",\n  chains_caip2_compliant: \"chains_caip2_compliant\",\n  chains_evm_compliant: \"chains_evm_compliant\",\n  create_authenticated_session_topic: \"create_authenticated_session_topic\",\n  cacaos_verified: \"cacaos_verified\",\n  store_authenticated_session: \"store_authenticated_session\",\n  subscribing_authenticated_session_topic: \"subscribing_authenticated_session_topic\",\n  subscribe_authenticated_session_topic_success: \"subscribe_authenticated_session_topic_success\",\n  publishing_authenticated_session_approve: \"publishing_authenticated_session_approve\",\n  authenticated_session_approve_publish_success: \"authenticated_session_approve_publish_success\",\n};\n\nexport const EVENT_CLIENT_AUTHENTICATE_ERRORS = {\n  no_internet_connection: \"no_internet_connection\",\n  no_wss_connection: \"no_wss_connection\",\n  missing_session_authenticate_request: \"missing_session_authenticate_request\",\n  session_authenticate_request_expired: \"session_authenticate_request_expired\",\n  chains_caip2_compliant_failure: \"chains_caip2_compliant_failure\",\n  chains_evm_compliant_failure: \"chains_evm_compliant_failure\",\n  invalid_cacao: \"invalid_cacao\",\n  subscribe_authenticated_session_topic_failure: \"subscribe_authenticated_session_topic_failure\",\n  authenticated_session_approve_publish_failure: \"authenticated_session_approve_publish_failure\",\n  authenticated_session_pending_request_not_found:\n    \"authenticated_session_pending_request_not_found\",\n};\n\nexport const EVENTS_STORAGE_VERSION = 0.1;\n\nexport const EVENTS_STORAGE_CONTEXT = \"event-client\";\n\nexport const EVENTS_STORAGE_CLEANUP_INTERVAL = 86400;\n\nexport const EVENTS_CLIENT_API_URL = \"https://pulse.walletconnect.org/batch\";\n","function base(ALPHABET, name) {\n  if (ALPHABET.length >= 255) {\n    throw new TypeError('Alphabet too long');\n  }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) {\n      throw new TypeError(x + ' is ambiguous');\n    }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256);\n  var iFACTOR = Math.log(256) / Math.log(BASE);\n  function encode(source) {\n    if (source instanceof Uint8Array);\n    else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) {\n      throw new TypeError('Expected Uint8Array');\n    }\n    if (source.length === 0) {\n      return '';\n    }\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n    var b58 = new Uint8Array(size);\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n        carry += 256 * b58[it1] >>> 0;\n        b58[it1] = carry % BASE >>> 0;\n        carry = carry / BASE >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      pbegin++;\n    }\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n      str += ALPHABET.charAt(b58[it2]);\n    }\n    return str;\n  }\n  function decodeUnsafe(source) {\n    if (typeof source !== 'string') {\n      throw new TypeError('Expected String');\n    }\n    if (source.length === 0) {\n      return new Uint8Array();\n    }\n    var psz = 0;\n    if (source[psz] === ' ') {\n      return;\n    }\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n    var size = (source.length - psz) * FACTOR + 1 >>> 0;\n    var b256 = new Uint8Array(size);\n    while (source[psz]) {\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n      if (carry === 255) {\n        return;\n      }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n        carry += BASE * b256[it3] >>> 0;\n        b256[it3] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      psz++;\n    }\n    if (source[psz] === ' ') {\n      return;\n    }\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch;\n  }\n  function decode(string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) {\n      return buffer;\n    }\n    throw new Error(`Non-${ name } character`);\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nexport default _brrp__multiformats_scope_baseX;","const empty = new Uint8Array(0);\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\nconst fromHex = hex => {\n  const hexes = hex.match(/../g);\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n};\nconst equals = (aa, bb) => {\n  if (aa === bb)\n    return true;\n  if (aa.byteLength !== bb.byteLength) {\n    return false;\n  }\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false;\n    }\n  }\n  return true;\n};\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n    return o;\n  if (o instanceof ArrayBuffer)\n    return new Uint8Array(o);\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n};\nconst isBinary = o => o instanceof ArrayBuffer || ArrayBuffer.isView(o);\nconst fromString = str => new TextEncoder().encode(str);\nconst toString = b => new TextDecoder().decode(b);\nexport {\n  equals,\n  coerce,\n  isBinary,\n  fromHex,\n  toHex,\n  fromString,\n  toString,\n  empty\n};","import basex from '../../vendor/base-x.js';\nimport { coerce } from '../bytes.js';\nclass Encoder {\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${ this.prefix }${ this.baseEncode(bytes) }`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}\nclass Decoder {\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character');\n    }\n    this.prefixCodePoint = prefix.codePointAt(0);\n    this.baseDecode = baseDecode;\n  }\n  decode(text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);\n      }\n      return this.baseDecode(text.slice(this.prefix.length));\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n}\nclass ComposedDecoder {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);\n    }\n  }\n}\nexport const or = (left, right) => new ComposedDecoder({\n  ...left.decoders || { [left.prefix]: left },\n  ...right.decoders || { [right.prefix]: right }\n});\nexport class Codec {\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n}\nexport const from = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);\nexport const baseX = ({prefix, name, alphabet}) => {\n  const {encode, decode} = basex(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => coerce(decode(text))\n  });\n};\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  const codes = {};\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n  let end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string[i]];\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${ name } character`);\n    }\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0;\n  let buffer = 0;\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\nexport const rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {\n  return from({\n    prefix,\n    name,\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n  });\n};","import { from } from './base.js';\nimport {\n  fromString,\n  toString\n} from '../bytes.js';\nexport const identity = from({\n  prefix: '\\0',\n  name: 'identity',\n  encode: buf => toString(buf),\n  decode: str => fromString(str)\n});","import { rfc4648 } from './base.js';\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n});","import { rfc4648 } from './base.js';\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n});","import { baseX } from './base.js';\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n});","import { rfc4648 } from './base.js';\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n});\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n});","import { rfc4648 } from './base.js';\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n});\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n});\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n});\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n});\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n});\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n});\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n});\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n});\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n});","import { baseX } from './base.js';\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n});\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n});","import { baseX } from './base.js';\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});","import { rfc4648 } from './base.js';\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n});\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n});\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n});\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n});","import { from } from './base.js';\nconst alphabet = Array.from('\\uD83D\\uDE80\\uD83E\\uDE90\\u2604\\uD83D\\uDEF0\\uD83C\\uDF0C\\uD83C\\uDF11\\uD83C\\uDF12\\uD83C\\uDF13\\uD83C\\uDF14\\uD83C\\uDF15\\uD83C\\uDF16\\uD83C\\uDF17\\uD83C\\uDF18\\uD83C\\uDF0D\\uD83C\\uDF0F\\uD83C\\uDF0E\\uD83D\\uDC09\\u2600\\uD83D\\uDCBB\\uD83D\\uDDA5\\uD83D\\uDCBE\\uD83D\\uDCBF\\uD83D\\uDE02\\u2764\\uD83D\\uDE0D\\uD83E\\uDD23\\uD83D\\uDE0A\\uD83D\\uDE4F\\uD83D\\uDC95\\uD83D\\uDE2D\\uD83D\\uDE18\\uD83D\\uDC4D\\uD83D\\uDE05\\uD83D\\uDC4F\\uD83D\\uDE01\\uD83D\\uDD25\\uD83E\\uDD70\\uD83D\\uDC94\\uD83D\\uDC96\\uD83D\\uDC99\\uD83D\\uDE22\\uD83E\\uDD14\\uD83D\\uDE06\\uD83D\\uDE44\\uD83D\\uDCAA\\uD83D\\uDE09\\u263A\\uD83D\\uDC4C\\uD83E\\uDD17\\uD83D\\uDC9C\\uD83D\\uDE14\\uD83D\\uDE0E\\uD83D\\uDE07\\uD83C\\uDF39\\uD83E\\uDD26\\uD83C\\uDF89\\uD83D\\uDC9E\\u270C\\u2728\\uD83E\\uDD37\\uD83D\\uDE31\\uD83D\\uDE0C\\uD83C\\uDF38\\uD83D\\uDE4C\\uD83D\\uDE0B\\uD83D\\uDC97\\uD83D\\uDC9A\\uD83D\\uDE0F\\uD83D\\uDC9B\\uD83D\\uDE42\\uD83D\\uDC93\\uD83E\\uDD29\\uD83D\\uDE04\\uD83D\\uDE00\\uD83D\\uDDA4\\uD83D\\uDE03\\uD83D\\uDCAF\\uD83D\\uDE48\\uD83D\\uDC47\\uD83C\\uDFB6\\uD83D\\uDE12\\uD83E\\uDD2D\\u2763\\uD83D\\uDE1C\\uD83D\\uDC8B\\uD83D\\uDC40\\uD83D\\uDE2A\\uD83D\\uDE11\\uD83D\\uDCA5\\uD83D\\uDE4B\\uD83D\\uDE1E\\uD83D\\uDE29\\uD83D\\uDE21\\uD83E\\uDD2A\\uD83D\\uDC4A\\uD83E\\uDD73\\uD83D\\uDE25\\uD83E\\uDD24\\uD83D\\uDC49\\uD83D\\uDC83\\uD83D\\uDE33\\u270B\\uD83D\\uDE1A\\uD83D\\uDE1D\\uD83D\\uDE34\\uD83C\\uDF1F\\uD83D\\uDE2C\\uD83D\\uDE43\\uD83C\\uDF40\\uD83C\\uDF37\\uD83D\\uDE3B\\uD83D\\uDE13\\u2B50\\u2705\\uD83E\\uDD7A\\uD83C\\uDF08\\uD83D\\uDE08\\uD83E\\uDD18\\uD83D\\uDCA6\\u2714\\uD83D\\uDE23\\uD83C\\uDFC3\\uD83D\\uDC90\\u2639\\uD83C\\uDF8A\\uD83D\\uDC98\\uD83D\\uDE20\\u261D\\uD83D\\uDE15\\uD83C\\uDF3A\\uD83C\\uDF82\\uD83C\\uDF3B\\uD83D\\uDE10\\uD83D\\uDD95\\uD83D\\uDC9D\\uD83D\\uDE4A\\uD83D\\uDE39\\uD83D\\uDDE3\\uD83D\\uDCAB\\uD83D\\uDC80\\uD83D\\uDC51\\uD83C\\uDFB5\\uD83E\\uDD1E\\uD83D\\uDE1B\\uD83D\\uDD34\\uD83D\\uDE24\\uD83C\\uDF3C\\uD83D\\uDE2B\\u26BD\\uD83E\\uDD19\\u2615\\uD83C\\uDFC6\\uD83E\\uDD2B\\uD83D\\uDC48\\uD83D\\uDE2E\\uD83D\\uDE46\\uD83C\\uDF7B\\uD83C\\uDF43\\uD83D\\uDC36\\uD83D\\uDC81\\uD83D\\uDE32\\uD83C\\uDF3F\\uD83E\\uDDE1\\uD83C\\uDF81\\u26A1\\uD83C\\uDF1E\\uD83C\\uDF88\\u274C\\u270A\\uD83D\\uDC4B\\uD83D\\uDE30\\uD83E\\uDD28\\uD83D\\uDE36\\uD83E\\uDD1D\\uD83D\\uDEB6\\uD83D\\uDCB0\\uD83C\\uDF53\\uD83D\\uDCA2\\uD83E\\uDD1F\\uD83D\\uDE41\\uD83D\\uDEA8\\uD83D\\uDCA8\\uD83E\\uDD2C\\u2708\\uD83C\\uDF80\\uD83C\\uDF7A\\uD83E\\uDD13\\uD83D\\uDE19\\uD83D\\uDC9F\\uD83C\\uDF31\\uD83D\\uDE16\\uD83D\\uDC76\\uD83E\\uDD74\\u25B6\\u27A1\\u2753\\uD83D\\uDC8E\\uD83D\\uDCB8\\u2B07\\uD83D\\uDE28\\uD83C\\uDF1A\\uD83E\\uDD8B\\uD83D\\uDE37\\uD83D\\uDD7A\\u26A0\\uD83D\\uDE45\\uD83D\\uDE1F\\uD83D\\uDE35\\uD83D\\uDC4E\\uD83E\\uDD32\\uD83E\\uDD20\\uD83E\\uDD27\\uD83D\\uDCCC\\uD83D\\uDD35\\uD83D\\uDC85\\uD83E\\uDDD0\\uD83D\\uDC3E\\uD83C\\uDF52\\uD83D\\uDE17\\uD83E\\uDD11\\uD83C\\uDF0A\\uD83E\\uDD2F\\uD83D\\uDC37\\u260E\\uD83D\\uDCA7\\uD83D\\uDE2F\\uD83D\\uDC86\\uD83D\\uDC46\\uD83C\\uDFA4\\uD83D\\uDE47\\uD83C\\uDF51\\u2744\\uD83C\\uDF34\\uD83D\\uDCA3\\uD83D\\uDC38\\uD83D\\uDC8C\\uD83D\\uDCCD\\uD83E\\uDD40\\uD83E\\uDD22\\uD83D\\uDC45\\uD83D\\uDCA1\\uD83D\\uDCA9\\uD83D\\uDC50\\uD83D\\uDCF8\\uD83D\\uDC7B\\uD83E\\uDD10\\uD83E\\uDD2E\\uD83C\\uDFBC\\uD83E\\uDD75\\uD83D\\uDEA9\\uD83C\\uDF4E\\uD83C\\uDF4A\\uD83D\\uDC7C\\uD83D\\uDC8D\\uD83D\\uDCE3\\uD83E\\uDD42');\nconst alphabetBytesToChars = alphabet.reduce((p, c, i) => {\n  p[i] = c;\n  return p;\n}, []);\nconst alphabetCharsToBytes = alphabet.reduce((p, c, i) => {\n  p[c.codePointAt(0)] = i;\n  return p;\n}, []);\nfunction encode(data) {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c];\n    return p;\n  }, '');\n}\nfunction decode(str) {\n  const byts = [];\n  for (const char of str) {\n    const byt = alphabetCharsToBytes[char.codePointAt(0)];\n    if (byt === undefined) {\n      throw new Error(`Non-base256emoji character: ${ char }`);\n    }\n    byts.push(byt);\n  }\n  return new Uint8Array(byts);\n}\nexport const base256emoji = from({\n  prefix: '\\uD83D\\uDE80',\n  name: 'base256emoji',\n  encode,\n  decode\n});","var encode_1 = encode;\nvar MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n  while (num >= INT) {\n    out[offset++] = num & 255 | MSB;\n    num /= 128;\n  }\n  while (num & MSBALL) {\n    out[offset++] = num & 255 | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  encode.bytes = offset - oldOffset + 1;\n  return out;\n}\nvar decode = read;\nvar MSB$1 = 128, REST$1 = 127;\nfunction read(buf, offset) {\n  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint');\n    }\n    b = buf[counter++];\n    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1);\n  read.bytes = counter - offset;\n  return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (value) {\n  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;\n};\nvar varint = {\n  encode: encode_1,\n  decode: decode,\n  encodingLength: length\n};\nvar _brrp_varint = varint;\nexport default _brrp_varint;","import varint from '../vendor/varint.js';\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset);\n  return [\n    code,\n    varint.decode.bytes\n  ];\n};\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset);\n  return target;\n};\nexport const encodingLength = int => {\n  return varint.encodingLength(int);\n};","import {\n  coerce,\n  equals as equalBytes\n} from '../bytes.js';\nimport * as varint from '../varint.js';\nexport const create = (code, digest) => {\n  const size = digest.byteLength;\n  const sizeOffset = varint.encodingLength(code);\n  const digestOffset = sizeOffset + varint.encodingLength(size);\n  const bytes = new Uint8Array(digestOffset + size);\n  varint.encodeTo(code, bytes, 0);\n  varint.encodeTo(size, bytes, sizeOffset);\n  bytes.set(digest, digestOffset);\n  return new Digest(code, size, digest, bytes);\n};\nexport const decode = multihash => {\n  const bytes = coerce(multihash);\n  const [code, sizeOffset] = varint.decode(bytes);\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset));\n  const digest = bytes.subarray(sizeOffset + digestOffset);\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length');\n  }\n  return new Digest(code, size, digest, bytes);\n};\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true;\n  } else {\n    return a.code === b.code && a.size === b.size && equalBytes(a.bytes, b.bytes);\n  }\n};\nexport class Digest {\n  constructor(code, size, digest, bytes) {\n    this.code = code;\n    this.size = size;\n    this.digest = digest;\n    this.bytes = bytes;\n  }\n}","import * as Digest from './digest.js';\nexport const from = ({name, code, encode}) => new Hasher(name, code, encode);\nexport class Hasher {\n  constructor(name, code, encode) {\n    this.name = name;\n    this.code = code;\n    this.encode = encode;\n  }\n  digest(input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input);\n      return result instanceof Uint8Array ? Digest.create(this.code, result) : result.then(digest => Digest.create(this.code, digest));\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}","import { from } from './hasher.js';\nconst sha = name => async data => new Uint8Array(await crypto.subtle.digest(name, data));\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 18,\n  encode: sha('SHA-256')\n});\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 19,\n  encode: sha('SHA-512')\n});","import { coerce } from '../bytes.js';\nimport * as Digest from './digest.js';\nconst code = 0;\nconst name = 'identity';\nconst encode = coerce;\nconst digest = input => Digest.create(code, encode(input));\nexport const identity = {\n  code,\n  name,\n  encode,\n  digest\n};","const textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nexport const name = 'json';\nexport const code = 512;\nexport const encode = node => textEncoder.encode(JSON.stringify(node));\nexport const decode = data => JSON.parse(textDecoder.decode(data));","import * as identityBase from './bases/identity.js';\nimport * as base2 from './bases/base2.js';\nimport * as base8 from './bases/base8.js';\nimport * as base10 from './bases/base10.js';\nimport * as base16 from './bases/base16.js';\nimport * as base32 from './bases/base32.js';\nimport * as base36 from './bases/base36.js';\nimport * as base58 from './bases/base58.js';\nimport * as base64 from './bases/base64.js';\nimport * as base256emoji from './bases/base256emoji.js';\nimport * as sha2 from './hashes/sha2.js';\nimport * as identity from './hashes/identity.js';\nimport * as raw from './codecs/raw.js';\nimport * as json from './codecs/json.js';\nimport {\n  CID,\n  hasher,\n  digest,\n  varint,\n  bytes\n} from './index.js';\nconst bases = {\n  ...identityBase,\n  ...base2,\n  ...base8,\n  ...base10,\n  ...base16,\n  ...base32,\n  ...base36,\n  ...base58,\n  ...base64,\n  ...base256emoji\n};\nconst hashes = {\n  ...sha2,\n  ...identity\n};\nconst codecs = {\n  raw,\n  json\n};\nexport {\n  CID,\n  hasher,\n  digest,\n  varint,\n  bytes,\n  hashes,\n  bases,\n  codecs\n};","export function alloc(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {\n    return globalThis.Buffer.alloc(size);\n  }\n  return new Uint8Array(size);\n}\nexport function allocUnsafe(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {\n    return globalThis.Buffer.allocUnsafe(size);\n  }\n  return new Uint8Array(size);\n}","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: { decode }\n  };\n}\nconst string = createCodec('utf8', 'u', buf => {\n  const decoder = new TextDecoder('utf8');\n  return 'u' + decoder.decode(buf);\n}, str => {\n  const encoder = new TextEncoder();\n  return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', buf => {\n  let string = 'a';\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i]);\n  }\n  return string;\n}, str => {\n  str = str.substring(1);\n  const buf = allocUnsafe(str.length);\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n});\nconst BASES = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii: ascii,\n  binary: ascii,\n  ...bases\n};\nexport default BASES;","import bases from './util/bases.js';\nexport function fromString(string, encoding = 'utf8') {\n  const base = bases[encoding];\n  if (!base) {\n    throw new Error(`Unsupported encoding \"${ encoding }\"`);\n  }\n  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n    return globalThis.Buffer.from(string, 'utf8');\n  }\n  return base.decoder.decode(`${ base.prefix }${ string }`);\n}","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { ICore, IKeyChain } from \"@walletconnect/types\";\nimport { getInternalError, mapToObj, objToMap } from \"@walletconnect/utils\";\n\nimport { CORE_STORAGE_PREFIX, KEYCHAIN_CONTEXT, KEYCHAIN_STORAGE_VERSION } from \"../constants\";\n\nexport class KeyChain implements IKeyChain {\n  public keychain = new Map<string, string>();\n  public name = KEYCHAIN_CONTEXT;\n  public version = KEYCHAIN_STORAGE_VERSION;\n\n  private initialized = false;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    this.core = core;\n    this.logger = generateChildLogger(logger, this.name);\n  }\n\n  public init: IKeyChain[\"init\"] = async () => {\n    if (!this.initialized) {\n      const keychain = await this.getKeyChain();\n      if (typeof keychain !== \"undefined\") {\n        this.keychain = keychain;\n      }\n      this.initialized = true;\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n\n  public has: IKeyChain[\"has\"] = (tag) => {\n    this.isInitialized();\n    return this.keychain.has(tag);\n  };\n\n  public set: IKeyChain[\"set\"] = async (tag, key) => {\n    this.isInitialized();\n    this.keychain.set(tag, key);\n    await this.persist();\n  };\n\n  public get: IKeyChain[\"get\"] = (tag) => {\n    this.isInitialized();\n    const key = this.keychain.get(tag);\n    if (typeof key === \"undefined\") {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${tag}`);\n      throw new Error(message);\n    }\n    return key;\n  };\n\n  public del: IKeyChain[\"del\"] = async (tag) => {\n    this.isInitialized();\n    this.keychain.delete(tag);\n    await this.persist();\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setKeyChain(keychain: Map<string, string>) {\n    await this.core.storage.setItem<Record<string, string>>(this.storageKey, mapToObj(keychain));\n  }\n\n  private async getKeyChain() {\n    const keychain = await this.core.storage.getItem<Record<string, string>>(this.storageKey);\n    return typeof keychain !== \"undefined\" ? objToMap(keychain) : undefined;\n  }\n\n  private async persist() {\n    await this.setKeyChain(this.keychain);\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { ICore, ICrypto, IKeyChain } from \"@walletconnect/types\";\nimport * as relayAuth from \"@walletconnect/relay-auth\";\nimport { fromString } from \"uint8arrays/from-string\";\nimport {\n  decrypt,\n  deriveSymKey,\n  encrypt,\n  generateKeyPair as generateKeyPairUtil,\n  hashKey,\n  getInternalError,\n  generateRandomBytes32,\n  validateEncoding,\n  validateDecoding,\n  isTypeOneEnvelope,\n  isTypeTwoEnvelope,\n  encodeTypeTwoEnvelope,\n  decodeTypeTwoEnvelope,\n  deserialize,\n  decodeTypeByte,\n  BASE16,\n  BASE64,\n} from \"@walletconnect/utils\";\nimport { toString } from \"uint8arrays\";\n\nimport { CRYPTO_CONTEXT, CRYPTO_CLIENT_SEED, CRYPTO_JWT_TTL } from \"../constants\";\nimport { KeyChain } from \"./keychain\";\n\nexport class Crypto implements ICrypto {\n  public name = CRYPTO_CONTEXT;\n  public keychain: ICrypto[\"keychain\"];\n  public readonly randomSessionIdentifier = generateRandomBytes32();\n\n  private initialized = false;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    keychain?: IKeyChain,\n  ) {\n    this.core = core;\n    this.logger = generateChildLogger(logger, this.name);\n    this.keychain = keychain || new KeyChain(this.core, this.logger);\n  }\n\n  public init: ICrypto[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.keychain.init();\n      this.initialized = true;\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  public hasKeys: ICrypto[\"hasKeys\"] = (tag) => {\n    this.isInitialized();\n    return this.keychain.has(tag);\n  };\n\n  public getClientId: ICrypto[\"getClientId\"] = async () => {\n    this.isInitialized();\n    const seed = await this.getClientSeed();\n    const keyPair = relayAuth.generateKeyPair(seed);\n    const clientId = relayAuth.encodeIss(keyPair.publicKey);\n    return clientId;\n  };\n\n  public generateKeyPair: ICrypto[\"generateKeyPair\"] = () => {\n    this.isInitialized();\n    const keyPair = generateKeyPairUtil();\n    return this.setPrivateKey(keyPair.publicKey, keyPair.privateKey);\n  };\n\n  public signJWT: ICrypto[\"signJWT\"] = async (aud) => {\n    this.isInitialized();\n    const seed = await this.getClientSeed();\n    const keyPair = relayAuth.generateKeyPair(seed);\n    const sub = this.randomSessionIdentifier;\n    const ttl = CRYPTO_JWT_TTL;\n    const jwt = await relayAuth.signJWT(sub, aud, ttl, keyPair);\n    return jwt;\n  };\n\n  public generateSharedKey: ICrypto[\"generateSharedKey\"] = (\n    selfPublicKey,\n    peerPublicKey,\n    overrideTopic,\n  ) => {\n    this.isInitialized();\n    const selfPrivateKey = this.getPrivateKey(selfPublicKey);\n    const symKey = deriveSymKey(selfPrivateKey, peerPublicKey);\n    return this.setSymKey(symKey, overrideTopic);\n  };\n\n  public setSymKey: ICrypto[\"setSymKey\"] = async (symKey, overrideTopic) => {\n    this.isInitialized();\n    const topic = overrideTopic || hashKey(symKey);\n    await this.keychain.set(topic, symKey);\n    return topic;\n  };\n\n  public deleteKeyPair: ICrypto[\"deleteKeyPair\"] = async (publicKey: string) => {\n    this.isInitialized();\n    await this.keychain.del(publicKey);\n  };\n\n  public deleteSymKey: ICrypto[\"deleteSymKey\"] = async (topic: string) => {\n    this.isInitialized();\n    await this.keychain.del(topic);\n  };\n\n  public encode: ICrypto[\"encode\"] = async (topic, payload, opts) => {\n    this.isInitialized();\n    const params = validateEncoding(opts);\n    const message = safeJsonStringify(payload);\n\n    if (isTypeTwoEnvelope(params)) {\n      return encodeTypeTwoEnvelope(message, opts?.encoding);\n    }\n\n    if (isTypeOneEnvelope(params)) {\n      const selfPublicKey = params.senderPublicKey;\n      const peerPublicKey = params.receiverPublicKey;\n      topic = await this.generateSharedKey(selfPublicKey, peerPublicKey);\n    }\n    const symKey = this.getSymKey(topic);\n    const { type, senderPublicKey } = params;\n    const result = encrypt({ type, symKey, message, senderPublicKey, encoding: opts?.encoding });\n    return result;\n  };\n\n  public decode: ICrypto[\"decode\"] = async (topic, encoded, opts) => {\n    this.isInitialized();\n    const params = validateDecoding(encoded, opts);\n    if (isTypeTwoEnvelope(params)) {\n      const message = decodeTypeTwoEnvelope(encoded, opts?.encoding);\n      return safeJsonParse(message);\n    }\n    if (isTypeOneEnvelope(params)) {\n      const selfPublicKey = params.receiverPublicKey;\n      const peerPublicKey = params.senderPublicKey;\n      topic = await this.generateSharedKey(selfPublicKey, peerPublicKey);\n    }\n    try {\n      const symKey = this.getSymKey(topic);\n      const message = decrypt({ symKey, encoded, encoding: opts?.encoding });\n      const payload = safeJsonParse(message);\n      return payload;\n    } catch (error) {\n      this.logger.error(\n        `Failed to decode message from topic: '${topic}', clientId: '${await this.getClientId()}'`,\n      );\n      this.logger.error(error);\n    }\n  };\n\n  public getPayloadType: ICrypto[\"getPayloadType\"] = (encoded, encoding = BASE64) => {\n    const deserialized = deserialize({ encoded, encoding });\n    return decodeTypeByte(deserialized.type);\n  };\n\n  public getPayloadSenderPublicKey: ICrypto[\"getPayloadSenderPublicKey\"] = (\n    encoded,\n    encoding = BASE64,\n  ) => {\n    const deserialized = deserialize({ encoded, encoding });\n    return deserialized.senderPublicKey\n      ? toString(deserialized.senderPublicKey, BASE16)\n      : undefined;\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setPrivateKey(publicKey: string, privateKey: string): Promise<string> {\n    await this.keychain.set(publicKey, privateKey);\n    return publicKey;\n  }\n\n  private getPrivateKey(publicKey: string) {\n    const privateKey = this.keychain.get(publicKey);\n    return privateKey;\n  }\n\n  private async getClientSeed(): Promise<Uint8Array> {\n    let seed = \"\";\n    try {\n      seed = this.keychain.get(CRYPTO_CLIENT_SEED);\n    } catch {\n      seed = generateRandomBytes32();\n      await this.keychain.set(CRYPTO_CLIENT_SEED, seed);\n    }\n    return fromString(seed, \"base16\");\n  }\n\n  private getSymKey(topic: string) {\n    const symKey = this.keychain.get(topic);\n    return symKey;\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { ICore, IMessageTracker, MessageRecord } from \"@walletconnect/types\";\nimport { hashMessage, mapToObj, objToMap, getInternalError } from \"@walletconnect/utils\";\nimport {\n  CORE_STORAGE_PREFIX,\n  MESSAGE_DIRECTION,\n  MESSAGES_CONTEXT,\n  MESSAGES_STORAGE_VERSION,\n} from \"../constants\";\n\nexport class MessageTracker extends IMessageTracker {\n  public messages = new Map<string, MessageRecord>();\n  /**\n   * stores messages that have not been acknowledged by the implementing client\n   * this is used to prevent losing messages in race conditions such as\n   * when a message is received by the relayer before the implementing client is ready to receive it\n   */\n  public messagesWithoutClientAck = new Map<string, MessageRecord>();\n  public name = MESSAGES_CONTEXT;\n  public version = MESSAGES_STORAGE_VERSION;\n\n  private initialized = false;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  constructor(\n    public logger: Logger,\n    public core: ICore,\n  ) {\n    super(logger, core);\n    this.logger = generateChildLogger(logger, this.name);\n    this.core = core;\n  }\n\n  public init: IMessageTracker[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n      try {\n        const messages = await this.getRelayerMessages();\n        if (typeof messages !== \"undefined\") {\n          this.messages = messages;\n        }\n        const messagesWithoutClientAck = await this.getRelayerMessagesWithoutClientAck();\n        if (typeof messagesWithoutClientAck !== \"undefined\") {\n          this.messagesWithoutClientAck = messagesWithoutClientAck;\n        }\n        this.logger.debug(`Successfully Restored records for ${this.name}`);\n        this.logger.trace({ type: \"method\", method: \"restore\", size: this.messages.size });\n      } catch (e) {\n        this.logger.debug(`Failed to Restore records for ${this.name}`);\n        this.logger.error(e as any);\n      } finally {\n        this.initialized = true;\n      }\n    }\n  };\n\n  get context(): string {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n\n  get storageKeyWithoutClientAck() {\n    return (\n      this.storagePrefix +\n      this.version +\n      this.core.customStoragePrefix +\n      \"//\" +\n      this.name +\n      \"_withoutClientAck\"\n    );\n  }\n\n  public set: IMessageTracker[\"set\"] = async (topic, message, direction) => {\n    this.isInitialized();\n    const hash = hashMessage(message);\n    let messages = this.messages.get(topic);\n    if (typeof messages === \"undefined\") {\n      messages = {};\n    }\n    if (typeof messages[hash] !== \"undefined\") {\n      return hash;\n    }\n    messages[hash] = message;\n    this.messages.set(topic, messages);\n    // Only store messages without client ack for inbound messages\n    if (direction === MESSAGE_DIRECTION.inbound) {\n      const messagesWithoutClientAck = this.messagesWithoutClientAck.get(topic) || {};\n      this.messagesWithoutClientAck.set(topic, {\n        ...messagesWithoutClientAck,\n        [hash]: message,\n      });\n    }\n\n    await this.persist();\n    return hash;\n  };\n\n  public get: IMessageTracker[\"get\"] = (topic) => {\n    this.isInitialized();\n    let messages = this.messages.get(topic);\n    if (typeof messages === \"undefined\") {\n      messages = {};\n    }\n    return messages;\n  };\n\n  public getWithoutAck: IMessageTracker[\"getWithoutAck\"] = (topics) => {\n    this.isInitialized();\n    const messages: Record<string, string[]> = {};\n    for (const topic of topics) {\n      const messagesWithoutClientAck = this.messagesWithoutClientAck.get(topic) || {};\n      messages[topic] = Object.values(messagesWithoutClientAck);\n    }\n    return messages;\n  };\n\n  public has: IMessageTracker[\"has\"] = (topic, message) => {\n    this.isInitialized();\n    const messages = this.get(topic);\n    const hash = hashMessage(message);\n    return typeof messages[hash] !== \"undefined\";\n  };\n\n  public ack: IMessageTracker[\"ack\"] = async (topic, message) => {\n    this.isInitialized();\n    const messages = this.messagesWithoutClientAck.get(topic);\n    if (typeof messages === \"undefined\") {\n      return;\n    }\n\n    const hash = hashMessage(message);\n\n    delete messages[hash];\n    if (Object.keys(messages).length === 0) {\n      this.messagesWithoutClientAck.delete(topic);\n    } else {\n      this.messagesWithoutClientAck.set(topic, messages);\n    }\n    await this.persist();\n  };\n\n  public del: IMessageTracker[\"del\"] = async (topic) => {\n    this.isInitialized();\n    this.messages.delete(topic);\n    this.messagesWithoutClientAck.delete(topic);\n    await this.persist();\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setRelayerMessages(messages: Map<string, MessageRecord>): Promise<void> {\n    await this.core.storage.setItem<Record<string, MessageRecord>>(\n      this.storageKey,\n      mapToObj(messages),\n    );\n  }\n\n  private async setRelayerMessagesWithoutClientAck(\n    messages: Map<string, MessageRecord>,\n  ): Promise<void> {\n    await this.core.storage.setItem<Record<string, MessageRecord>>(\n      this.storageKeyWithoutClientAck,\n      mapToObj(messages),\n    );\n  }\n\n  private async getRelayerMessages(): Promise<Map<string, MessageRecord> | undefined> {\n    const messages = await this.core.storage.getItem<Record<string, MessageRecord>>(\n      this.storageKey,\n    );\n    return typeof messages !== \"undefined\" ? objToMap(messages) : undefined;\n  }\n\n  private async getRelayerMessagesWithoutClientAck(): Promise<\n    Map<string, MessageRecord> | undefined\n  > {\n    const messages = await this.core.storage.getItem<Record<string, MessageRecord>>(\n      this.storageKeyWithoutClientAck,\n    );\n    return typeof messages !== \"undefined\" ? objToMap(messages) : undefined;\n  }\n\n  private async persist() {\n    await this.setRelayerMessages(this.messages);\n    await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport { JsonRpcPayload, RequestArguments } from \"@walletconnect/jsonrpc-types\";\nimport { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { RelayJsonRpc } from \"@walletconnect/relay-api\";\nimport { IPublisher, IRelayer, PublisherTypes, RelayerTypes } from \"@walletconnect/types\";\nimport {\n  getRelayProtocolApi,\n  getRelayProtocolName,\n  isUndefined,\n  createExpiringPromise,\n} from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\n\nimport { PUBLISHER_CONTEXT, PUBLISHER_DEFAULT_TTL, RELAYER_EVENTS } from \"../constants\";\nimport { getBigIntRpcId } from \"@walletconnect/jsonrpc-utils\";\nimport { ONE_MINUTE, ONE_SECOND, toMiliseconds } from \"@walletconnect/time\";\n\ntype IPublishType = PublisherTypes.Params & {\n  attestation?: string;\n  attempt: number;\n};\nexport class Publisher extends IPublisher {\n  public events = new EventEmitter();\n  public name = PUBLISHER_CONTEXT;\n  public queue = new Map<string, IPublishType>();\n\n  private publishTimeout = toMiliseconds(ONE_MINUTE);\n  private initialPublishTimeout = toMiliseconds(ONE_SECOND * 15);\n  private needsTransportRestart = false;\n\n  constructor(\n    public relayer: IRelayer,\n    public logger: Logger,\n  ) {\n    super(relayer, logger);\n    this.relayer = relayer;\n    this.logger = generateChildLogger(logger, this.name);\n    this.registerEventListeners();\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  public publish: IPublisher[\"publish\"] = async (topic, message, opts) => {\n    this.logger.debug(`Publishing Payload`);\n    this.logger.trace({ type: \"method\", method: \"publish\", params: { topic, message, opts } });\n\n    const ttl = opts?.ttl || PUBLISHER_DEFAULT_TTL;\n    const relay = getRelayProtocolName(opts);\n    const prompt = opts?.prompt || false;\n    const tag = opts?.tag || 0;\n    const id = opts?.id || (getBigIntRpcId().toString() as any);\n    const params = {\n      topic,\n      message,\n      opts: {\n        ttl,\n        relay,\n        prompt,\n        tag,\n        id,\n        attestation: opts?.attestation,\n        tvf: opts?.tvf,\n      },\n    };\n    const failedPublishMessage = `Failed to publish payload, please try again. id:${id} tag:${tag}`;\n\n    try {\n      /**\n       * attempt to publish the payload for <initialPublishTimeout> seconds,\n       * if the publish fails, add the payload to the queue and it will be retried on every pulse\n       * until it is successfully published or <publishTimeout> seconds have passed\n       */\n      const publishPromise = new Promise(async (resolve) => {\n        const onPublish = ({ id }: { id: string }) => {\n          if (params.opts.id === id) {\n            this.removeRequestFromQueue(id);\n            this.relayer.events.removeListener(RELAYER_EVENTS.publish, onPublish);\n            resolve(params);\n          }\n        };\n        this.relayer.events.on(RELAYER_EVENTS.publish, onPublish);\n        const initialPublish = createExpiringPromise(\n          new Promise((resolve, reject) => {\n            this.rpcPublish({\n              topic,\n              message,\n              ttl,\n              prompt,\n              tag,\n              id,\n              attestation: opts?.attestation,\n              tvf: opts?.tvf,\n            })\n              .then(resolve)\n              .catch((e) => {\n                this.logger.warn(e, e?.message);\n                reject(e);\n              });\n          }),\n          this.initialPublishTimeout,\n          `Failed initial publish, retrying.... id:${id} tag:${tag}`,\n        );\n        try {\n          await initialPublish;\n          this.events.removeListener(RELAYER_EVENTS.publish, onPublish);\n        } catch (e) {\n          this.queue.set(id, { ...params, attempt: 1 });\n          this.logger.warn(e, (e as Error)?.message);\n        }\n      });\n      this.logger.trace({\n        type: \"method\",\n        method: \"publish\",\n        params: { id, topic, message, opts },\n      });\n\n      await createExpiringPromise(publishPromise, this.publishTimeout, failedPublishMessage);\n    } catch (e) {\n      this.logger.debug(`Failed to Publish Payload`);\n      this.logger.error(e as any);\n      if (opts?.internal?.throwOnFailedPublish) {\n        throw e;\n      }\n    } finally {\n      this.queue.delete(id);\n    }\n  };\n\n  public on: IPublisher[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n  };\n\n  public once: IPublisher[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n  };\n\n  public off: IPublisher[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n  };\n\n  public removeListener: IPublisher[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async rpcPublish(params: {\n    topic: string;\n    message: string;\n    ttl?: number;\n    prompt?: boolean;\n    tag?: number;\n    id?: number;\n    attestation?: string;\n    tvf?: RelayerTypes.ITVF;\n  }) {\n    const {\n      topic,\n      message,\n      ttl = PUBLISHER_DEFAULT_TTL,\n      prompt,\n      tag,\n      id,\n      attestation,\n      tvf,\n    } = params;\n    const api = getRelayProtocolApi(getRelayProtocolName().protocol);\n    const request: RequestArguments<RelayJsonRpc.PublishParams> = {\n      method: api.publish,\n      params: {\n        topic,\n        message,\n        ttl,\n        prompt,\n        tag,\n        attestation,\n        ...tvf,\n      },\n      id,\n    };\n    if (isUndefined(request.params?.prompt)) delete request.params?.prompt;\n    if (isUndefined(request.params?.tag)) delete request.params?.tag;\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"message\", direction: \"outgoing\", request });\n    const result = await this.relayer.request(request);\n    this.relayer.events.emit(RELAYER_EVENTS.publish, params);\n    this.logger.debug(`Successfully Published Payload`);\n    return result;\n  }\n\n  private removeRequestFromQueue(id: string) {\n    this.queue.delete(id);\n  }\n\n  private checkQueue() {\n    this.queue.forEach(async (params, id) => {\n      const attempt = params.attempt + 1;\n      this.queue.set(id, { ...params, attempt });\n      const { topic, message, opts, attestation } = params;\n      this.logger.warn(\n        {},\n        `Publisher: queue->publishing: ${params.opts.id}, tag: ${params.opts.tag}, attempt: ${attempt}`,\n      );\n      await this.rpcPublish({\n        ...params,\n        topic,\n        message,\n        ttl: opts.ttl,\n        prompt: opts.prompt,\n        tag: opts.tag,\n        id: opts.id,\n        attestation,\n        tvf: opts.tvf,\n      });\n      this.logger.warn({}, `Publisher: queue->published: ${params.opts.id}`);\n    });\n  }\n\n  private registerEventListeners() {\n    this.relayer.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {\n      // restart the transport if needed\n      // queue will be processed on the next pulse\n      if (this.needsTransportRestart) {\n        this.needsTransportRestart = false;\n        this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);\n        return;\n      }\n      this.checkQueue();\n    });\n    this.relayer.on(RELAYER_EVENTS.message_ack, (event: JsonRpcPayload) => {\n      this.removeRequestFromQueue(event.id.toString());\n    });\n  }\n}\n","import { ISubscriberTopicMap } from \"@walletconnect/types\";\n\nexport class SubscriberTopicMap implements ISubscriberTopicMap {\n  public map = new Map<string, string[]>();\n\n  get topics(): string[] {\n    return Array.from(this.map.keys());\n  }\n\n  public set: ISubscriberTopicMap[\"set\"] = (topic, id) => {\n    const ids = this.get(topic);\n    if (this.exists(topic, id)) return;\n    this.map.set(topic, [...ids, id]);\n  };\n\n  public get: ISubscriberTopicMap[\"get\"] = (topic) => {\n    const ids = this.map.get(topic);\n    return ids || [];\n  };\n\n  public exists: ISubscriberTopicMap[\"exists\"] = (topic, id) => {\n    const ids = this.get(topic);\n    return ids.includes(id);\n  };\n\n  public delete: ISubscriberTopicMap[\"delete\"] = (topic, id) => {\n    if (typeof id === \"undefined\") {\n      this.map.delete(topic);\n      return;\n    }\n    if (!this.map.has(topic)) return;\n    const ids = this.get(topic);\n    if (!this.exists(topic, id)) return;\n    const remaining = ids.filter((x) => x !== id);\n    if (!remaining.length) {\n      this.map.delete(topic);\n      return;\n    }\n    this.map.set(topic, remaining);\n  };\n\n  public clear: ISubscriberTopicMap[\"clear\"] = () => {\n    this.map.clear();\n  };\n}\n","import { EventEmitter } from \"events\";\nimport { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport { ErrorResponse, RequestArguments } from \"@walletconnect/jsonrpc-types\";\nimport { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { RelayJsonRpc } from \"@walletconnect/relay-api\";\nimport { ONE_SECOND, ONE_MINUTE, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  IRelayer,\n  ISubscriber,\n  RelayerTypes,\n  SubscriberEvents,\n  SubscriberTypes,\n} from \"@walletconnect/types\";\nimport {\n  getSdkError,\n  getInternalError,\n  getRelayProtocolApi,\n  getRelayProtocolName,\n  createExpiringPromise,\n  hashMessage,\n  sleep,\n} from \"@walletconnect/utils\";\nimport {\n  CORE_STORAGE_PREFIX,\n  SUBSCRIBER_CONTEXT,\n  SUBSCRIBER_EVENTS,\n  SUBSCRIBER_STORAGE_VERSION,\n  RELAYER_EVENTS,\n  TRANSPORT_TYPES,\n} from \"../constants\";\nimport { SubscriberTopicMap } from \"./topicmap\";\n\nexport class Subscriber extends ISubscriber {\n  public subscriptions = new Map<string, SubscriberTypes.Active>();\n  public topicMap = new SubscriberTopicMap();\n  public events = new EventEmitter();\n  public name = SUBSCRIBER_CONTEXT;\n  public version = SUBSCRIBER_STORAGE_VERSION;\n  public pending = new Map<string, SubscriberTypes.Params>();\n\n  private cached: SubscriberTypes.Active[] = [];\n  private initialized = false;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n  private subscribeTimeout = toMiliseconds(ONE_MINUTE);\n  private initialSubscribeTimeout = toMiliseconds(ONE_SECOND * 15);\n  private clientId: string;\n  private batchSubscribeTopicsLimit = 500;\n\n  constructor(\n    public relayer: IRelayer,\n    public logger: Logger,\n  ) {\n    super(relayer, logger);\n    this.relayer = relayer;\n    this.logger = generateChildLogger(logger, this.name);\n    this.clientId = \"\"; // assigned when calling this.getClientId()\n  }\n\n  public init: ISubscriber[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n      this.registerEventListeners();\n      await this.restore();\n    }\n    this.initialized = true;\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey() {\n    return (\n      this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + \"//\" + this.name\n    );\n  }\n\n  get length() {\n    return this.subscriptions.size;\n  }\n\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n\n  get topics() {\n    return this.topicMap.topics;\n  }\n\n  get hasAnyTopics() {\n    return (\n      this.topicMap.topics.length > 0 ||\n      this.pending.size > 0 ||\n      this.cached.length > 0 ||\n      this.subscriptions.size > 0\n    );\n  }\n\n  public subscribe: ISubscriber[\"subscribe\"] = async (topic, opts) => {\n    this.isInitialized();\n    this.logger.debug(`Subscribing Topic`);\n    this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic, opts } });\n    try {\n      const relay = getRelayProtocolName(opts);\n      const params = { topic, relay, transportType: opts?.transportType };\n      this.pending.set(topic, params);\n      const id = await this.rpcSubscribe(topic, relay, opts);\n      if (typeof id === \"string\") {\n        this.onSubscribe(id, params);\n        this.logger.debug(`Successfully Subscribed Topic`);\n        this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic, opts } });\n      }\n      return id;\n    } catch (e) {\n      this.logger.debug(`Failed to Subscribe Topic`);\n      this.logger.error(e as any);\n      throw e;\n    }\n  };\n\n  public unsubscribe: ISubscriber[\"unsubscribe\"] = async (topic, opts) => {\n    this.isInitialized();\n    if (typeof opts?.id !== \"undefined\") {\n      await this.unsubscribeById(topic, opts.id, opts);\n    } else {\n      await this.unsubscribeByTopic(topic, opts);\n    }\n  };\n\n  /**\n   * returns `true` only if the topic is actively subscribed to i.e. not pending or cached\n   */\n  public isSubscribed: ISubscriber[\"isSubscribed\"] = (topic: string) => {\n    return new Promise((resolve) => {\n      resolve(this.topicMap.topics.includes(topic));\n    });\n  };\n\n  /**\n   * returns `true` if the topic is known to the subscriber i.e. it is actively subscribed, pending, cached or in the topic map\n   */\n  public isKnownTopic: ISubscriber[\"isKnownTopic\"] = (topic: string) => {\n    return new Promise((resolve) => {\n      resolve(\n        this.topicMap.topics.includes(topic) ||\n          this.pending.has(topic) ||\n          this.cached.some((s) => s.topic === topic),\n      );\n    });\n  };\n\n  public on: ISubscriber[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n  };\n\n  public once: ISubscriber[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n  };\n\n  public off: ISubscriber[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n  };\n\n  public removeListener: ISubscriber[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n  };\n\n  public start: ISubscriber[\"start\"] = async () => {\n    await this.onConnect();\n  };\n\n  public stop: ISubscriber[\"stop\"] = async () => {\n    await this.onDisconnect();\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private hasSubscription(id: string, topic: string) {\n    let result = false;\n    try {\n      const subscription = this.getSubscription(id);\n      result = subscription.topic === topic;\n    } catch (e) {\n      // ignore error\n    }\n    return result;\n  }\n\n  private reset() {\n    this.cached = [];\n    this.initialized = true;\n  }\n\n  private onDisable() {\n    // only write to this.cached if there are active subscriptions\n    // as this.cached can be overridden if onDisable is called multiple times\n    if (this.values.length > 0) {\n      this.cached = this.values;\n    }\n    this.subscriptions.clear();\n    this.topicMap.clear();\n  }\n\n  private async unsubscribeByTopic(topic: string, opts?: RelayerTypes.UnsubscribeOptions) {\n    const ids = this.topicMap.get(topic);\n    await Promise.all(ids.map(async (id) => await this.unsubscribeById(topic, id, opts)));\n  }\n\n  private async unsubscribeById(topic: string, id: string, opts?: RelayerTypes.UnsubscribeOptions) {\n    this.logger.debug(`Unsubscribing Topic`);\n    this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic, id, opts } });\n\n    try {\n      const relay = getRelayProtocolName(opts);\n      await this.restartToComplete({ topic, id, relay });\n      await this.rpcUnsubscribe(topic, id, relay);\n      const reason = getSdkError(\"USER_DISCONNECTED\", `${this.name}, ${topic}`);\n      await this.onUnsubscribe(topic, id, reason);\n      this.logger.debug(`Successfully Unsubscribed Topic`);\n      this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic, id, opts } });\n    } catch (e) {\n      this.logger.debug(`Failed to Unsubscribe Topic`);\n      this.logger.error(e as any);\n      throw e;\n    }\n  }\n\n  private async rpcSubscribe(\n    topic: string,\n    relay: RelayerTypes.ProtocolOptions,\n    opts?: RelayerTypes.SubscribeOptions,\n  ) {\n    if (!opts || opts?.transportType === TRANSPORT_TYPES.relay) {\n      await this.restartToComplete({ topic, id: topic, relay });\n    }\n    const api = getRelayProtocolApi(relay.protocol);\n    const request: RequestArguments<RelayJsonRpc.SubscribeParams> = {\n      method: api.subscribe,\n      params: {\n        topic,\n      },\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n    const shouldThrow = opts?.internal?.throwOnFailedPublish;\n    try {\n      const subId = await this.getSubscriptionId(topic);\n      // in link mode, allow the app to update its network state (i.e. active airplane mode) with small delay before attempting to subscribe\n      if (opts?.transportType === TRANSPORT_TYPES.link_mode) {\n        setTimeout(() => {\n          if (this.relayer.connected || this.relayer.connecting) {\n            this.relayer.request(request).catch((e) => this.logger.warn(e));\n          }\n        }, toMiliseconds(ONE_SECOND));\n        return subId;\n      }\n      const subscribePromise = new Promise(async (resolve) => {\n        const onSubscribe = (subscription: SubscriberEvents.Created) => {\n          if (subscription.topic === topic) {\n            this.events.removeListener(SUBSCRIBER_EVENTS.created, onSubscribe);\n            resolve(subscription.id);\n          }\n        };\n        this.events.on(SUBSCRIBER_EVENTS.created, onSubscribe);\n        try {\n          const result = await createExpiringPromise(\n            new Promise((resolve, reject) => {\n              this.relayer\n                .request(request)\n                .catch((e) => {\n                  this.logger.warn(e, e?.message);\n                  reject(e);\n                })\n                .then(resolve);\n            }),\n            this.initialSubscribeTimeout,\n            `Subscribing to ${topic} failed, please try again`,\n          );\n          this.events.removeListener(SUBSCRIBER_EVENTS.created, onSubscribe);\n          resolve(result);\n        } catch (err) {}\n      });\n\n      const subscribe = createExpiringPromise(\n        subscribePromise,\n        this.subscribeTimeout,\n        `Subscribing to ${topic} failed, please try again`,\n      );\n\n      const result = await subscribe;\n      if (!result && shouldThrow) {\n        throw new Error(`Subscribing to ${topic} failed, please try again`);\n      }\n      // return null to indicate that the subscription failed\n      return result ? subId : null;\n    } catch (err) {\n      this.logger.debug(`Outgoing Relay Subscribe Payload stalled`);\n      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);\n      if (shouldThrow) {\n        throw err;\n      }\n    }\n    return null;\n  }\n\n  private async rpcBatchSubscribe(subscriptions: SubscriberTypes.Params[]) {\n    if (!subscriptions.length) return;\n    const relay = subscriptions[0].relay;\n    const api = getRelayProtocolApi(relay!.protocol);\n    const request: RequestArguments<RelayJsonRpc.BatchSubscribeParams> = {\n      method: api.batchSubscribe,\n      params: {\n        topics: subscriptions.map((s) => s.topic),\n      },\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n    try {\n      const subscribe = await createExpiringPromise(\n        new Promise((resolve) => {\n          this.relayer\n            .request(request)\n            .catch((e) => this.logger.warn(e))\n            .then(resolve);\n        }),\n        this.subscribeTimeout,\n        \"rpcBatchSubscribe failed, please try again\",\n      );\n      await subscribe;\n    } catch (err) {\n      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);\n    }\n  }\n\n  private async rpcBatchFetchMessages(subscriptions: SubscriberTypes.Params[]) {\n    if (!subscriptions.length) return;\n    const relay = subscriptions[0].relay;\n    const api = getRelayProtocolApi(relay!.protocol);\n    const request: RequestArguments<RelayJsonRpc.BatchFetchMessagesParams> = {\n      method: api.batchFetchMessages,\n      params: {\n        topics: subscriptions.map((s) => s.topic),\n      },\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n    let result;\n    try {\n      const fetchMessagesPromise = await createExpiringPromise(\n        new Promise((resolve, reject) => {\n          this.relayer\n            .request(request)\n            .catch((e) => {\n              this.logger.warn(e);\n              reject(e);\n            })\n            .then(resolve);\n        }),\n        this.subscribeTimeout,\n        \"rpcBatchFetchMessages failed, please try again\",\n      );\n      result = (await fetchMessagesPromise) as {\n        messages: RelayerTypes.MessageEvent[];\n      };\n    } catch (err) {\n      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);\n    }\n    return result;\n  }\n\n  private rpcUnsubscribe(topic: string, id: string, relay: RelayerTypes.ProtocolOptions) {\n    const api = getRelayProtocolApi(relay.protocol);\n    const request: RequestArguments<RelayJsonRpc.UnsubscribeParams> = {\n      method: api.unsubscribe,\n      params: {\n        topic,\n        id,\n      },\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n    return this.relayer.request(request);\n  }\n\n  private onSubscribe(id: string, params: SubscriberTypes.Params) {\n    this.setSubscription(id, { ...params, id });\n    this.pending.delete(params.topic);\n  }\n\n  private onBatchSubscribe(subscriptions: SubscriberTypes.Active[]) {\n    if (!subscriptions.length) return;\n    subscriptions.forEach((subscription) => {\n      this.setSubscription(subscription.id, { ...subscription });\n      this.pending.delete(subscription.topic);\n    });\n  }\n\n  private async onUnsubscribe(topic: string, id: string, reason: ErrorResponse) {\n    this.events.removeAllListeners(id);\n    if (this.hasSubscription(id, topic)) {\n      this.deleteSubscription(id, reason);\n    }\n    await this.relayer.messages.del(topic);\n  }\n\n  private async setRelayerSubscriptions(subscriptions: SubscriberTypes.Active[]) {\n    await this.relayer.core.storage.setItem<SubscriberTypes.Active[]>(\n      this.storageKey,\n      subscriptions,\n    );\n  }\n\n  private async getRelayerSubscriptions() {\n    const subscriptions = await this.relayer.core.storage.getItem<SubscriberTypes.Active[]>(\n      this.storageKey,\n    );\n    return subscriptions;\n  }\n\n  private setSubscription(id: string, subscription: SubscriberTypes.Active) {\n    this.logger.debug(`Setting subscription`);\n    this.logger.trace({ type: \"method\", method: \"setSubscription\", id, subscription });\n    this.addSubscription(id, subscription);\n  }\n\n  private addSubscription(id: string, subscription: SubscriberTypes.Active) {\n    this.subscriptions.set(id, { ...subscription });\n    this.topicMap.set(subscription.topic, id);\n    this.events.emit(SUBSCRIBER_EVENTS.created, subscription);\n  }\n\n  private getSubscription(id: string) {\n    this.logger.debug(`Getting subscription`);\n    this.logger.trace({ type: \"method\", method: \"getSubscription\", id });\n    const subscription = this.subscriptions.get(id);\n    if (!subscription) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${id}`);\n      throw new Error(message);\n    }\n    return subscription;\n  }\n\n  private deleteSubscription(id: string, reason: ErrorResponse) {\n    this.logger.debug(`Deleting subscription`);\n    this.logger.trace({ type: \"method\", method: \"deleteSubscription\", id, reason });\n    const subscription = this.getSubscription(id);\n    this.subscriptions.delete(id);\n    this.topicMap.delete(subscription.topic, id);\n    this.events.emit(SUBSCRIBER_EVENTS.deleted, {\n      ...subscription,\n      reason,\n    } as SubscriberEvents.Deleted);\n  }\n\n  private restart = async () => {\n    await this.restore();\n    await this.onRestart();\n  };\n\n  private async persist() {\n    await this.setRelayerSubscriptions(this.values);\n    this.events.emit(SUBSCRIBER_EVENTS.sync);\n  }\n\n  private async onRestart() {\n    if (this.cached.length) {\n      const subs = [...this.cached];\n      const numOfBatches = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);\n      for (let i = 0; i < numOfBatches; i++) {\n        const batch = subs.splice(0, this.batchSubscribeTopicsLimit);\n        await this.batchSubscribe(batch);\n      }\n    }\n    this.events.emit(SUBSCRIBER_EVENTS.resubscribed);\n  }\n\n  private async restore() {\n    try {\n      const persisted = await this.getRelayerSubscriptions();\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n      if (this.subscriptions.size) {\n        const { message } = getInternalError(\"RESTORE_WILL_OVERRIDE\", this.name);\n        this.logger.error(message);\n        this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`);\n        throw new Error(message);\n      }\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored subscriptions for ${this.name}`);\n      this.logger.trace({ type: \"method\", method: \"restore\", subscriptions: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`);\n      this.logger.error(e as any);\n    }\n  }\n\n  private async batchSubscribe(subscriptions: SubscriberTypes.Params[]) {\n    if (!subscriptions.length) return;\n\n    await this.rpcBatchSubscribe(subscriptions);\n    this.onBatchSubscribe(\n      await Promise.all(\n        subscriptions.map(async (s) => {\n          return { ...s, id: await this.getSubscriptionId(s.topic) };\n        }),\n      ),\n    );\n  }\n\n  // @ts-ignore\n  private async batchFetchMessages(subscriptions: SubscriberTypes.Params[]) {\n    if (!subscriptions.length) return;\n    this.logger.trace(`Fetching batch messages for ${subscriptions.length} subscriptions`);\n    const response = await this.rpcBatchFetchMessages(subscriptions);\n    if (response && response.messages) {\n      await sleep(toMiliseconds(ONE_SECOND));\n      await this.relayer.handleBatchMessageEvents(response.messages);\n    }\n  }\n\n  private async onConnect() {\n    await this.restart();\n    this.reset();\n  }\n\n  private onDisconnect() {\n    this.onDisable();\n  }\n\n  private checkPending = async () => {\n    if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) {\n      return;\n    }\n    const pendingSubscriptions: SubscriberTypes.Params[] = [];\n    this.pending.forEach((params) => {\n      pendingSubscriptions.push(params);\n    });\n\n    await this.batchSubscribe(pendingSubscriptions);\n  };\n\n  private registerEventListeners = () => {\n    this.relayer.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, async () => {\n      await this.checkPending();\n    });\n    this.events.on(SUBSCRIBER_EVENTS.created, async (createdEvent: SubscriberEvents.Created) => {\n      const eventName = SUBSCRIBER_EVENTS.created;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: createdEvent });\n      await this.persist();\n    });\n    this.events.on(SUBSCRIBER_EVENTS.deleted, async (deletedEvent: SubscriberEvents.Deleted) => {\n      const eventName = SUBSCRIBER_EVENTS.deleted;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: deletedEvent });\n      await this.persist();\n    });\n  };\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  private async restartToComplete(subscription: SubscriberTypes.Active) {\n    if (!this.relayer.connected && !this.relayer.connecting) {\n      this.cached.push(subscription);\n      await this.relayer.transportOpen();\n    }\n  }\n\n  private async getClientId() {\n    if (!this.clientId) {\n      this.clientId = await this.relayer.core.crypto.getClientId();\n    }\n    return this.clientId;\n  }\n\n  private async getSubscriptionId(topic: string) {\n    return hashMessage(topic + (await this.getClientId()));\n  }\n}\n","import { EventEmitter } from \"events\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport {\n  formatJsonRpcResult,\n  getBigIntRpcId,\n  IJsonRpcProvider,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  JsonRpcPayload,\n  JsonRpcRequest,\n  RequestArguments,\n} from \"@walletconnect/jsonrpc-utils\";\nimport WsConnection from \"@walletconnect/jsonrpc-ws-connection\";\nimport {\n  generateChildLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n  pino,\n  Logger,\n} from \"@walletconnect/logger\";\nimport { RelayJsonRpc } from \"@walletconnect/relay-api\";\nimport {\n  FIVE_MINUTES,\n  ONE_SECOND,\n  FIVE_SECONDS,\n  THIRTY_SECONDS,\n  toMiliseconds,\n} from \"@walletconnect/time\";\nimport {\n  ICore,\n  IMessageTracker,\n  IPublisher,\n  IRelayer,\n  ISubscriber,\n  RelayerOptions,\n  RelayerTypes,\n  SubscriberTypes,\n} from \"@walletconnect/types\";\nimport {\n  createExpiringPromise,\n  formatRelayRpcUrl,\n  isOnline,\n  subscribeToNetworkChange,\n  getAppId,\n  isAndroid,\n  isIos,\n  getInternalError,\n  isNode,\n  calcExpiry,\n  isAppVisible,\n} from \"@walletconnect/utils\";\n\nimport { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\n\nimport {\n  RELAYER_SDK_VERSION,\n  RELAYER_CONTEXT,\n  RELAYER_DEFAULT_LOGGER,\n  RELAYER_EVENTS,\n  RELAYER_PROVIDER_EVENTS,\n  RELAYER_SUBSCRIBER_SUFFIX,\n  RELAYER_DEFAULT_RELAY_URL,\n  SUBSCRIBER_EVENTS,\n  RELAYER_RECONNECT_TIMEOUT,\n  TRANSPORT_TYPES,\n  MESSAGE_DIRECTION,\n} from \"../constants\";\nimport { MessageTracker } from \"./messages\";\nimport { Publisher } from \"./publisher\";\nimport { Subscriber } from \"./subscriber\";\n\nexport class Relayer extends IRelayer {\n  public protocol = \"wc\";\n  public version = 2;\n\n  public core: ICore;\n  public logger: Logger;\n  public events = new EventEmitter();\n  public provider: IJsonRpcProvider;\n  public messages: IMessageTracker;\n  public subscriber: ISubscriber;\n  public publisher: IPublisher;\n  public name = RELAYER_CONTEXT;\n  public transportExplicitlyClosed = false;\n\n  private initialized = false;\n  private connectionAttemptInProgress = false;\n\n  private relayUrl: string;\n  private projectId: string | undefined;\n  private packageName: string | undefined;\n  private bundleId: string | undefined;\n  private hasExperiencedNetworkDisruption = false;\n  private pingTimeout: NodeJS.Timeout | undefined;\n  /**\n   * the relay pings the client 30 seconds after the last message was received\n   * meaning if we don't receive a message in 30 seconds, the connection can be considered dead\n   */\n  private heartBeatTimeout = toMiliseconds(THIRTY_SECONDS + FIVE_SECONDS);\n  private reconnectTimeout: NodeJS.Timeout | undefined;\n  private connectPromise: Promise<void> | undefined;\n  private reconnectInProgress = false;\n  private requestsInFlight: string[] = [];\n  private connectTimeout = toMiliseconds(ONE_SECOND * 15);\n  constructor(opts: RelayerOptions) {\n    super(opts);\n    this.core = opts.core;\n    this.logger =\n      typeof opts.logger !== \"undefined\" && typeof opts.logger !== \"string\"\n        ? generateChildLogger(opts.logger, this.name)\n        : pino(getDefaultLoggerOptions({ level: opts.logger || RELAYER_DEFAULT_LOGGER }));\n    this.messages = new MessageTracker(this.logger, opts.core);\n    this.subscriber = new Subscriber(this, this.logger);\n    this.publisher = new Publisher(this, this.logger);\n\n    this.relayUrl = opts?.relayUrl || RELAYER_DEFAULT_RELAY_URL;\n    this.projectId = opts.projectId;\n\n    if (isAndroid()) {\n      this.packageName = getAppId();\n    } else if (isIos()) {\n      this.bundleId = getAppId();\n    }\n\n    // re-assigned during init()\n    this.provider = {} as IJsonRpcProvider;\n  }\n\n  public async init() {\n    this.logger.trace(`Initialized`);\n    this.registerEventListeners();\n    await Promise.all([this.messages.init(), this.subscriber.init()]);\n    this.initialized = true;\n    if (this.subscriber.hasAnyTopics) {\n      try {\n        await this.transportOpen();\n      } catch (e) {\n        this.logger.warn(e, (e as Error)?.message);\n      }\n    }\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get connected() {\n    // @ts-expect-error\n    return this.provider?.connection?.socket?.readyState === 1 || false;\n  }\n\n  get connecting() {\n    return (\n      // @ts-expect-error\n      this.provider?.connection?.socket?.readyState === 0 ||\n      this.connectPromise !== undefined ||\n      false\n    );\n  }\n\n  public async publish(topic: string, message: string, opts?: RelayerTypes.PublishOptions) {\n    this.isInitialized();\n    await this.publisher.publish(topic, message, opts);\n    await this.recordMessageEvent(\n      {\n        topic,\n        message,\n        // We don't have `publishedAt` from the relay server on outgoing, so use current time to satisfy type.\n        publishedAt: Date.now(),\n        transportType: TRANSPORT_TYPES.relay,\n      },\n      MESSAGE_DIRECTION.outbound,\n    );\n  }\n\n  public async subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions) {\n    this.isInitialized();\n    if (!opts?.transportType || opts?.transportType === \"relay\") {\n      await this.toEstablishConnection();\n    }\n    // throw unless explicitly set to false\n    const shouldThrowOnFailure =\n      typeof opts?.internal?.throwOnFailedPublish === \"undefined\"\n        ? true\n        : opts?.internal?.throwOnFailedPublish;\n\n    let id = this.subscriber.topicMap.get(topic)?.[0] || \"\";\n    let resolvePromise: () => void;\n    const onSubCreated = (subscription: SubscriberTypes.Active) => {\n      if (subscription.topic === topic) {\n        this.subscriber.off(SUBSCRIBER_EVENTS.created, onSubCreated);\n        resolvePromise();\n      }\n    };\n\n    await Promise.all([\n      new Promise<void>((resolve) => {\n        resolvePromise = resolve;\n        this.subscriber.on(SUBSCRIBER_EVENTS.created, onSubCreated);\n      }),\n      new Promise<void>(async (resolve, reject) => {\n        const result = await this.subscriber\n          .subscribe(topic, {\n            internal: {\n              throwOnFailedPublish: shouldThrowOnFailure,\n            },\n            ...opts,\n          })\n          .catch((error) => {\n            if (shouldThrowOnFailure) {\n              reject(error);\n            }\n          });\n        id = result || id;\n        resolve();\n      }),\n    ]);\n    return id;\n  }\n\n  public request = async (request: RequestArguments<RelayJsonRpc.SubscribeParams>) => {\n    this.logger.debug(`Publishing Request Payload`);\n    const id = request.id || (getBigIntRpcId().toString() as any);\n    await this.toEstablishConnection();\n    try {\n      this.logger.trace(\n        {\n          id,\n          method: request.method,\n          topic: request.params?.topic,\n        },\n        \"relayer.request - publishing...\",\n      );\n      const tag = `${id}:${(request.params as any)?.tag || \"\"}`;\n      this.requestsInFlight.push(tag);\n      const result = await this.provider.request(request);\n      this.requestsInFlight = this.requestsInFlight.filter((i) => i !== tag);\n      return result;\n    } catch (e) {\n      this.logger.debug(`Failed to Publish Request: ${id}`);\n      throw e;\n    }\n  };\n\n  public async unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions) {\n    this.isInitialized();\n    await this.subscriber.unsubscribe(topic, opts);\n  }\n\n  public on(event: string, listener: any) {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any) {\n    this.events.once(event, listener);\n  }\n\n  public off(event: string, listener: any) {\n    this.events.off(event, listener);\n  }\n\n  public removeListener(event: string, listener: any) {\n    this.events.removeListener(event, listener);\n  }\n\n  public async transportDisconnect() {\n    if (this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected)) {\n      await createExpiringPromise(this.provider.disconnect(), 2000, \"provider.disconnect()\").catch(\n        () => this.onProviderDisconnect(),\n      );\n    } else {\n      this.onProviderDisconnect();\n    }\n  }\n\n  public async transportClose() {\n    this.transportExplicitlyClosed = true;\n    await this.transportDisconnect();\n  }\n\n  async transportOpen(relayUrl?: string) {\n    if (!this.subscriber.hasAnyTopics) {\n      this.logger.warn(\n        \"Starting WS connection skipped because the client has no topics to work with.\",\n      );\n      return;\n    }\n\n    if (this.connectPromise) {\n      this.logger.debug({}, `Waiting for existing connection attempt to resolve...`);\n      await this.connectPromise;\n      this.logger.debug({}, `Existing connection attempt resolved`);\n    } else {\n      this.connectPromise = new Promise(async (resolve, reject) => {\n        await this.connect(relayUrl)\n          .then(resolve)\n          .catch(reject)\n          .finally(() => {\n            this.connectPromise = undefined;\n          });\n      });\n      await this.connectPromise;\n    }\n    if (!this.connected) {\n      throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);\n    }\n  }\n\n  public async restartTransport(relayUrl?: string) {\n    this.logger.debug({}, \"Restarting transport...\");\n    if (this.connectionAttemptInProgress) return;\n    this.relayUrl = relayUrl || this.relayUrl;\n    await this.confirmOnlineStateOrThrow();\n    await this.transportClose();\n    await this.transportOpen();\n  }\n\n  public async confirmOnlineStateOrThrow() {\n    if (await isOnline()) return;\n    throw new Error(\"No internet connection detected. Please restart your network and try again.\");\n  }\n\n  public async handleBatchMessageEvents(messages: RelayerTypes.MessageEvent[]) {\n    if (messages?.length === 0) {\n      this.logger.trace(\"Batch message events is empty. Ignoring...\");\n      return;\n    }\n    const sortedMessages = messages.sort((a, b) => a.publishedAt - b.publishedAt);\n    this.logger.debug(`Batch of ${sortedMessages.length} message events sorted`);\n    for (const message of sortedMessages) {\n      try {\n        await this.onMessageEvent(message);\n      } catch (e) {\n        this.logger.warn(e, \"Error while processing batch message event: \" + (e as Error)?.message);\n      }\n    }\n    this.logger.trace(`Batch of ${sortedMessages.length} message events processed`);\n  }\n\n  public async onLinkMessageEvent(\n    messageEvent: RelayerTypes.MessageEvent,\n    opts: { sessionExists: boolean },\n  ) {\n    const { topic } = messageEvent;\n\n    if (!opts.sessionExists) {\n      const expiry = calcExpiry(FIVE_MINUTES);\n      const pairing = { topic, expiry, relay: { protocol: \"irn\" }, active: false };\n      await this.core.pairing.pairings.set(topic, pairing);\n    }\n\n    this.events.emit(RELAYER_EVENTS.message, messageEvent);\n    await this.recordMessageEvent(messageEvent, MESSAGE_DIRECTION.inbound);\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async connect(relayUrl?: string) {\n    await this.confirmOnlineStateOrThrow();\n    if (relayUrl && relayUrl !== this.relayUrl) {\n      this.relayUrl = relayUrl;\n      await this.transportDisconnect();\n    }\n\n    this.connectionAttemptInProgress = true;\n    this.transportExplicitlyClosed = false;\n    let attempt = 1;\n    while (attempt < 6) {\n      try {\n        if (this.transportExplicitlyClosed) {\n          break;\n        }\n        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${attempt}...`);\n        // Always create new socket instance when trying to connect because if the socket was dropped due to `socket hang up` exception\n        // It wont be able to reconnect\n        await this.createProvider();\n\n        await new Promise<void>(async (resolve, reject) => {\n          const onDisconnect = () => {\n            reject(new Error(`Connection interrupted while trying to subscribe`));\n          };\n          this.provider.once(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);\n\n          await createExpiringPromise(\n            new Promise((resolve, reject) => {\n              this.provider.connect().then(resolve).catch(reject);\n            }),\n            this.connectTimeout,\n            `Socket stalled when trying to connect to ${this.relayUrl}`,\n          )\n            .catch((e) => {\n              reject(e);\n            })\n            .finally(() => {\n              this.provider.off(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);\n              clearTimeout(this.reconnectTimeout);\n            });\n          await new Promise(async (resolve, reject) => {\n            const onDisconnect = () => {\n              reject(new Error(`Connection interrupted while trying to subscribe`));\n            };\n            this.provider.once(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);\n            await this.subscriber\n              .start()\n              .then(resolve)\n              .catch(reject)\n              .finally(() => {\n                this.provider.off(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);\n              });\n          });\n          this.hasExperiencedNetworkDisruption = false;\n          resolve();\n        });\n      } catch (e) {\n        await this.subscriber.stop();\n        const error = e as Error;\n        this.logger.warn({}, error.message);\n        this.hasExperiencedNetworkDisruption = true;\n      } finally {\n        this.connectionAttemptInProgress = false;\n      }\n\n      if (this.connected) {\n        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${attempt}`);\n        break;\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, toMiliseconds(attempt * 1)));\n      attempt++;\n    }\n  }\n\n  /*\n   * In Node, we must detect when the connection is stalled and terminate it.\n   * The logic is, if we don't receive ping from the relay within a certain time, we terminate the connection.\n   * The timer is refreshed on every message received from the relay.\n   *\n   * In the browser, ping/pong events are not exposed, so the above behaviour is handled by `subscribeToNetworkChange` and `isOnline` functions.\n   */\n  private startPingTimeout() {\n    if (!isNode()) return;\n    try {\n      //@ts-expect-error - Types are divergent between the node and browser WS API\n      if (this.provider?.connection?.socket) {\n        //@ts-expect-error\n        this.provider?.connection?.socket?.on(\"ping\", () => {\n          this.resetPingTimeout();\n        });\n      }\n      this.resetPingTimeout();\n    } catch (e) {\n      this.logger.warn(e, (e as Error)?.message);\n    }\n  }\n\n  private resetPingTimeout = () => {\n    if (!isNode()) return;\n    clearTimeout(this.pingTimeout);\n    this.pingTimeout = setTimeout(() => {\n      try {\n        this.logger.debug({}, \"pingTimeout: Connection stalled, terminating...\");\n        //@ts-expect-error\n        this.provider?.connection?.socket?.terminate?.();\n      } catch (e) {\n        this.logger.warn(e, (e as Error)?.message);\n      }\n    }, this.heartBeatTimeout);\n  };\n\n  private async createProvider() {\n    if (this.provider.connection) {\n      this.unregisterProviderListeners();\n    }\n    const auth = await this.core.crypto.signJWT(this.relayUrl);\n\n    this.provider = new JsonRpcProvider(\n      new WsConnection(\n        formatRelayRpcUrl({\n          sdkVersion: RELAYER_SDK_VERSION,\n          protocol: this.protocol,\n          version: this.version,\n          relayUrl: this.relayUrl,\n          projectId: this.projectId,\n          auth,\n          useOnCloseEvent: true,\n          bundleId: this.bundleId,\n          packageName: this.packageName,\n        }),\n      ),\n    );\n    this.registerProviderListeners();\n  }\n\n  private async recordMessageEvent(\n    messageEvent: RelayerTypes.MessageEvent,\n    direction?: RelayerTypes.MessageDirection,\n  ) {\n    const { topic, message } = messageEvent;\n    await this.messages.set(topic, message, direction);\n  }\n\n  private async shouldIgnoreMessageEvent(\n    messageEvent: RelayerTypes.MessageEvent,\n  ): Promise<boolean> {\n    const { topic, message } = messageEvent;\n\n    // Ignore if incoming `message` is clearly invalid.\n    if (!message || message.length === 0) {\n      this.logger.warn(`Ignoring invalid/empty message: ${message}`);\n      return true;\n    }\n\n    // Ignore if `topic` is not known to the subscriber.\n    if (!(await this.subscriber.isKnownTopic(topic))) {\n      this.logger.warn(`Ignoring message for unknown topic ${topic}`);\n      return true;\n    }\n\n    // Ignore if `message` is a duplicate.\n    const exists = this.messages.has(topic, message);\n    if (exists) {\n      this.logger.warn(`Ignoring duplicate message: ${message}`);\n    }\n    return exists;\n  }\n\n  private async onProviderPayload(payload: JsonRpcPayload) {\n    this.logger.debug(`Incoming Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"incoming\", payload });\n    if (isJsonRpcRequest(payload)) {\n      if (!payload.method.endsWith(RELAYER_SUBSCRIBER_SUFFIX)) return;\n      const event = (payload as JsonRpcRequest<RelayJsonRpc.SubscriptionParams>).params;\n      const { topic, message, publishedAt, attestation } = event.data;\n      const messageEvent: RelayerTypes.MessageEvent = {\n        topic,\n        message,\n        publishedAt,\n        transportType: TRANSPORT_TYPES.relay,\n        attestation,\n      };\n      this.logger.debug(`Emitting Relayer Payload`);\n      this.logger.trace({ type: \"event\", event: event.id, ...messageEvent });\n      this.events.emit(event.id, messageEvent);\n      await this.acknowledgePayload(payload);\n      await this.onMessageEvent(messageEvent);\n    } else if (isJsonRpcResponse(payload)) {\n      this.events.emit(RELAYER_EVENTS.message_ack, payload);\n    }\n  }\n\n  private async onMessageEvent(messageEvent: RelayerTypes.MessageEvent) {\n    if (await this.shouldIgnoreMessageEvent(messageEvent)) {\n      return;\n    }\n    await this.recordMessageEvent(messageEvent, MESSAGE_DIRECTION.inbound);\n    this.events.emit(RELAYER_EVENTS.message, messageEvent);\n  }\n\n  private async acknowledgePayload(payload: JsonRpcPayload) {\n    const response = formatJsonRpcResult(payload.id, true);\n    await this.provider.connection.send(response);\n  }\n\n  // ---------- Events Handlers ----------------------------------------------- //\n  private onPayloadHandler = (payload: JsonRpcPayload) => {\n    this.onProviderPayload(payload);\n    this.resetPingTimeout();\n  };\n\n  private onConnectHandler = () => {\n    this.logger.warn({}, \"Relayer connected 🛜\");\n    this.startPingTimeout();\n    this.events.emit(RELAYER_EVENTS.connect);\n  };\n\n  private onDisconnectHandler = () => {\n    this.logger.warn({}, `Relayer disconnected 🛑`);\n    this.requestsInFlight = [];\n    this.onProviderDisconnect();\n  };\n\n  private onProviderErrorHandler = (error: Error) => {\n    this.logger.fatal(`Fatal socket error: ${error.message}`);\n    this.events.emit(RELAYER_EVENTS.error, error);\n    // close the transport when a fatal error is received as there's no way to recover from it\n    // usual cases are missing/invalid projectId, expired jwt token, invalid origin etc\n    this.logger.fatal(\"Fatal socket error received, closing transport\");\n    this.transportClose();\n  };\n\n  private registerProviderListeners = () => {\n    this.provider.on(RELAYER_PROVIDER_EVENTS.payload, this.onPayloadHandler);\n    this.provider.on(RELAYER_PROVIDER_EVENTS.connect, this.onConnectHandler);\n    this.provider.on(RELAYER_PROVIDER_EVENTS.disconnect, this.onDisconnectHandler);\n    this.provider.on(RELAYER_PROVIDER_EVENTS.error, this.onProviderErrorHandler);\n  };\n\n  private unregisterProviderListeners() {\n    this.provider.off(RELAYER_PROVIDER_EVENTS.payload, this.onPayloadHandler);\n    this.provider.off(RELAYER_PROVIDER_EVENTS.connect, this.onConnectHandler);\n    this.provider.off(RELAYER_PROVIDER_EVENTS.disconnect, this.onDisconnectHandler);\n    this.provider.off(RELAYER_PROVIDER_EVENTS.error, this.onProviderErrorHandler);\n    clearTimeout(this.pingTimeout);\n  }\n\n  private async registerEventListeners() {\n    let lastConnectedState = await isOnline();\n    subscribeToNetworkChange(async (connected: boolean) => {\n      // sometimes the network change event is triggered multiple times so avoid reacting to the samFe value\n      if (lastConnectedState === connected) return;\n\n      lastConnectedState = connected;\n      if (!connected) {\n        // when the device network is restarted, the socket might stay in false `connected` state\n        this.hasExperiencedNetworkDisruption = true;\n        await this.transportDisconnect();\n        this.transportExplicitlyClosed = false;\n      } else {\n        await this.transportOpen().catch((error) =>\n          this.logger.error(error, (error as Error)?.message),\n        );\n      }\n    });\n\n    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, async () => {\n      if (this.transportExplicitlyClosed) return;\n      if (!this.connected && isAppVisible()) {\n        try {\n          await this.confirmOnlineStateOrThrow();\n          await this.transportOpen();\n        } catch (error) {\n          this.logger.warn(error, (error as Error)?.message);\n        }\n      }\n    });\n  }\n\n  private async onProviderDisconnect() {\n    clearTimeout(this.pingTimeout);\n    this.events.emit(RELAYER_EVENTS.disconnect);\n    this.connectionAttemptInProgress = false;\n    if (this.reconnectInProgress) return;\n\n    this.reconnectInProgress = true;\n    await this.subscriber.stop();\n\n    if (!this.subscriber.hasAnyTopics) return;\n    if (this.transportExplicitlyClosed) return;\n\n    this.reconnectTimeout = setTimeout(async () => {\n      await this.transportOpen().catch((error) =>\n        this.logger.error(error, (error as Error)?.message),\n      );\n      this.reconnectTimeout = undefined;\n      this.reconnectInProgress = false;\n    }, toMiliseconds(RELAYER_RECONNECT_TIMEOUT));\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  private async toEstablishConnection() {\n    await this.confirmOnlineStateOrThrow();\n    if (this.connected) return;\n    if (this.connectPromise) {\n      await this.connectPromise;\n      return;\n    }\n    await this.connect();\n  }\n}\n","function noop() { }\n\nexport { noop };\n","function isPlainObject(value) {\n    if (!value || typeof value !== 'object') {\n        return false;\n    }\n    const proto = Object.getPrototypeOf(value);\n    const hasObjectPrototype = proto === null ||\n        proto === Object.prototype ||\n        Object.getPrototypeOf(proto) === null;\n    if (!hasObjectPrototype) {\n        return false;\n    }\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nexport { isPlainObject };\n","function getSymbols(object) {\n    return Object.getOwnPropertySymbols(object).filter(symbol => Object.prototype.propertyIsEnumerable.call(object, symbol));\n}\n\nexport { getSymbols };\n","function getTag(value) {\n    if (value == null) {\n        return value === undefined ? '[object Undefined]' : '[object Null]';\n    }\n    return Object.prototype.toString.call(value);\n}\n\nexport { getTag };\n","const regexpTag = '[object RegExp]';\nconst stringTag = '[object String]';\nconst numberTag = '[object Number]';\nconst booleanTag = '[object Boolean]';\nconst argumentsTag = '[object Arguments]';\nconst symbolTag = '[object Symbol]';\nconst dateTag = '[object Date]';\nconst mapTag = '[object Map]';\nconst setTag = '[object Set]';\nconst arrayTag = '[object Array]';\nconst functionTag = '[object Function]';\nconst arrayBufferTag = '[object ArrayBuffer]';\nconst objectTag = '[object Object]';\nconst errorTag = '[object Error]';\nconst dataViewTag = '[object DataView]';\nconst uint8ArrayTag = '[object Uint8Array]';\nconst uint8ClampedArrayTag = '[object Uint8ClampedArray]';\nconst uint16ArrayTag = '[object Uint16Array]';\nconst uint32ArrayTag = '[object Uint32Array]';\nconst bigUint64ArrayTag = '[object BigUint64Array]';\nconst int8ArrayTag = '[object Int8Array]';\nconst int16ArrayTag = '[object Int16Array]';\nconst int32ArrayTag = '[object Int32Array]';\nconst bigInt64ArrayTag = '[object BigInt64Array]';\nconst float32ArrayTag = '[object Float32Array]';\nconst float64ArrayTag = '[object Float64Array]';\n\nexport { argumentsTag, arrayBufferTag, arrayTag, bigInt64ArrayTag, bigUint64ArrayTag, booleanTag, dataViewTag, dateTag, errorTag, float32ArrayTag, float64ArrayTag, functionTag, int16ArrayTag, int32ArrayTag, int8ArrayTag, mapTag, numberTag, objectTag, regexpTag, setTag, stringTag, symbolTag, uint16ArrayTag, uint32ArrayTag, uint8ArrayTag, uint8ClampedArrayTag };\n","function eq(value, other) {\n    return value === other || (Number.isNaN(value) && Number.isNaN(other));\n}\n\nexport { eq };\n","import { isPlainObject } from './isPlainObject.mjs';\nimport { getSymbols } from '../compat/_internal/getSymbols.mjs';\nimport { getTag } from '../compat/_internal/getTag.mjs';\nimport { functionTag, regexpTag, symbolTag, dateTag, booleanTag, numberTag, stringTag, objectTag, errorTag, dataViewTag, arrayBufferTag, float64ArrayTag, float32ArrayTag, bigInt64ArrayTag, int32ArrayTag, int16ArrayTag, int8ArrayTag, bigUint64ArrayTag, uint32ArrayTag, uint16ArrayTag, uint8ClampedArrayTag, uint8ArrayTag, arrayTag, setTag, mapTag, argumentsTag } from '../compat/_internal/tags.mjs';\nimport { eq } from '../compat/util/eq.mjs';\n\nfunction isEqualWith(a, b, areValuesEqual) {\n    return isEqualWithImpl(a, b, undefined, undefined, undefined, undefined, areValuesEqual);\n}\nfunction isEqualWithImpl(a, b, property, aParent, bParent, stack, areValuesEqual) {\n    const result = areValuesEqual(a, b, property, aParent, bParent, stack);\n    if (result !== undefined) {\n        return result;\n    }\n    if (typeof a === typeof b) {\n        switch (typeof a) {\n            case 'bigint':\n            case 'string':\n            case 'boolean':\n            case 'symbol':\n            case 'undefined': {\n                return a === b;\n            }\n            case 'number': {\n                return a === b || Object.is(a, b);\n            }\n            case 'function': {\n                return a === b;\n            }\n            case 'object': {\n                return areObjectsEqual(a, b, stack, areValuesEqual);\n            }\n        }\n    }\n    return areObjectsEqual(a, b, stack, areValuesEqual);\n}\nfunction areObjectsEqual(a, b, stack, areValuesEqual) {\n    if (Object.is(a, b)) {\n        return true;\n    }\n    let aTag = getTag(a);\n    let bTag = getTag(b);\n    if (aTag === argumentsTag) {\n        aTag = objectTag;\n    }\n    if (bTag === argumentsTag) {\n        bTag = objectTag;\n    }\n    if (aTag !== bTag) {\n        return false;\n    }\n    switch (aTag) {\n        case stringTag:\n            return a.toString() === b.toString();\n        case numberTag: {\n            const x = a.valueOf();\n            const y = b.valueOf();\n            return eq(x, y);\n        }\n        case booleanTag:\n        case dateTag:\n        case symbolTag:\n            return Object.is(a.valueOf(), b.valueOf());\n        case regexpTag: {\n            return a.source === b.source && a.flags === b.flags;\n        }\n        case functionTag: {\n            return a === b;\n        }\n    }\n    stack = stack ?? new Map();\n    const aStack = stack.get(a);\n    const bStack = stack.get(b);\n    if (aStack != null && bStack != null) {\n        return aStack === b;\n    }\n    stack.set(a, b);\n    stack.set(b, a);\n    try {\n        switch (aTag) {\n            case mapTag: {\n                if (a.size !== b.size) {\n                    return false;\n                }\n                for (const [key, value] of a.entries()) {\n                    if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a, b, stack, areValuesEqual)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            case setTag: {\n                if (a.size !== b.size) {\n                    return false;\n                }\n                const aValues = Array.from(a.values());\n                const bValues = Array.from(b.values());\n                for (let i = 0; i < aValues.length; i++) {\n                    const aValue = aValues[i];\n                    const index = bValues.findIndex(bValue => {\n                        return isEqualWithImpl(aValue, bValue, undefined, a, b, stack, areValuesEqual);\n                    });\n                    if (index === -1) {\n                        return false;\n                    }\n                    bValues.splice(index, 1);\n                }\n                return true;\n            }\n            case arrayTag:\n            case uint8ArrayTag:\n            case uint8ClampedArrayTag:\n            case uint16ArrayTag:\n            case uint32ArrayTag:\n            case bigUint64ArrayTag:\n            case int8ArrayTag:\n            case int16ArrayTag:\n            case int32ArrayTag:\n            case bigInt64ArrayTag:\n            case float32ArrayTag:\n            case float64ArrayTag: {\n                if (typeof Buffer !== 'undefined' && Buffer.isBuffer(a) !== Buffer.isBuffer(b)) {\n                    return false;\n                }\n                if (a.length !== b.length) {\n                    return false;\n                }\n                for (let i = 0; i < a.length; i++) {\n                    if (!isEqualWithImpl(a[i], b[i], i, a, b, stack, areValuesEqual)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            case arrayBufferTag: {\n                if (a.byteLength !== b.byteLength) {\n                    return false;\n                }\n                return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack, areValuesEqual);\n            }\n            case dataViewTag: {\n                if (a.byteLength !== b.byteLength || a.byteOffset !== b.byteOffset) {\n                    return false;\n                }\n                return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack, areValuesEqual);\n            }\n            case errorTag: {\n                return a.name === b.name && a.message === b.message;\n            }\n            case objectTag: {\n                const areEqualInstances = areObjectsEqual(a.constructor, b.constructor, stack, areValuesEqual) ||\n                    (isPlainObject(a) && isPlainObject(b));\n                if (!areEqualInstances) {\n                    return false;\n                }\n                const aKeys = [...Object.keys(a), ...getSymbols(a)];\n                const bKeys = [...Object.keys(b), ...getSymbols(b)];\n                if (aKeys.length !== bKeys.length) {\n                    return false;\n                }\n                for (let i = 0; i < aKeys.length; i++) {\n                    const propKey = aKeys[i];\n                    const aProp = a[propKey];\n                    if (!Object.hasOwn(b, propKey)) {\n                        return false;\n                    }\n                    const bProp = b[propKey];\n                    if (!isEqualWithImpl(aProp, bProp, propKey, a, b, stack, areValuesEqual)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            default: {\n                return false;\n            }\n        }\n    }\n    finally {\n        stack.delete(a);\n        stack.delete(b);\n    }\n}\n\nexport { isEqualWith };\n","import { isEqualWith } from './isEqualWith.mjs';\nimport { noop } from '../function/noop.mjs';\n\nfunction isEqual(a, b) {\n    return isEqualWith(a, b, noop);\n}\n\nexport { isEqual };\n","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { ICore, IStore } from \"@walletconnect/types\";\nimport {\n  getInternalError,\n  isProposalStruct,\n  isSessionStruct,\n  isUndefined,\n} from \"@walletconnect/utils\";\nimport { CORE_STORAGE_PREFIX, STORE_STORAGE_VERSION } from \"../constants\";\nimport { isEqual } from \"es-toolkit/compat\";\n\nexport class Store<Key, Data extends Record<string, any>> extends IStore<Key, Data> {\n  public map = new Map<Key, Data>();\n  public version = STORE_STORAGE_VERSION;\n\n  private cached: Data[] = [];\n  private initialized = false;\n\n  /**\n   * Regenerates the value key to retrieve it from cache\n   */\n  private getKey: ((data: Data) => Key) | undefined;\n\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  // stores recently deleted key to return different rejection message when key is not found\n  private recentlyDeleted: Key[] = [];\n  private recentlyDeletedLimit = 200;\n\n  /**\n   * @param {ICore} core Core\n   * @param {Logger} logger Logger\n   * @param {string} name Store's name\n   * @param {Store<Key, Data>[\"getKey\"]} getKey Regenerates the value key to retrieve it from cache\n   * @param {string} storagePrefix Prefixes value keys\n   */\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public name: string,\n    storagePrefix: string = CORE_STORAGE_PREFIX,\n    getKey: Store<Key, Data>[\"getKey\"] = undefined,\n  ) {\n    super(core, logger, name, storagePrefix);\n    this.logger = generateChildLogger(logger, this.name);\n    this.storagePrefix = storagePrefix;\n    this.getKey = getKey;\n  }\n\n  public init: IStore<Key, Data>[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n\n      await this.restore();\n\n      this.cached.forEach((value) => {\n        if (this.getKey && value !== null && !isUndefined(value)) {\n          this.map.set(this.getKey(value), value);\n        } else if (isProposalStruct(value)) {\n          // TODO(pedro) revert type casting as any\n          this.map.set(value.id as any, value);\n        } else if (isSessionStruct(value)) {\n          // TODO(pedro) revert type casting as any\n          this.map.set(value.topic as any, value);\n        }\n      });\n\n      this.cached = [];\n      this.initialized = true;\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n\n  get length() {\n    return this.map.size;\n  }\n\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n\n  get values() {\n    return Array.from(this.map.values());\n  }\n\n  public set: IStore<Key, Data>[\"set\"] = async (key, value) => {\n    this.isInitialized();\n    if (this.map.has(key)) {\n      await this.update(key, value);\n    } else {\n      this.logger.debug(`Setting value`);\n      this.logger.trace({ type: \"method\", method: \"set\", key, value });\n      this.map.set(key, value);\n      await this.persist();\n    }\n  };\n\n  public get: IStore<Key, Data>[\"get\"] = (key) => {\n    this.isInitialized();\n    this.logger.debug(`Getting value`);\n    this.logger.trace({ type: \"method\", method: \"get\", key });\n    const value = this.getData(key);\n    return value;\n  };\n\n  public getAll: IStore<Key, Data>[\"getAll\"] = (filter) => {\n    this.isInitialized();\n    if (!filter) return this.values;\n\n    return this.values.filter((value) =>\n      Object.keys(filter).every((key) => isEqual(value[key], filter[key])),\n    );\n  };\n\n  public update: IStore<Key, Data>[\"update\"] = async (key, update) => {\n    this.isInitialized();\n    this.logger.debug(`Updating value`);\n    this.logger.trace({ type: \"method\", method: \"update\", key, update });\n    const value = { ...this.getData(key), ...update };\n    this.map.set(key, value);\n    await this.persist();\n  };\n\n  public delete: IStore<Key, Data>[\"delete\"] = async (key, reason) => {\n    this.isInitialized();\n    if (!this.map.has(key)) return;\n    this.logger.debug(`Deleting value`);\n    this.logger.trace({ type: \"method\", method: \"delete\", key, reason });\n    this.map.delete(key);\n    this.addToRecentlyDeleted(key);\n    await this.persist();\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private addToRecentlyDeleted(key: Key) {\n    this.recentlyDeleted.push(key);\n    // limit the size of the recentlyDeleted array, truncate the 100 oldest entries.\n    if (this.recentlyDeleted.length >= this.recentlyDeletedLimit) {\n      this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);\n    }\n  }\n\n  private async setDataStore(value: Data[]) {\n    await this.core.storage.setItem<Data[]>(this.storageKey, value);\n  }\n\n  private async getDataStore() {\n    const value = await this.core.storage.getItem<Data[]>(this.storageKey);\n    return value;\n  }\n\n  private getData(key: Key) {\n    const value = this.map.get(key);\n    if (!value) {\n      if (this.recentlyDeleted.includes(key)) {\n        const { message } = getInternalError(\n          \"MISSING_OR_INVALID\",\n          `Record was recently deleted - ${this.name}: ${key}`,\n        );\n        this.logger.error(message);\n        throw new Error(message);\n      }\n\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${key}`);\n      this.logger.error(message);\n      throw new Error(message);\n    }\n    return value;\n  }\n\n  private async persist() {\n    await this.setDataStore(this.values);\n  }\n\n  private async restore() {\n    try {\n      const persisted = await this.getDataStore();\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n      if (this.map.size) {\n        const { message } = getInternalError(\"RESTORE_WILL_OVERRIDE\", this.name);\n        this.logger.error(message);\n        throw new Error(message);\n      }\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored value for ${this.name}`);\n      this.logger.trace({ type: \"method\", method: \"restore\", value: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore value for ${this.name}`);\n      this.logger.error(e as any);\n    }\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport {\n  ICore,\n  PairingTypes,\n  IPairing,\n  IPairingPrivate,\n  IStore,\n  RelayerTypes,\n  PairingJsonRpcTypes,\n  ExpirerTypes,\n  EventClientTypes,\n} from \"@walletconnect/types\";\nimport {\n  getInternalError,\n  parseUri,\n  calcExpiry,\n  generateRandomBytes32,\n  formatUri,\n  getSdkError,\n  engineEvent,\n  createDelayedPromise,\n  isValidParams,\n  isValidUrl,\n  isValidString,\n  isExpired,\n  parseExpirerTarget,\n  TYPE_1,\n} from \"@walletconnect/utils\";\nimport {\n  formatJsonRpcRequest,\n  formatJsonRpcResult,\n  formatJsonRpcError,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  isJsonRpcResult,\n  isJsonRpcError,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { FIVE_MINUTES, toMiliseconds } from \"@walletconnect/time\";\nimport EventEmitter from \"events\";\nimport {\n  PAIRING_CONTEXT,\n  PAIRING_STORAGE_VERSION,\n  CORE_STORAGE_PREFIX,\n  RELAYER_DEFAULT_PROTOCOL,\n  PAIRING_RPC_OPTS,\n  RELAYER_EVENTS,\n  EXPIRER_EVENTS,\n  PAIRING_EVENTS,\n  EVENT_CLIENT_PAIRING_TRACES,\n  EVENT_CLIENT_PAIRING_ERRORS,\n  TRANSPORT_TYPES,\n} from \"../constants\";\nimport { Store } from \"../controllers/store\";\n\nexport class Pairing implements IPairing {\n  public name = PAIRING_CONTEXT;\n  public version = PAIRING_STORAGE_VERSION;\n\n  public events = new EventEmitter();\n  public pairings: IStore<string, PairingTypes.Struct>;\n\n  private initialized = false;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n  private ignoredPayloadTypes = [TYPE_1];\n  private registeredMethods: string[] = [];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    this.core = core;\n    this.logger = generateChildLogger(logger, this.name);\n    this.pairings = new Store(this.core, this.logger, this.name, this.storagePrefix);\n  }\n\n  public init: IPairing[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.pairings.init();\n      await this.cleanup();\n      this.registerRelayerEvents();\n      this.registerExpirerEvents();\n      this.initialized = true;\n      this.logger.trace(`Initialized`);\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  public register: IPairing[\"register\"] = ({ methods }) => {\n    this.isInitialized();\n    this.registeredMethods = [...new Set([...this.registeredMethods, ...methods])];\n  };\n\n  public create: IPairing[\"create\"] = async (params) => {\n    this.isInitialized();\n    const symKey = generateRandomBytes32();\n    const topic = await this.core.crypto.setSymKey(symKey);\n    const expiry = calcExpiry(FIVE_MINUTES);\n    const relay = { protocol: RELAYER_DEFAULT_PROTOCOL };\n    const pairing = { topic, expiry, relay, active: false, methods: params?.methods };\n    const uri = formatUri({\n      protocol: this.core.protocol,\n      version: this.core.version,\n      topic,\n      symKey,\n      relay,\n      expiryTimestamp: expiry,\n      methods: params?.methods,\n    });\n    this.events.emit(PAIRING_EVENTS.create, pairing);\n    this.core.expirer.set(topic, expiry);\n    await this.pairings.set(topic, pairing);\n    await this.core.relayer.subscribe(topic, { transportType: params?.transportType });\n\n    return { topic, uri };\n  };\n\n  public pair: IPairing[\"pair\"] = async (params) => {\n    this.isInitialized();\n\n    const event = this.core.eventClient.createEvent({\n      properties: {\n        topic: params?.uri,\n        trace: [EVENT_CLIENT_PAIRING_TRACES.pairing_started],\n      },\n    });\n\n    this.isValidPair(params, event);\n\n    const { topic, symKey, relay, expiryTimestamp, methods } = parseUri(params.uri);\n\n    event.props.properties.topic = topic;\n    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.pairing_uri_validation_success);\n    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.pairing_uri_not_expired);\n\n    let existingPairing;\n    if (this.pairings.keys.includes(topic)) {\n      existingPairing = this.pairings.get(topic);\n      event.addTrace(EVENT_CLIENT_PAIRING_TRACES.existing_pairing);\n      if (existingPairing.active) {\n        event.setError(EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists);\n        throw new Error(\n          `Pairing already exists: ${topic}. Please try again with a new connection URI.`,\n        );\n      } else {\n        event.addTrace(EVENT_CLIENT_PAIRING_TRACES.pairing_not_expired);\n      }\n    }\n\n    const expiry = expiryTimestamp || calcExpiry(FIVE_MINUTES);\n    const pairing = { topic, relay, expiry, active: false, methods };\n    this.core.expirer.set(topic, expiry);\n    await this.pairings.set(topic, pairing);\n\n    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.store_new_pairing);\n\n    if (params.activatePairing) {\n      await this.activate({ topic });\n    }\n\n    this.events.emit(PAIRING_EVENTS.create, pairing);\n\n    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.emit_inactive_pairing);\n\n    // avoid overwriting keychain pairing already exists\n    if (!this.core.crypto.keychain.has(topic)) {\n      await this.core.crypto.setSymKey(symKey, topic);\n    }\n    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.subscribing_pairing_topic);\n\n    try {\n      await this.core.relayer.confirmOnlineStateOrThrow();\n    } catch (error) {\n      event.setError(EVENT_CLIENT_PAIRING_ERRORS.no_internet_connection);\n    }\n\n    try {\n      await this.core.relayer.subscribe(topic, { relay });\n    } catch (error) {\n      event.setError(EVENT_CLIENT_PAIRING_ERRORS.subscribe_pairing_topic_failure);\n      throw error;\n    }\n\n    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.subscribe_pairing_topic_success);\n\n    return pairing;\n  };\n\n  public activate: IPairing[\"activate\"] = async ({ topic }) => {\n    this.isInitialized();\n    const expiry = calcExpiry(FIVE_MINUTES);\n    this.core.expirer.set(topic, expiry);\n    await this.pairings.update(topic, { active: true, expiry });\n  };\n\n  /**\n   * @deprecated Ping will be removed in the next major release.\n   */\n  public ping: IPairing[\"ping\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidPing(params);\n    this.logger.warn(\"ping() is deprecated and will be removed in the next major release.\");\n    const { topic } = params;\n    if (this.pairings.keys.includes(topic)) {\n      const id = await this.sendRequest(topic, \"wc_pairingPing\", {});\n      const { done, resolve, reject } = createDelayedPromise<void>();\n      this.events.once(engineEvent(\"pairing_ping\", id), ({ error }) => {\n        if (error) reject(error);\n        else resolve();\n      });\n      await done();\n    }\n  };\n\n  public updateExpiry: IPairing[\"updateExpiry\"] = async ({ topic, expiry }) => {\n    this.isInitialized();\n    await this.pairings.update(topic, { expiry });\n  };\n\n  public updateMetadata: IPairing[\"updateMetadata\"] = async ({ topic, metadata }) => {\n    this.isInitialized();\n    await this.pairings.update(topic, { peerMetadata: metadata });\n  };\n\n  public getPairings: IPairing[\"getPairings\"] = () => {\n    this.isInitialized();\n    return this.pairings.values;\n  };\n\n  public disconnect: IPairing[\"disconnect\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidDisconnect(params);\n    const { topic } = params;\n    if (this.pairings.keys.includes(topic)) {\n      await this.sendRequest(topic, \"wc_pairingDelete\", getSdkError(\"USER_DISCONNECTED\"));\n      await this.deletePairing(topic);\n    }\n  };\n\n  public formatUriFromPairing: IPairing[\"formatUriFromPairing\"] = (pairing) => {\n    this.isInitialized();\n    const { topic, relay, expiry, methods } = pairing;\n    const symKey = this.core.crypto.keychain.get(topic);\n    return formatUri({\n      protocol: this.core.protocol,\n      version: this.core.version,\n      topic,\n      symKey,\n      relay,\n      expiryTimestamp: expiry,\n      methods,\n    });\n  };\n\n  // ---------- Private Helpers ----------------------------------------------- //\n\n  private sendRequest: IPairingPrivate[\"sendRequest\"] = async (topic, method, params) => {\n    const payload = formatJsonRpcRequest(method, params);\n    const message = await this.core.crypto.encode(topic, payload);\n    const opts = PAIRING_RPC_OPTS[method].req;\n    this.core.history.set(topic, payload);\n    this.core.relayer.publish(topic, message, opts);\n    return payload.id;\n  };\n\n  private sendResult: IPairingPrivate[\"sendResult\"] = async (id, topic, result) => {\n    const payload = formatJsonRpcResult(id, result);\n    const message = await this.core.crypto.encode(topic, payload);\n    const record = await this.core.history.get(topic, id);\n    const method = record.request.method as PairingJsonRpcTypes.WcMethod;\n    const opts = PAIRING_RPC_OPTS[method].res;\n    await this.core.relayer.publish(topic, message, opts);\n    await this.core.history.resolve(payload);\n  };\n\n  private sendError: IPairingPrivate[\"sendError\"] = async (id, topic, error) => {\n    const payload = formatJsonRpcError(id, error);\n    const message = await this.core.crypto.encode(topic, payload);\n    const record = await this.core.history.get(topic, id);\n    const method = record.request.method as PairingJsonRpcTypes.WcMethod;\n\n    const opts = PAIRING_RPC_OPTS[method]\n      ? PAIRING_RPC_OPTS[method].res\n      : PAIRING_RPC_OPTS.unregistered_method.res;\n\n    await this.core.relayer.publish(topic, message, opts);\n    await this.core.history.resolve(payload);\n  };\n\n  private deletePairing: IPairingPrivate[\"deletePairing\"] = async (topic, expirerHasDeleted) => {\n    // Await the unsubscribe first to avoid deleting the symKey too early below.\n    await this.core.relayer.unsubscribe(topic);\n    await Promise.all([\n      this.pairings.delete(topic, getSdkError(\"USER_DISCONNECTED\")),\n      this.core.crypto.deleteSymKey(topic),\n      expirerHasDeleted ? Promise.resolve() : this.core.expirer.del(topic),\n    ]);\n  };\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  private cleanup = async () => {\n    const expiredPairings = this.pairings.getAll().filter((pairing) => isExpired(pairing.expiry));\n    await Promise.all(expiredPairings.map((pairing) => this.deletePairing(pairing.topic)));\n  };\n\n  // ---------- Relay Events Router ----------------------------------- //\n\n  private registerRelayerEvents() {\n    this.core.relayer.on(RELAYER_EVENTS.message, async (event: RelayerTypes.MessageEvent) => {\n      const { topic, message, transportType } = event;\n\n      // Do not handle if the topic is not related to known pairing topics.\n      if (!this.pairings.keys.includes(topic)) return;\n\n      // Do not handle link-mode messages\n      if (transportType === TRANSPORT_TYPES.link_mode) return;\n\n      // messages of certain types should be ignored as they are handled by their respective SDKs\n      if (this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(message))) return;\n\n      try {\n        const payload = await this.core.crypto.decode(topic, message);\n\n        if (isJsonRpcRequest(payload)) {\n          this.core.history.set(topic, payload);\n          await this.onRelayEventRequest({ topic, payload });\n        } else if (isJsonRpcResponse(payload)) {\n          await this.core.history.resolve(payload);\n          await this.onRelayEventResponse({ topic, payload });\n          this.core.history.delete(topic, payload.id);\n        }\n        await this.core.relayer.messages.ack(topic, message);\n      } catch (error) {\n        this.logger.error(error);\n      }\n    });\n  }\n\n  private onRelayEventRequest: IPairingPrivate[\"onRelayEventRequest\"] = async (event) => {\n    const { topic, payload } = event;\n    const reqMethod = payload.method as PairingJsonRpcTypes.WcMethod;\n\n    switch (reqMethod) {\n      case \"wc_pairingPing\":\n        return await this.onPairingPingRequest(topic, payload);\n      case \"wc_pairingDelete\":\n        return await this.onPairingDeleteRequest(topic, payload);\n      default:\n        return await this.onUnknownRpcMethodRequest(topic, payload);\n    }\n  };\n\n  private onRelayEventResponse: IPairingPrivate[\"onRelayEventResponse\"] = async (event) => {\n    const { topic, payload } = event;\n    const record = await this.core.history.get(topic, payload.id);\n    const resMethod = record.request.method as PairingJsonRpcTypes.WcMethod;\n\n    switch (resMethod) {\n      case \"wc_pairingPing\":\n        return this.onPairingPingResponse(topic, payload);\n      default:\n        return this.onUnknownRpcMethodResponse(resMethod);\n    }\n  };\n\n  private onPairingPingRequest: IPairingPrivate[\"onPairingPingRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidPing({ topic });\n      await this.sendResult<\"wc_pairingPing\">(id, topic, true);\n      this.events.emit(PAIRING_EVENTS.ping, { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.logger.error(err);\n    }\n  };\n\n  private onPairingPingResponse: IPairingPrivate[\"onPairingPingResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    // put at the end of the stack to avoid a race condition\n    // where pairing_ping listener is not yet initialized\n    setTimeout(() => {\n      if (isJsonRpcResult(payload)) {\n        this.events.emit(engineEvent(\"pairing_ping\", id), {});\n      } else if (isJsonRpcError(payload)) {\n        this.events.emit(engineEvent(\"pairing_ping\", id), { error: payload.error });\n      }\n    }, 500);\n  };\n\n  private onPairingDeleteRequest: IPairingPrivate[\"onPairingDeleteRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidDisconnect({ topic });\n      await this.deletePairing(topic);\n      this.events.emit(PAIRING_EVENTS.delete, { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.logger.error(err);\n    }\n  };\n\n  private onUnknownRpcMethodRequest: IPairingPrivate[\"onUnknownRpcMethodRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, method } = payload;\n\n    try {\n      // Ignore if the implementing client has registered this method as known.\n      if (this.registeredMethods.includes(method)) return;\n      const error = getSdkError(\"WC_METHOD_UNSUPPORTED\", method);\n      await this.sendError(id, topic, error);\n      this.logger.error(error);\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.logger.error(err);\n    }\n  };\n\n  private onUnknownRpcMethodResponse: IPairingPrivate[\"onUnknownRpcMethodResponse\"] = (method) => {\n    // Ignore if the implementing client has registered this method as known.\n    if (this.registeredMethods.includes(method)) return;\n    this.logger.error(getSdkError(\"WC_METHOD_UNSUPPORTED\", method));\n  };\n\n  // ---------- Expirer Events ---------------------------------------- //\n\n  private registerExpirerEvents() {\n    this.core.expirer.on(EXPIRER_EVENTS.expired, async (event: ExpirerTypes.Expiration) => {\n      const { topic } = parseExpirerTarget(event.target);\n      if (!topic) return;\n      if (!this.pairings.keys.includes(topic)) return;\n      await this.deletePairing(topic, true);\n      this.events.emit(PAIRING_EVENTS.expire, { topic });\n    });\n  }\n\n  // ---------- Validation Helpers ----------------------------------- //\n\n  private isValidPair = (params: { uri: string }, event: EventClientTypes.Event) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `pair() params: ${params}`);\n      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);\n      throw new Error(message);\n    }\n    if (!isValidUrl(params.uri)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `pair() uri: ${params.uri}`);\n      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);\n      throw new Error(message);\n    }\n    const uri = parseUri(params?.uri);\n    if (!uri?.relay?.protocol) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `pair() uri#relay-protocol`);\n      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);\n      throw new Error(message);\n    }\n    if (!uri?.symKey) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `pair() uri#symKey`);\n      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);\n      throw new Error(message);\n    }\n    if (uri?.expiryTimestamp) {\n      const expiration = toMiliseconds(uri?.expiryTimestamp);\n      if (expiration < Date.now()) {\n        event.setError(EVENT_CLIENT_PAIRING_ERRORS.pairing_expired);\n        const { message } = getInternalError(\n          \"EXPIRED\",\n          `pair() URI has expired. Please try again with a new connection URI.`,\n        );\n        throw new Error(message);\n      }\n    }\n  };\n\n  private isValidPing = async (params: { topic: string }) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `ping() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidPairingTopic(topic);\n  };\n\n  private isValidDisconnect = async (params: { topic: string }) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `disconnect() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidPairingTopic(topic);\n  };\n\n  private isValidPairingTopic = async (topic: any) => {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.pairings.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.pairings.get(topic).expiry)) {\n      await this.deletePairing(topic);\n      const { message } = getInternalError(\"EXPIRED\", `pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n  };\n}\n","import { formatJsonRpcRequest, isJsonRpcError } from \"@walletconnect/jsonrpc-utils\";\nimport { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { IJsonRpcHistory, JsonRpcRecord, RequestEvent, ICore } from \"@walletconnect/types\";\nimport { calcExpiry, getInternalError } from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport { THIRTY_DAYS, toMiliseconds } from \"@walletconnect/time\";\nimport { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport {\n  CORE_STORAGE_PREFIX,\n  HISTORY_CONTEXT,\n  HISTORY_EVENTS,\n  HISTORY_STORAGE_VERSION,\n} from \"../constants\";\n\nexport class JsonRpcHistory extends IJsonRpcHistory {\n  public records = new Map<number, JsonRpcRecord>();\n  public events = new EventEmitter();\n  public name = HISTORY_CONTEXT;\n  public version = HISTORY_STORAGE_VERSION;\n\n  private cached: JsonRpcRecord[] = [];\n  private initialized = false;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super(core, logger);\n    this.logger = generateChildLogger(logger, this.name);\n  }\n\n  public init: IJsonRpcHistory[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n      await this.restore();\n      this.cached.forEach((record) => this.records.set(record.id, record));\n      this.cached = [];\n      this.registerEventListeners();\n      this.initialized = true;\n    }\n  };\n\n  get context(): string {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n\n  get size(): number {\n    return this.records.size;\n  }\n\n  get keys(): number[] {\n    return Array.from(this.records.keys());\n  }\n\n  get values() {\n    return Array.from(this.records.values());\n  }\n\n  get pending(): RequestEvent[] {\n    const requests: RequestEvent[] = [];\n    this.values.forEach((record) => {\n      if (typeof record.response !== \"undefined\") return;\n      const requestEvent: RequestEvent = {\n        topic: record.topic,\n        request: formatJsonRpcRequest(record.request.method, record.request.params, record.id),\n        chainId: record.chainId,\n      };\n      return requests.push(requestEvent);\n    });\n    return requests;\n  }\n\n  public set: IJsonRpcHistory[\"set\"] = (topic, request, chainId) => {\n    this.isInitialized();\n    this.logger.debug(`Setting JSON-RPC request history record`);\n    this.logger.trace({ type: \"method\", method: \"set\", topic, request, chainId });\n    if (this.records.has(request.id)) return;\n    const record: JsonRpcRecord = {\n      id: request.id,\n      topic,\n      request: { method: request.method, params: request.params || null },\n      chainId,\n      expiry: calcExpiry(THIRTY_DAYS),\n    };\n    this.records.set(record.id, record);\n    this.persist();\n    this.events.emit(HISTORY_EVENTS.created, record);\n  };\n\n  public resolve: IJsonRpcHistory[\"resolve\"] = async (response) => {\n    this.isInitialized();\n    this.logger.debug(`Updating JSON-RPC response history record`);\n    this.logger.trace({ type: \"method\", method: \"update\", response });\n    if (!this.records.has(response.id)) return;\n    const record = await this.getRecord(response.id);\n    if (typeof record.response !== \"undefined\") return;\n    record.response = isJsonRpcError(response)\n      ? { error: response.error }\n      : { result: response.result };\n    this.records.set(record.id, record);\n    this.persist();\n    this.events.emit(HISTORY_EVENTS.updated, record);\n  };\n\n  public get: IJsonRpcHistory[\"get\"] = async (topic, id) => {\n    this.isInitialized();\n    this.logger.debug(`Getting record`);\n    this.logger.trace({ type: \"method\", method: \"get\", topic, id });\n    const record = await this.getRecord(id);\n    return record;\n  };\n\n  public delete: IJsonRpcHistory[\"delete\"] = (topic, id) => {\n    this.isInitialized();\n    this.logger.debug(`Deleting record`);\n    this.logger.trace({ type: \"method\", method: \"delete\", id });\n    this.values.forEach((record: JsonRpcRecord) => {\n      if (record.topic === topic) {\n        if (typeof id !== \"undefined\" && record.id !== id) return;\n        this.records.delete(record.id);\n        this.events.emit(HISTORY_EVENTS.deleted, record);\n      }\n    });\n    this.persist();\n  };\n\n  public exists: IJsonRpcHistory[\"exists\"] = async (topic, id) => {\n    this.isInitialized();\n    if (!this.records.has(id)) return false;\n    const record = await this.getRecord(id);\n    return record.topic === topic;\n  };\n\n  public on: IJsonRpcHistory[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n  };\n\n  public once: IJsonRpcHistory[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n  };\n\n  public off: IJsonRpcHistory[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n  };\n\n  public removeListener: IJsonRpcHistory[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setJsonRpcRecords(records: JsonRpcRecord[]): Promise<void> {\n    await this.core.storage.setItem<JsonRpcRecord[]>(this.storageKey, records);\n  }\n\n  private async getJsonRpcRecords(): Promise<JsonRpcRecord[] | undefined> {\n    const records = await this.core.storage.getItem<JsonRpcRecord[]>(this.storageKey);\n    return records;\n  }\n\n  private getRecord(id: number) {\n    this.isInitialized();\n    const record = this.records.get(id);\n    if (!record) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${id}`);\n      throw new Error(message);\n    }\n    return record;\n  }\n\n  private async persist() {\n    await this.setJsonRpcRecords(this.values);\n    this.events.emit(HISTORY_EVENTS.sync);\n  }\n\n  private async restore() {\n    try {\n      const persisted = await this.getJsonRpcRecords();\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n      if (this.records.size) {\n        const { message } = getInternalError(\"RESTORE_WILL_OVERRIDE\", this.name);\n        this.logger.error(message);\n        throw new Error(message);\n      }\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored records for ${this.name}`);\n      this.logger.trace({ type: \"method\", method: \"restore\", records: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore records for ${this.name}`);\n      this.logger.error(e as any);\n    }\n  }\n\n  private registerEventListeners(): void {\n    this.events.on(HISTORY_EVENTS.created, (record: JsonRpcRecord) => {\n      const eventName = HISTORY_EVENTS.created;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, record });\n    });\n    this.events.on(HISTORY_EVENTS.updated, (record: JsonRpcRecord) => {\n      const eventName = HISTORY_EVENTS.updated;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, record });\n    });\n\n    this.events.on(HISTORY_EVENTS.deleted, (record: JsonRpcRecord) => {\n      const eventName = HISTORY_EVENTS.deleted;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, record });\n    });\n\n    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {\n      this.cleanup();\n    });\n  }\n\n  private cleanup() {\n    try {\n      this.isInitialized();\n      let deleted = false;\n      this.records.forEach((record: JsonRpcRecord) => {\n        const msToExpiry = toMiliseconds(record.expiry || 0) - Date.now();\n        if (msToExpiry <= 0) {\n          this.logger.info(`Deleting expired history log: ${record.id}`);\n          this.records.delete(record.id);\n          this.events.emit(HISTORY_EVENTS.deleted, record, false);\n          deleted = true;\n        }\n      });\n      if (deleted) {\n        this.persist();\n      }\n    } catch (e) {\n      this.logger.warn(e);\n    }\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { toMiliseconds } from \"@walletconnect/time\";\nimport { ExpirerTypes, ICore, IExpirer } from \"@walletconnect/types\";\nimport { getInternalError, formatIdTarget, formatTopicTarget } from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport {\n  CORE_STORAGE_PREFIX,\n  EXPIRER_CONTEXT,\n  EXPIRER_EVENTS,\n  EXPIRER_STORAGE_VERSION,\n} from \"../constants\";\n\nexport class Expirer extends IExpirer {\n  public expirations = new Map<string, ExpirerTypes.Expiration>();\n  public events = new EventEmitter();\n  public name = EXPIRER_CONTEXT;\n  public version = EXPIRER_STORAGE_VERSION;\n\n  private cached: ExpirerTypes.Expiration[] = [];\n  private initialized = false;\n\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super(core, logger);\n    this.logger = generateChildLogger(logger, this.name);\n  }\n\n  public init: IExpirer[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n      await this.restore();\n      this.cached.forEach((expiration) => this.expirations.set(expiration.target, expiration));\n      this.cached = [];\n      this.registerEventListeners();\n      this.initialized = true;\n    }\n  };\n\n  get context(): string {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n\n  get length(): number {\n    return this.expirations.size;\n  }\n\n  get keys(): string[] {\n    return Array.from(this.expirations.keys());\n  }\n\n  get values(): ExpirerTypes.Expiration[] {\n    return Array.from(this.expirations.values());\n  }\n\n  public has: IExpirer[\"has\"] = (key) => {\n    try {\n      const target = this.formatTarget(key);\n      const expiration = this.getExpiration(target);\n      return typeof expiration !== \"undefined\";\n    } catch (e) {\n      // ignore\n      return false;\n    }\n  };\n\n  public set: IExpirer[\"set\"] = (key, expiry) => {\n    this.isInitialized();\n    const target = this.formatTarget(key);\n    const expiration = { target, expiry };\n    this.expirations.set(target, expiration);\n    this.checkExpiry(target, expiration);\n    this.events.emit(EXPIRER_EVENTS.created, {\n      target,\n      expiration,\n    } as ExpirerTypes.Created);\n  };\n\n  public get: IExpirer[\"get\"] = (key) => {\n    this.isInitialized();\n    const target = this.formatTarget(key);\n    return this.getExpiration(target);\n  };\n\n  public del: IExpirer[\"del\"] = (key) => {\n    this.isInitialized();\n    const exists = this.has(key);\n    if (exists) {\n      const target = this.formatTarget(key);\n      const expiration = this.getExpiration(target);\n      this.expirations.delete(target);\n      this.events.emit(EXPIRER_EVENTS.deleted, {\n        target,\n        expiration,\n      } as ExpirerTypes.Deleted);\n    }\n  };\n\n  public on: IExpirer[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n  };\n\n  public once: IExpirer[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n  };\n\n  public off: IExpirer[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n  };\n\n  public removeListener: IExpirer[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private formatTarget(key: string | number) {\n    if (typeof key === \"string\") {\n      return formatTopicTarget(key);\n    } else if (typeof key === \"number\") {\n      return formatIdTarget(key);\n    }\n    const { message } = getInternalError(\"UNKNOWN_TYPE\", `Target type: ${typeof key}`);\n    throw new Error(message);\n  }\n\n  private async setExpirations(expirations: ExpirerTypes.Expiration[]): Promise<void> {\n    await this.core.storage.setItem<ExpirerTypes.Expiration[]>(this.storageKey, expirations);\n  }\n\n  private async getExpirations(): Promise<ExpirerTypes.Expiration[] | undefined> {\n    const expirations = await this.core.storage.getItem<ExpirerTypes.Expiration[]>(this.storageKey);\n    return expirations;\n  }\n\n  private async persist() {\n    await this.setExpirations(this.values);\n    this.events.emit(EXPIRER_EVENTS.sync);\n  }\n\n  private async restore() {\n    try {\n      const persisted = await this.getExpirations();\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n      if (this.expirations.size) {\n        const { message } = getInternalError(\"RESTORE_WILL_OVERRIDE\", this.name);\n        this.logger.error(message);\n        throw new Error(message);\n      }\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored expirations for ${this.name}`);\n      this.logger.trace({ type: \"method\", method: \"restore\", expirations: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore expirations for ${this.name}`);\n      this.logger.error(e as any);\n    }\n  }\n\n  private getExpiration(target: string): ExpirerTypes.Expiration {\n    const expiration = this.expirations.get(target);\n    if (!expiration) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${target}`);\n      this.logger.warn(message);\n      throw new Error(message);\n    }\n    return expiration;\n  }\n\n  private checkExpiry(target: string, expiration: ExpirerTypes.Expiration): void {\n    const { expiry } = expiration;\n    const msToTimeout = toMiliseconds(expiry) - Date.now();\n    if (msToTimeout <= 0) this.expire(target, expiration);\n  }\n\n  private expire(target: string, expiration: ExpirerTypes.Expiration): void {\n    this.expirations.delete(target);\n    this.events.emit(EXPIRER_EVENTS.expired, {\n      target,\n      expiration,\n    } as ExpirerTypes.Expired);\n  }\n\n  private checkExpirations(): void {\n    // avoid auto expiring if the relayer is not connected\n    if (!this.core.relayer.connected) return;\n    this.expirations.forEach((expiration, target) => this.checkExpiry(target, expiration));\n  }\n\n  private registerEventListeners(): void {\n    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => this.checkExpirations());\n    this.events.on(EXPIRER_EVENTS.created, (createdEvent: ExpirerTypes.Created) => {\n      const eventName = EXPIRER_EVENTS.created;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: createdEvent });\n      this.persist();\n    });\n    this.events.on(EXPIRER_EVENTS.expired, (expiredEvent: ExpirerTypes.Expired) => {\n      const eventName = EXPIRER_EVENTS.expired;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: expiredEvent });\n      this.persist();\n    });\n    this.events.on(EXPIRER_EVENTS.deleted, (deletedEvent: ExpirerTypes.Deleted) => {\n      const eventName = EXPIRER_EVENTS.deleted;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: deletedEvent });\n      this.persist();\n    });\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { generateChildLogger, getLoggerContext, Logger } from \"@walletconnect/logger\";\nimport { ICore, IVerify } from \"@walletconnect/types\";\nimport { isBrowser, isTestRun, P256KeyDataType, verifyP256Jwt } from \"@walletconnect/utils\";\nimport { FIVE_SECONDS, ONE_SECOND, toMiliseconds } from \"@walletconnect/time\";\nimport { getDocument } from \"@walletconnect/window-getters\";\nimport { decodeJWT } from \"@walletconnect/relay-auth\";\n\nimport {\n  CORE_STORAGE_PREFIX,\n  CORE_VERSION,\n  TRUSTED_VERIFY_URLS,\n  VERIFY_CONTEXT,\n  VERIFY_SERVER,\n  VERIFY_SERVER_V3,\n} from \"../constants\";\nimport { IKeyValueStorage } from \"@walletconnect/keyvaluestorage\";\n\ntype Jwk = {\n  publicKey: P256KeyDataType;\n  expiresAt: number;\n};\ntype JwkPayload = {\n  exp: number;\n  id: string;\n  origin: string;\n  isScam: boolean;\n  isVerified: boolean;\n};\nexport class Verify extends IVerify {\n  public name = VERIFY_CONTEXT;\n  private abortController: AbortController;\n  private isDevEnv;\n  private verifyUrlV3 = VERIFY_SERVER_V3;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n  private version = CORE_VERSION;\n  private publicKey?: Jwk;\n  private fetchPromise?: Promise<Jwk>;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public store: IKeyValueStorage,\n  ) {\n    super(core, logger, store);\n    this.logger = generateChildLogger(logger, this.name);\n    this.abortController = new AbortController();\n    this.isDevEnv = isTestRun();\n    this.init();\n  }\n\n  get storeKey(): string {\n    return (\n      this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + `verify:public:key`\n    );\n  }\n\n  public init = async () => {\n    if (this.isDevEnv) return;\n    this.publicKey = await this.store.getItem(this.storeKey);\n    if (this.publicKey && toMiliseconds(this.publicKey?.expiresAt) < Date.now()) {\n      this.logger.debug(\"verify v2 public key expired\");\n      await this.removePublicKey();\n    }\n  };\n\n  public register: IVerify[\"register\"] = async (params) => {\n    if (!isBrowser() || this.isDevEnv) return;\n    const origin = window.location.origin;\n    const { id, decryptedId } = params;\n    const src = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${origin}&id=${id}&decryptedId=${decryptedId}`;\n    try {\n      const document = getDocument() as Document;\n      const abortTimeout = this.startAbortTimer(ONE_SECOND * 5);\n      const attestationJwt = await new Promise((resolve, reject) => {\n        const abortListener = () => {\n          window.removeEventListener(\"message\", listener);\n          document.body.removeChild(iframe);\n          reject(\"attestation aborted\");\n        };\n        this.abortController.signal.addEventListener(\"abort\", abortListener);\n        const iframe = document.createElement(\"iframe\");\n        iframe.src = src;\n        iframe.style.display = \"none\";\n        iframe.addEventListener(\"error\", abortListener, { signal: this.abortController.signal });\n        const listener = (event: MessageEvent) => {\n          if (!event.data) return;\n          if (typeof event.data !== \"string\") return;\n          try {\n            const data = JSON.parse(event.data);\n            if (data.type === \"verify_attestation\") {\n              const decoded = decodeJWT(data.attestation) as unknown as { payload: JwkPayload };\n              if (decoded.payload.id !== id) return;\n\n              clearInterval(abortTimeout);\n              document.body.removeChild(iframe);\n              this.abortController.signal.removeEventListener(\"abort\", abortListener);\n              window.removeEventListener(\"message\", listener);\n              resolve(data.attestation === null ? \"\" : data.attestation);\n            }\n          } catch (e) {\n            this.logger.warn(e);\n          }\n        };\n        document.body.appendChild(iframe);\n        window.addEventListener(\"message\", listener, { signal: this.abortController.signal });\n      });\n      this.logger.debug(\"jwt attestation\", attestationJwt);\n      return attestationJwt as string;\n    } catch (e) {\n      this.logger.warn(e);\n    }\n    return \"\";\n  };\n\n  public resolve: IVerify[\"resolve\"] = async (params) => {\n    if (this.isDevEnv) return \"\";\n    const { attestationId, hash, encryptedId } = params;\n    if (attestationId === \"\") {\n      this.logger.debug(\"resolve: attestationId is empty, skipping\");\n      return;\n    }\n\n    if (attestationId) {\n      const decoded = decodeJWT(attestationId) as unknown as { payload: JwkPayload };\n      if (decoded.payload.id !== encryptedId) return;\n      const validation = await this.isValidJwtAttestation(attestationId);\n      if (validation) {\n        if (!validation.isVerified) {\n          this.logger.warn(\"resolve: jwt attestation: origin url not verified\");\n          return;\n        }\n        return validation;\n      }\n    }\n    if (!hash) return;\n    const verifyUrl = this.getVerifyUrl(params?.verifyUrl);\n    return this.fetchAttestation(hash, verifyUrl);\n  };\n\n  get context(): string {\n    return getLoggerContext(this.logger);\n  }\n\n  private fetchAttestation = async (attestationId: string, url: string) => {\n    this.logger.debug(`resolving attestation: ${attestationId} from url: ${url}`);\n    // set artificial timeout to prevent hanging\n    const timeout = this.startAbortTimer(ONE_SECOND * 5);\n    const result = await fetch(`${url}/attestation/${attestationId}?v2Supported=true`, {\n      signal: this.abortController.signal,\n    });\n    clearTimeout(timeout);\n    return result.status === 200 ? await result.json() : undefined;\n  };\n\n  private startAbortTimer(timer: number) {\n    this.abortController = new AbortController();\n    return setTimeout(() => this.abortController.abort(), toMiliseconds(timer));\n  }\n\n  private getVerifyUrl = (verifyUrl?: string) => {\n    let url = verifyUrl || VERIFY_SERVER;\n    if (!TRUSTED_VERIFY_URLS.includes(url)) {\n      this.logger.info(\n        `verify url: ${url}, not included in trusted list, assigning default: ${VERIFY_SERVER}`,\n      );\n      url = VERIFY_SERVER;\n    }\n    return url;\n  };\n\n  private fetchPublicKey = async () => {\n    try {\n      this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);\n      const timeout = this.startAbortTimer(FIVE_SECONDS);\n      const result = await fetch(`${this.verifyUrlV3}/public-key`, {\n        signal: this.abortController.signal,\n      });\n      clearTimeout(timeout);\n      return (await result.json()) as Jwk;\n    } catch (e) {\n      this.logger.warn(e);\n    }\n    return undefined;\n  };\n\n  private persistPublicKey = async (publicKey: Jwk) => {\n    this.logger.debug(`persisting public key to local storage`, publicKey);\n    await this.store.setItem(this.storeKey, publicKey);\n    this.publicKey = publicKey;\n  };\n\n  private removePublicKey = async () => {\n    this.logger.debug(`removing verify v2 public key from storage`);\n    await this.store.removeItem(this.storeKey);\n    this.publicKey = undefined;\n  };\n\n  private isValidJwtAttestation = async (attestation: string) => {\n    const key = await this.getPublicKey();\n    try {\n      if (key) {\n        const validation = this.validateAttestation(attestation, key);\n        return validation;\n      }\n    } catch (e) {\n      this.logger.error(e);\n      this.logger.warn(\"error validating attestation\");\n    }\n    const newKey = await this.fetchAndPersistPublicKey();\n    try {\n      if (newKey) {\n        const validation = this.validateAttestation(attestation, newKey);\n        return validation;\n      }\n    } catch (e) {\n      this.logger.error(e);\n      this.logger.warn(\"error validating attestation\");\n    }\n    return undefined;\n  };\n\n  private getPublicKey = async () => {\n    if (this.publicKey) return this.publicKey;\n    return await this.fetchAndPersistPublicKey();\n  };\n\n  private fetchAndPersistPublicKey = async () => {\n    if (this.fetchPromise) {\n      await this.fetchPromise;\n      return this.publicKey;\n    }\n    this.fetchPromise = new Promise(async (resolve) => {\n      const key = await this.fetchPublicKey();\n      if (!key) return;\n      await this.persistPublicKey(key);\n      resolve(key);\n    });\n    const key = await this.fetchPromise;\n    this.fetchPromise = undefined;\n    return key;\n  };\n\n  private validateAttestation = (attestation: string, key: Jwk) => {\n    const result = verifyP256Jwt<JwkPayload>(attestation, key.publicKey);\n    const validation = {\n      hasExpired: toMiliseconds(result.exp) < Date.now(),\n      payload: result,\n    };\n\n    if (validation.hasExpired) {\n      this.logger.warn(\"resolve: jwt attestation expired\");\n      throw new Error(\"JWT attestation expired\");\n    }\n\n    return {\n      origin: validation.payload.origin,\n      isScam: validation.payload.isScam,\n      isVerified: validation.payload.isVerified,\n    };\n  };\n}\n","import { generateChildLogger, Logger } from \"@walletconnect/logger\";\nimport { IEchoClient } from \"@walletconnect/types\";\nimport { ECHO_CONTEXT, ECHO_URL } from \"../constants\";\n\nexport class EchoClient extends IEchoClient {\n  public readonly context = ECHO_CONTEXT;\n  constructor(\n    public projectId: string,\n    public logger: Logger,\n  ) {\n    super(projectId, logger);\n    this.logger = generateChildLogger(logger, this.context);\n  }\n\n  public registerDeviceToken: IEchoClient[\"registerDeviceToken\"] = async (params) => {\n    const { clientId, token, notificationType, enableEncrypted = false } = params;\n\n    const echoUrl = `${ECHO_URL}/${this.projectId}/clients`;\n\n    await fetch(echoUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        client_id: clientId,\n        type: notificationType,\n        token,\n        always_raw: enableEncrypted,\n      }),\n    });\n  };\n}\n","import { generateChildLogger, Logger } from \"@walletconnect/logger\";\nimport { ICore, IEventClient, EventClientTypes } from \"@walletconnect/types\";\nimport { formatUA, isTestRun, uuidv4, getAppMetadata } from \"@walletconnect/utils\";\nimport {\n  CORE_STORAGE_PREFIX,\n  EVENTS_CLIENT_API_URL,\n  EVENTS_STORAGE_CLEANUP_INTERVAL,\n  EVENTS_STORAGE_CONTEXT,\n  EVENTS_STORAGE_VERSION,\n  RELAYER_SDK_VERSION,\n} from \"../constants\";\nimport { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport { fromMiliseconds } from \"@walletconnect/time\";\n\nexport class EventClient extends IEventClient {\n  public readonly context = EVENTS_STORAGE_CONTEXT;\n  private readonly storagePrefix = CORE_STORAGE_PREFIX;\n  private readonly storageVersion = EVENTS_STORAGE_VERSION;\n  private events = new Map<string, EventClientTypes.Event>();\n  private shouldPersist = false;\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    telemetryEnabled = true,\n  ) {\n    super(core, logger, telemetryEnabled);\n    this.logger = generateChildLogger(logger, this.context);\n    this.telemetryEnabled = telemetryEnabled;\n    if (telemetryEnabled) {\n      this.restore().then(async () => {\n        await this.submit();\n        this.setEventListeners();\n      });\n    } else {\n      // overwrite any persisted events with an empty array\n      this.persist();\n    }\n  }\n\n  get storageKey() {\n    return (\n      this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + \"//\" + this.context\n    );\n  }\n\n  public init: IEventClient[\"init\"] = async () => {\n    if (isTestRun()) return;\n    try {\n      const initEvent = {\n        eventId: uuidv4(),\n        timestamp: Date.now(),\n        domain: this.getAppDomain(),\n        props: {\n          event: \"INIT\",\n          type: \"\",\n          properties: {\n            client_id: await this.core.crypto.getClientId(),\n            user_agent: formatUA(\n              this.core.relayer.protocol,\n              this.core.relayer.version,\n              RELAYER_SDK_VERSION,\n            ),\n          },\n        },\n      };\n      await this.sendEvent([initEvent] as unknown as EventClientTypes.Event[]);\n    } catch (error) {\n      this.logger.warn(error);\n    }\n  };\n\n  public createEvent: IEventClient[\"createEvent\"] = (params) => {\n    const {\n      event = \"ERROR\",\n      type = \"\",\n      properties: { topic, trace },\n    } = params;\n    const eventId = uuidv4();\n    const bundleId = this.core.projectId || \"\";\n    const timestamp = Date.now();\n    const props = {\n      event,\n      type,\n      properties: {\n        topic,\n        trace,\n      },\n    };\n    const eventObj = {\n      eventId,\n      timestamp,\n      props,\n      bundleId,\n      domain: this.getAppDomain(),\n      ...this.setMethods(eventId),\n    };\n    if (this.telemetryEnabled) {\n      this.events.set(eventId, eventObj);\n      this.shouldPersist = true;\n    }\n\n    return eventObj;\n  };\n\n  public getEvent: IEventClient[\"getEvent\"] = (params) => {\n    const { eventId, topic } = params;\n    if (eventId) {\n      return this.events.get(eventId);\n    }\n    const event = Array.from(this.events.values()).find(\n      (event) => event.props.properties.topic === topic,\n    );\n\n    if (!event) return;\n\n    return {\n      ...event,\n      ...this.setMethods(event.eventId),\n    };\n  };\n\n  public deleteEvent: IEventClient[\"deleteEvent\"] = (params) => {\n    const { eventId } = params;\n    this.events.delete(eventId);\n    this.shouldPersist = true;\n  };\n\n  private setEventListeners = () => {\n    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, async () => {\n      if (this.shouldPersist) await this.persist();\n      // cleanup events older than EVENTS_STORAGE_CLEANUP_INTERVAL\n      this.events.forEach((event) => {\n        if (\n          fromMiliseconds(Date.now()) - fromMiliseconds(event.timestamp) >\n          EVENTS_STORAGE_CLEANUP_INTERVAL\n        ) {\n          this.events.delete(event.eventId);\n          this.shouldPersist = true;\n        }\n      });\n    });\n  };\n\n  private setMethods = (eventId: string) => {\n    return {\n      addTrace: (trace: string) => this.addTrace(eventId, trace),\n      setError: (errorType: string) => this.setError(eventId, errorType),\n    };\n  };\n\n  private addTrace = (eventId: string, trace: string) => {\n    const event = this.events.get(eventId);\n    if (!event) return;\n    event.props.properties.trace.push(trace);\n    this.events.set(eventId, event);\n    this.shouldPersist = true;\n  };\n\n  private setError = (eventId: string, errorType: string) => {\n    const event = this.events.get(eventId);\n    if (!event) return;\n    event.props.type = errorType;\n    event.timestamp = Date.now();\n    this.events.set(eventId, event);\n    this.shouldPersist = true;\n  };\n\n  private persist = async () => {\n    await this.core.storage.setItem(this.storageKey, Array.from(this.events.values()));\n    this.shouldPersist = false;\n  };\n\n  private restore = async () => {\n    try {\n      const events =\n        (await this.core.storage.getItem<EventClientTypes.Event[]>(this.storageKey)) || [];\n      if (!events.length) return;\n      events.forEach((event) => {\n        this.events.set(event.eventId, {\n          ...event,\n          ...this.setMethods(event.eventId),\n        });\n      });\n    } catch (error) {\n      this.logger.warn(error);\n    }\n  };\n\n  private submit = async () => {\n    if (!this.telemetryEnabled) return;\n\n    if (this.events.size === 0) return;\n\n    const eventsToSend: EventClientTypes.Event[] = [];\n    // exclude events without type as they can be considered `in progress`\n    for (const [_, event] of this.events) {\n      if (event.props.type) {\n        eventsToSend.push(event);\n      }\n    }\n\n    if (eventsToSend.length === 0) return;\n\n    try {\n      const response = await this.sendEvent(eventsToSend);\n      if (response.ok) {\n        for (const event of eventsToSend) {\n          this.events.delete(event.eventId);\n          this.shouldPersist = true;\n        }\n      }\n    } catch (error) {\n      this.logger.warn(error);\n    }\n  };\n\n  private sendEvent = async (events: EventClientTypes.Event[]) => {\n    // if domain isn't available, set `sp` as `desktop` so data would be extracted on api side\n    const platform = this.getAppDomain() ? \"\" : \"&sp=desktop\";\n    const response = await fetch(\n      `${EVENTS_CLIENT_API_URL}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${RELAYER_SDK_VERSION}${platform}`,\n      {\n        method: \"POST\",\n        body: JSON.stringify(events),\n      },\n    );\n    return response;\n  };\n\n  private getAppDomain = () => {\n    return getAppMetadata().url;\n  };\n}\n","import { EventEmitter } from \"events\";\n\nimport { HeartBeat } from \"@walletconnect/heartbeat\";\nimport KeyValueStorage from \"@walletconnect/keyvaluestorage\";\nimport {\n  ChunkLoggerController,\n  generateChildLogger,\n  generatePlatformLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n} from \"@walletconnect/logger\";\nimport { CoreTypes, ICore } from \"@walletconnect/types\";\n\nimport {\n  CORE_CONTEXT,\n  CORE_DEFAULT,\n  CORE_PROTOCOL,\n  CORE_STORAGE_OPTIONS,\n  CORE_VERSION,\n  RELAYER_DEFAULT_RELAY_URL,\n  TRANSPORT_TYPES,\n  WALLETCONNECT_CLIENT_ID,\n  WALLETCONNECT_LINK_MODE_APPS,\n} from \"./constants\";\nimport {\n  Crypto,\n  EchoClient,\n  EventClient,\n  Expirer,\n  JsonRpcHistory,\n  Pairing,\n  Relayer,\n  Verify,\n} from \"./controllers\";\n\nexport class Core extends ICore {\n  public readonly protocol = CORE_PROTOCOL;\n  public readonly version = CORE_VERSION;\n\n  public readonly name: ICore[\"name\"] = CORE_CONTEXT;\n  public readonly relayUrl: ICore[\"relayUrl\"];\n  public readonly projectId: ICore[\"projectId\"];\n  public readonly customStoragePrefix: ICore[\"customStoragePrefix\"];\n  public events: ICore[\"events\"] = new EventEmitter();\n  public logger: ICore[\"logger\"];\n  public heartbeat: ICore[\"heartbeat\"];\n  public relayer: ICore[\"relayer\"];\n  public crypto: ICore[\"crypto\"];\n  public storage: ICore[\"storage\"];\n  public history: ICore[\"history\"];\n  public expirer: ICore[\"expirer\"];\n  public pairing: ICore[\"pairing\"];\n  public verify: ICore[\"verify\"];\n  public echoClient: ICore[\"echoClient\"];\n  public linkModeSupportedApps: ICore[\"linkModeSupportedApps\"];\n  public eventClient: ICore[\"eventClient\"];\n\n  private initialized = false;\n  private logChunkController: ChunkLoggerController | null;\n\n  static async init(opts?: CoreTypes.Options) {\n    const core = new Core(opts);\n    await core.initialize();\n    const clientId = await core.crypto.getClientId();\n    await core.storage.setItem(WALLETCONNECT_CLIENT_ID, clientId);\n\n    return core;\n  }\n\n  constructor(opts?: CoreTypes.Options) {\n    super(opts);\n\n    const globalCore = this.getGlobalCore(opts?.customStoragePrefix);\n    if (globalCore) {\n      try {\n        this.customStoragePrefix = globalCore.customStoragePrefix;\n        this.logger = globalCore.logger;\n        this.heartbeat = globalCore.heartbeat;\n        this.crypto = globalCore.crypto;\n        this.history = globalCore.history;\n        this.expirer = globalCore.expirer;\n        this.storage = globalCore.storage;\n        this.relayer = globalCore.relayer;\n        this.pairing = globalCore.pairing;\n        this.verify = globalCore.verify;\n        this.echoClient = globalCore.echoClient;\n        this.linkModeSupportedApps = globalCore.linkModeSupportedApps;\n        this.eventClient = globalCore.eventClient;\n        this.initialized = globalCore.initialized;\n        this.logChunkController = globalCore.logChunkController;\n        return globalCore;\n      } catch (error) {\n        console.warn(\"Failed to copy global core\", error);\n      }\n    }\n\n    this.projectId = opts?.projectId;\n    this.relayUrl = opts?.relayUrl || RELAYER_DEFAULT_RELAY_URL;\n    this.customStoragePrefix = opts?.customStoragePrefix ? `:${opts.customStoragePrefix}` : \"\";\n\n    const loggerOptions = getDefaultLoggerOptions({\n      level: typeof opts?.logger === \"string\" && opts.logger ? opts.logger : CORE_DEFAULT.logger,\n      name: CORE_CONTEXT,\n    });\n\n    const { logger, chunkLoggerController } = generatePlatformLogger({\n      opts: loggerOptions,\n      maxSizeInBytes: opts?.maxLogBlobSizeInBytes,\n      loggerOverride: opts?.logger,\n    });\n\n    this.logChunkController = chunkLoggerController;\n\n    if (this.logChunkController?.downloadLogsBlobInBrowser) {\n      // @ts-ignore\n      window.downloadLogsBlobInBrowser = async () => {\n        // Have to null check twice becquse there is no guarantee\n        // this.logChunkController.downloadLogsBlobInBrowser is always truthy\n        if (this.logChunkController?.downloadLogsBlobInBrowser) {\n          this.logChunkController?.downloadLogsBlobInBrowser({\n            clientId: await this.crypto.getClientId(),\n          });\n        }\n      };\n    }\n\n    this.logger = generateChildLogger(logger, this.name);\n    this.heartbeat = new HeartBeat();\n    this.crypto = new Crypto(this, this.logger, opts?.keychain);\n    this.history = new JsonRpcHistory(this, this.logger);\n    this.expirer = new Expirer(this, this.logger);\n    this.storage = opts?.storage\n      ? opts.storage\n      : new KeyValueStorage({ ...CORE_STORAGE_OPTIONS, ...opts?.storageOptions });\n    this.relayer = new Relayer({\n      core: this,\n      logger: this.logger,\n      relayUrl: this.relayUrl,\n      projectId: this.projectId,\n    });\n    this.pairing = new Pairing(this, this.logger);\n    this.verify = new Verify(this, this.logger, this.storage);\n    this.echoClient = new EchoClient(this.projectId || \"\", this.logger);\n    this.linkModeSupportedApps = [];\n    this.eventClient = new EventClient(this, this.logger, opts?.telemetryEnabled);\n    this.setGlobalCore(this);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  // ---------- Public ----------------------------------------------- //\n\n  public async start() {\n    if (this.initialized) return;\n    await this.initialize();\n  }\n\n  public async getLogsBlob() {\n    return this.logChunkController?.logsToBlob({\n      clientId: await this.crypto.getClientId(),\n    });\n  }\n\n  public async addLinkModeSupportedApp(universalLink: string) {\n    if (this.linkModeSupportedApps.includes(universalLink)) return;\n    this.linkModeSupportedApps.push(universalLink);\n    await this.storage.setItem(WALLETCONNECT_LINK_MODE_APPS, this.linkModeSupportedApps);\n  }\n\n  // ---------- Events ----------------------------------------------- //\n\n  public on = (name: any, listener: any) => {\n    return this.events.on(name, listener);\n  };\n\n  public once = (name: any, listener: any) => {\n    return this.events.once(name, listener);\n  };\n\n  public off = (name: any, listener: any) => {\n    return this.events.off(name, listener);\n  };\n\n  public removeListener = (name: any, listener: any) => {\n    return this.events.removeListener(name, listener);\n  };\n\n  // ---------- Link-mode ----------------------------------------------- //\n\n  public dispatchEnvelope = ({\n    topic,\n    message,\n    sessionExists,\n  }: {\n    topic: string;\n    message: string;\n    sessionExists: boolean;\n  }) => {\n    if (!topic || !message) return;\n\n    const payload = {\n      topic,\n      message,\n      publishedAt: Date.now(),\n      transportType: TRANSPORT_TYPES.link_mode,\n    };\n\n    this.relayer.onLinkMessageEvent(payload, { sessionExists });\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    try {\n      await this.crypto.init();\n      await this.history.init();\n      await this.expirer.init();\n      await this.relayer.init();\n      await this.heartbeat.init();\n      await this.pairing.init();\n      this.linkModeSupportedApps = (await this.storage.getItem(WALLETCONNECT_LINK_MODE_APPS)) || [];\n\n      this.initialized = true;\n      this.logger.info(`Core Initialization Success`);\n    } catch (error) {\n      this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, error);\n      this.logger.error((error as any).message);\n      throw error;\n    }\n  }\n\n  private getGlobalCore(customStoragePrefix = \"\"): Core | undefined {\n    try {\n      if (this.isGlobalCoreDisabled()) {\n        return undefined;\n      }\n      const globalCorePrefix = `_walletConnectCore_${customStoragePrefix}`;\n\n      const counterKey = `${globalCorePrefix}_count`;\n      globalThis[counterKey] = (globalThis[counterKey] || 0) + 1;\n      if (globalThis[counterKey] > 1) {\n        console.warn(\n          `WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[counterKey]} times.`,\n        );\n      }\n\n      return globalThis[globalCorePrefix];\n    } catch (error) {\n      console.warn(\"Failed to get global WalletConnect core\", error);\n      return undefined;\n    }\n  }\n\n  private setGlobalCore(core: Core) {\n    try {\n      if (this.isGlobalCoreDisabled()) {\n        return;\n      }\n      const customStoragePrefix = core.opts?.customStoragePrefix || \"\";\n      const globalCorePrefix = `_walletConnectCore_${customStoragePrefix}`;\n      globalThis[globalCorePrefix] = core;\n    } catch (error) {\n      console.warn(\"Failed to set global WalletConnect core\", error);\n    }\n  }\n\n  private isGlobalCoreDisabled() {\n    try {\n      return typeof process !== \"undefined\" && process.env.DISABLE_GLOBAL_CORE === \"true\";\n    } catch (error) {\n      return true;\n    }\n  }\n}\n","import { Core as WalletConnectCore } from \"./core\";\n\nexport * from \"./constants\";\nexport * from \"./controllers\";\n\nexport const Core = WalletConnectCore;\nexport default WalletConnectCore;\n"],"names":["ONE_DAY","SIX_HOURS","THIRTY_DAYS","FIVE_SECONDS","THIRTY_SECONDS","VERIFY_SERVER_COM","VERIFY_SERVER_ORG","fromString","from","basex","decode","encode","identity","varint","varint.encodingLength","varint.encodeTo","Digest.create","base2","base8","base10","base16","base32","base36","base64","base256emoji","bases","r","h","core","logger","__publicField","KEYCHAIN_CONTEXT","KEYCHAIN_STORAGE_VERSION","CORE_STORAGE_PREFIX","keychain","tag","key","message","getInternalError","generateChildLogger","getLoggerContext","mapToObj","objToMap","C","b","CRYPTO_CONTEXT","generateRandomBytes32","seed","keyPair","relayAuth","generateKeyPairUtil","aud","sub","ttl","CRYPTO_JWT_TTL","selfPublicKey","peerPublicKey","overrideTopic","selfPrivateKey","symKey","deriveSymKey","topic","hashKey","publicKey","payload","opts","params","validateEncoding","safeJsonStringify","isTypeTwoEnvelope","encodeTypeTwoEnvelope","isTypeOneEnvelope","type","senderPublicKey","encrypt","encoded","validateDecoding","decodeTypeTwoEnvelope","safeJsonParse","decrypt","error","encoding","BASE64","deserialized","deserialize","decodeTypeByte","toString","BASE16","KeyChain","privateKey","CRYPTO_CLIENT_SEED","e","p","y","k","R","g","l","i","IMessageTracker","MESSAGES_CONTEXT","MESSAGES_STORAGE_VERSION","messages","messagesWithoutClientAck","direction","hash","hashMessage","MESSAGE_DIRECTION","__spreadProps","__spreadValues","topics","IPublisher","relayer","EventEmitter","PUBLISHER_CONTEXT","toMiliseconds","ONE_MINUTE","ONE_SECOND","_a","PUBLISHER_DEFAULT_TTL","relay","getRelayProtocolName","prompt","id","getBigIntRpcId","failedPublishMessage","publishPromise","resolve","onPublish","RELAYER_EVENTS","initialPublish","createExpiringPromise","reject","event","listener","_b","_c","_d","attestation","tvf","request","getRelayProtocolApi","isUndefined","result","attempt","HEARTBEAT_EVENTS","a","n","ids","remaining","x","ISubscriber","SubscriberTopicMap","SUBSCRIBER_CONTEXT","SUBSCRIBER_STORAGE_VERSION","pendingSubscriptions","SUBSCRIBER_EVENTS","createdEvent","eventName","deletedEvent","reason","getSdkError","TRANSPORT_TYPES","shouldThrow","subId","subscribePromise","onSubscribe","subscription","err","subscriptions","s","subs","numOfBatches","batch","persisted","response","sleep","m","IRelayer","RELAYER_CONTEXT","isNode","RELAYER_PROVIDER_EVENTS","pino","getDefaultLoggerOptions","RELAYER_DEFAULT_LOGGER","MessageTracker","Subscriber","Publisher","RELAYER_DEFAULT_RELAY_URL","isAndroid","getAppId","isIos","shouldThrowOnFailure","resolvePromise","onSubCreated","relayUrl","isOnline","sortedMessages","messageEvent","expiry","calcExpiry","FIVE_MINUTES","pairing","onDisconnect","_e","auth","JsonRpcProvider","WsConnection","formatRelayRpcUrl","RELAYER_SDK_VERSION","exists","isJsonRpcRequest","RELAYER_SUBSCRIBER_SUFFIX","publishedAt","isJsonRpcResponse","formatJsonRpcResult","lastConnectedState","subscribeToNetworkChange","connected","isAppVisible","RELAYER_RECONNECT_TIMEOUT","u","IStore","name","storagePrefix","getKey","STORE_STORAGE_VERSION","value","isProposalStruct","isSessionStruct","filter","isEqual","update","PAIRING_CONTEXT","PAIRING_STORAGE_VERSION","TYPE_1","methods","RELAYER_DEFAULT_PROTOCOL","uri","formatUri","PAIRING_EVENTS","EVENT_CLIENT_PAIRING_TRACES","expiryTimestamp","parseUri","existingPairing","EVENT_CLIENT_PAIRING_ERRORS","done","createDelayedPromise","engineEvent","metadata","method","formatJsonRpcRequest","PAIRING_RPC_OPTS","formatJsonRpcError","expirerHasDeleted","expiredPairings","isExpired","resMethod","_topic","isJsonRpcResult","isJsonRpcError","isValidParams","isValidUrl","isValidString","Store","transportType","EXPIRER_EVENTS","parseExpirerTarget","IJsonRpcHistory","HISTORY_CONTEXT","HISTORY_STORAGE_VERSION","record","chainId","HISTORY_EVENTS","requests","requestEvent","records","deleted","IExpirer","EXPIRER_CONTEXT","EXPIRER_STORAGE_VERSION","expiration","target","formatTopicTarget","formatIdTarget","expirations","expiredEvent","IVerify","store","VERIFY_CONTEXT","VERIFY_SERVER_V3","CORE_VERSION","isBrowser","origin","decryptedId","src","document","getDocument","abortTimeout","attestationJwt","abortListener","iframe","data","decodeJWT","attestationId","encryptedId","validation","verifyUrl","url","timeout","VERIFY_SERVER","TRUSTED_VERIFY_URLS","newKey","verifyP256Jwt","isTestRun","timer","IEchoClient","projectId","ECHO_CONTEXT","clientId","token","notificationType","enableEncrypted","echoUrl","ECHO_URL","I","IEventClient","telemetryEnabled","EVENTS_STORAGE_CONTEXT","EVENTS_STORAGE_VERSION","initEvent","uuidv4","formatUA","trace","eventId","bundleId","timestamp","eventObj","fromMiliseconds","EVENTS_STORAGE_CLEANUP_INTERVAL","errorType","events","eventsToSend","_","platform","EVENTS_CLIENT_API_URL","getAppMetadata","Core","ICore","CORE_PROTOCOL","CORE_CONTEXT","sessionExists","globalCore","loggerOptions","CORE_DEFAULT","chunkLoggerController","generatePlatformLogger","HeartBeat","Crypto","JsonRpcHistory","Expirer","KeyValueStorage","CORE_STORAGE_OPTIONS","Relayer","Pairing","Verify","EchoClient","EventClient","WALLETCONNECT_CLIENT_ID","universalLink","WALLETCONNECT_LINK_MODE_APPS","customStoragePrefix","globalCorePrefix","counterKey","WalletConnectCore"],"mappings":"","debugId":null}},
    {"offset": {"line": 10578, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/sign-client/dist/index.es.js","sources":["file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/sign-client/src/constants/client.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/sign-client/src/constants/history.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/sign-client/src/constants/proposal.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/sign-client/src/constants/session.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/sign-client/src/constants/engine.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/sign-client/src/constants/pendingRequest.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/sign-client/src/constants/verify.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/sign-client/src/constants/auth.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/sign-client/src/controllers/engine.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/sign-client/src/controllers/proposal.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/sign-client/src/controllers/session.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/sign-client/src/controllers/pendingRequest.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/sign-client/src/controllers/authKey.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/sign-client/src/controllers/authPairingTopic.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/sign-client/src/controllers/authRequest.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/sign-client/src/controllers/authStore.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/sign-client/src/client.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/sign-client/src/index.ts"],"sourcesContent":["import { SignClientTypes } from \"@walletconnect/types\";\n\nexport const SIGN_CLIENT_PROTOCOL = \"wc\";\nexport const SIGN_CLIENT_VERSION = 2;\nexport const SIGN_CLIENT_CONTEXT = \"client\";\n\nexport const SIGN_CLIENT_STORAGE_PREFIX = `${SIGN_CLIENT_PROTOCOL}@${SIGN_CLIENT_VERSION}:${SIGN_CLIENT_CONTEXT}:`;\n\nexport const SIGN_CLIENT_DEFAULT = {\n  name: SIGN_CLIENT_CONTEXT,\n  logger: \"error\",\n  controller: false,\n  relayUrl: \"wss://relay.walletconnect.org\",\n};\n\nexport const SIGN_CLIENT_EVENTS: Record<SignClientTypes.Event, SignClientTypes.Event> = {\n  session_proposal: \"session_proposal\",\n  session_update: \"session_update\",\n  session_extend: \"session_extend\",\n  session_ping: \"session_ping\",\n  session_delete: \"session_delete\",\n  session_expire: \"session_expire\",\n  session_request: \"session_request\",\n  session_request_sent: \"session_request_sent\",\n  session_event: \"session_event\",\n  proposal_expire: \"proposal_expire\",\n  session_authenticate: \"session_authenticate\",\n  session_request_expire: \"session_request_expire\",\n  session_connect: \"session_connect\",\n};\n\nexport const SIGN_CLIENT_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n\nexport const WALLETCONNECT_DEEPLINK_CHOICE = \"WALLETCONNECT_DEEPLINK_CHOICE\";\n","export const HISTORY_EVENTS = {\n  created: \"history_created\",\n  updated: \"history_updated\",\n  deleted: \"history_deleted\",\n  sync: \"history_sync\",\n};\n\nexport const HISTORY_CONTEXT = \"history\";\n\nexport const HISTORY_STORAGE_VERSION = \"0.3\";\n","import { THIRTY_DAYS } from \"@walletconnect/time\";\n\nexport const PROPOSAL_CONTEXT = \"proposal\";\n\nexport const PROPOSAL_EXPIRY = THIRTY_DAYS;\n\nexport const PROPOSAL_EXPIRY_MESSAGE = \"Proposal expired\";\n","import { SEVEN_DAYS } from \"@walletconnect/time\";\n\nexport const SESSION_CONTEXT = \"session\";\n\nexport const SESSION_EXPIRY = SEVEN_DAYS;\n","import { FIVE_MINUTES, ONE_DAY, ONE_HOUR, SEVEN_DAYS } from \"@walletconnect/time\";\nimport { EngineTypes } from \"@walletconnect/types\";\n\nexport const ENGINE_CONTEXT = \"engine\";\n\nexport const ENGINE_RPC_OPTS: EngineTypes.RpcOptsMap = {\n  wc_sessionPropose: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1100,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1101,\n    },\n    reject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1120,\n    },\n    autoReject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1121,\n    },\n  },\n  wc_sessionSettle: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1102,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1103,\n    },\n  },\n  wc_sessionUpdate: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1104,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1105,\n    },\n  },\n  wc_sessionExtend: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1106,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1107,\n    },\n  },\n  wc_sessionRequest: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1108,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1109,\n    },\n  },\n  wc_sessionEvent: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1110,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1111,\n    },\n  },\n\n  wc_sessionDelete: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1112,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1113,\n    },\n  },\n  wc_sessionPing: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1114,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1115,\n    },\n  },\n  wc_sessionAuthenticate: {\n    req: {\n      ttl: ONE_HOUR,\n      prompt: true,\n      tag: 1116,\n    },\n    res: {\n      ttl: ONE_HOUR,\n      prompt: false,\n      tag: 1117,\n    },\n    reject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1118,\n    },\n    autoReject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1119,\n    },\n  },\n};\n\nexport const SESSION_REQUEST_EXPIRY_BOUNDARIES = {\n  min: FIVE_MINUTES,\n  max: SEVEN_DAYS,\n};\n\nexport const ENGINE_QUEUE_STATES: { idle: \"IDLE\"; active: \"ACTIVE\" } = {\n  idle: \"IDLE\",\n  active: \"ACTIVE\",\n};\n\nexport const TVF_METHODS = {\n  eth_sendTransaction: {\n    key: \"\",\n  },\n  eth_sendRawTransaction: {\n    key: \"\",\n  },\n  wallet_sendCalls: {\n    key: \"\",\n  },\n\n  solana_signTransaction: {\n    key: \"signature\",\n  },\n  solana_signAllTransactions: {\n    key: \"transactions\",\n  },\n  solana_signAndSendTransaction: {\n    key: \"signature\",\n  },\n};\n","export const REQUEST_CONTEXT = \"request\";\n","export const METHODS_TO_VERIFY = [\n  \"wc_sessionPropose\",\n  \"wc_sessionRequest\",\n  \"wc_authRequest\",\n  \"wc_sessionAuthenticate\",\n];\n","export const AUTH_PROTOCOL = \"wc\";\nexport const AUTH_VERSION = 1.5;\nexport const AUTH_CONTEXT = \"auth\";\nexport const AUTH_KEYS_CONTEXT = \"authKeys\";\nexport const AUTH_PAIRING_TOPIC_CONTEXT = \"pairingTopics\";\nexport const AUTH_REQUEST_CONTEXT = \"requests\";\n\nexport const AUTH_STORAGE_PREFIX = `${AUTH_PROTOCOL}@${AUTH_VERSION}:${AUTH_CONTEXT}:`;\nexport const AUTH_PUBLIC_KEY_NAME = `${AUTH_STORAGE_PREFIX}:PUB_KEY`;\n","/* eslint-disable no-console */\nimport {\n  EVENT_CLIENT_AUTHENTICATE_ERRORS,\n  EVENT_CLIENT_AUTHENTICATE_TRACES,\n  EVENT_CLIENT_PAIRING_ERRORS,\n  EVENT_CLIENT_PAIRING_TRACES,\n  EVENT_CLIENT_SESSION_ERRORS,\n  EVENT_CLIENT_SESSION_TRACES,\n  EXPIRER_EVENTS,\n  PAIRING_EVENTS,\n  RELAYER_DEFAULT_PROTOCOL,\n  RELAYER_EVENTS,\n  TRANSPORT_TYPES,\n  VERIFY_SERVER,\n} from \"@walletconnect/core\";\n\nimport {\n  formatJsonRpcError,\n  formatJsonRpcRequest,\n  formatJsonRpcResult,\n  payloadId,\n  isJsonRpcError,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  isJsonRpcResult,\n  JsonRpcRequest,\n  ErrorResponse,\n  getBigIntRpcId,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { FIVE_MINUTES, ONE_SECOND, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  EnginePrivate,\n  EngineTypes,\n  ExpirerTypes,\n  IEngine,\n  IEngineEvents,\n  JsonRpcTypes,\n  PendingRequestTypes,\n  Verify,\n  CoreTypes,\n  ProposalTypes,\n  RelayerTypes,\n  SessionTypes,\n  PairingTypes,\n  AuthTypes,\n  EventClientTypes,\n} from \"@walletconnect/types\";\nimport {\n  calcExpiry,\n  createDelayedPromise,\n  engineEvent,\n  getInternalError,\n  getSdkError,\n  isConformingNamespaces,\n  isExpired,\n  isSessionCompatible,\n  isUndefined,\n  isValidController,\n  isValidErrorReason,\n  isValidEvent,\n  isValidId,\n  isValidNamespaces,\n  isValidNamespacesChainId,\n  isValidNamespacesEvent,\n  isValidNamespacesRequest,\n  isValidObject,\n  isValidParams,\n  isValidRelay,\n  isValidRelays,\n  isValidRequest,\n  isValidRequestExpiry,\n  hashMessage,\n  isValidRequiredNamespaces,\n  isValidResponse,\n  isValidString,\n  parseExpirerTarget,\n  TYPE_1,\n  TYPE_2,\n  handleDeeplinkRedirect,\n  MemoryStore,\n  getDeepLink,\n  hashKey,\n  getDidAddress,\n  formatMessage,\n  getMethodsFromRecap,\n  buildNamespacesFromAuth,\n  createEncodedRecap,\n  getChainsFromRecap,\n  mergeEncodedRecaps,\n  getRecapFromResources,\n  validateSignedCacao,\n  getNamespacedDidChainId,\n  parseChainId,\n  getLinkModeURL,\n  BASE64,\n  BASE64URL,\n  getSearchParamFromURL,\n  isReactNative,\n  isTestRun,\n  isValidArray,\n  extractSolanaTransactionId,\n  mergeRequiredAndOptionalNamespaces,\n} from \"@walletconnect/utils\";\nimport EventEmmiter from \"events\";\nimport {\n  ENGINE_CONTEXT,\n  ENGINE_RPC_OPTS,\n  PROPOSAL_EXPIRY_MESSAGE,\n  SESSION_EXPIRY,\n  SESSION_REQUEST_EXPIRY_BOUNDARIES,\n  METHODS_TO_VERIFY,\n  WALLETCONNECT_DEEPLINK_CHOICE,\n  ENGINE_QUEUE_STATES,\n  AUTH_PUBLIC_KEY_NAME,\n  TVF_METHODS,\n} from \"../constants\";\n\nexport class Engine extends IEngine {\n  public name = ENGINE_CONTEXT;\n\n  private events: IEngineEvents = new EventEmmiter();\n  private initialized = false;\n\n  /**\n   * Queue responsible for processing incoming requests such as session_update, session_event, session_ping etc\n   * It's needed when the client receives multiple requests at once from the mailbox immediately after initialization and to avoid attempting to process them all at the same time\n   */\n  private requestQueue: EngineTypes.EngineQueue<EngineTypes.EventCallback<JsonRpcRequest>> = {\n    state: ENGINE_QUEUE_STATES.idle,\n    queue: [],\n  };\n\n  /**\n   * Queue responsible for processing incoming session_request\n   * The queue emits the next request only after the previous one has been responded to\n   */\n  private sessionRequestQueue: EngineTypes.EngineQueue<PendingRequestTypes.Struct> = {\n    state: ENGINE_QUEUE_STATES.idle,\n    queue: [],\n  };\n\n  private requestQueueDelay = ONE_SECOND;\n  private expectedPairingMethodMap: Map<string, string[]> = new Map();\n  // Ephemeral (in-memory) map to store recently deleted items\n  private recentlyDeletedMap = new Map<\n    string | number,\n    \"pairing\" | \"session\" | \"proposal\" | \"request\"\n  >();\n\n  private recentlyDeletedLimit = 200;\n  private relayMessageCache: RelayerTypes.MessageEvent[] = [];\n  private pendingSessions: Map<\n    number,\n    {\n      sessionTopic: string;\n      pairingTopic: string;\n      proposalId: number;\n      publicKey: string;\n    }\n  > = new Map();\n\n  constructor(client: IEngine[\"client\"]) {\n    super(client);\n  }\n\n  public init: IEngine[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.cleanup();\n      this.registerRelayerEvents();\n      this.registerExpirerEvents();\n      this.registerPairingEvents();\n      await this.registerLinkModeListeners();\n      this.client.core.pairing.register({ methods: Object.keys(ENGINE_RPC_OPTS) });\n      this.initialized = true;\n      setTimeout(async () => {\n        await this.processPendingMessageEvents();\n\n        this.sessionRequestQueue.queue = this.getPendingSessionRequests();\n        this.processSessionRequestQueue();\n      }, toMiliseconds(this.requestQueueDelay));\n    }\n  };\n\n  private async processPendingMessageEvents() {\n    try {\n      const topics = this.client.session.keys;\n      const pendingMessages = this.client.core.relayer.messages.getWithoutAck(topics);\n      for (const [topic, messages] of Object.entries(pendingMessages)) {\n        for (const message of messages) {\n          try {\n            await this.onProviderMessageEvent({\n              topic,\n              message,\n              publishedAt: Date.now(),\n            });\n          } catch (error) {\n            this.client.logger.warn(\n              `Error processing pending message event for topic: ${topic}, message: ${message}`,\n            );\n          }\n        }\n      }\n    } catch (error) {\n      this.client.logger.warn(\"processPendingMessageEvents failed\", error);\n    }\n  }\n\n  // ---------- Public ------------------------------------------------ //\n\n  public connect: IEngine[\"connect\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    const connectParams = {\n      ...params,\n      requiredNamespaces: params.requiredNamespaces || {},\n      optionalNamespaces: params.optionalNamespaces || {},\n    };\n    await this.isValidConnect(connectParams);\n\n    // requiredNamespaces are deprecated, assign them to optionalNamespaces\n    connectParams.optionalNamespaces = mergeRequiredAndOptionalNamespaces(\n      connectParams.requiredNamespaces,\n      connectParams.optionalNamespaces,\n    );\n\n    connectParams.requiredNamespaces = {};\n\n    const {\n      pairingTopic,\n      requiredNamespaces,\n      optionalNamespaces,\n      sessionProperties,\n      scopedProperties,\n      relays,\n    } = connectParams;\n    let topic = pairingTopic;\n    let uri: string | undefined;\n    let active = false;\n    try {\n      if (topic) {\n        const pairing = this.client.core.pairing.pairings.get(topic);\n        this.client.logger.warn(\n          \"connect() with existing pairing topic is deprecated and will be removed in the next major release.\",\n        );\n        active = pairing.active;\n      }\n    } catch (error) {\n      this.client.logger.error(`connect() -> pairing.get(${topic}) failed`);\n      throw error;\n    }\n    if (!topic || !active) {\n      const { topic: newTopic, uri: newUri } = await this.client.core.pairing.create();\n      topic = newTopic;\n      uri = newUri;\n    }\n    // safety check to ensure pairing topic is available\n    if (!topic) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `connect() pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n\n    const publicKey = await this.client.core.crypto.generateKeyPair();\n\n    const expiry = ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl || FIVE_MINUTES;\n    const expiryTimestamp = calcExpiry(expiry);\n    const proposal = {\n      requiredNamespaces,\n      optionalNamespaces,\n      relays: relays ?? [{ protocol: RELAYER_DEFAULT_PROTOCOL }],\n      proposer: {\n        publicKey,\n        metadata: this.client.metadata,\n      },\n      expiryTimestamp,\n      pairingTopic: topic,\n      ...(sessionProperties && { sessionProperties }),\n      ...(scopedProperties && { scopedProperties }),\n      id: payloadId(),\n    };\n    const sessionConnectTarget = engineEvent(\"session_connect\", proposal.id);\n\n    const {\n      reject,\n      resolve,\n      done: approval,\n    } = createDelayedPromise<SessionTypes.Struct>(expiry, PROPOSAL_EXPIRY_MESSAGE);\n\n    const proposalExpireHandler = ({ id }: { id: number }) => {\n      if (id === proposal.id) {\n        this.client.events.off(\"proposal_expire\", proposalExpireHandler);\n        this.pendingSessions.delete(proposal.id);\n        // emit the event to trigger reject, this approach automatically cleans up the .once listener below\n        this.events.emit(sessionConnectTarget, {\n          error: { message: PROPOSAL_EXPIRY_MESSAGE, code: 0 },\n        });\n      }\n    };\n\n    this.client.events.on(\"proposal_expire\", proposalExpireHandler);\n    this.events.once<\"session_connect\">(sessionConnectTarget, ({ error, session }) => {\n      this.client.events.off(\"proposal_expire\", proposalExpireHandler);\n      if (error) reject(error);\n      else if (session) {\n        resolve(session);\n      }\n    });\n\n    await this.sendRequest({\n      topic,\n      method: \"wc_sessionPropose\",\n      params: proposal,\n      throwOnFailedPublish: true,\n      clientRpcId: proposal.id,\n    });\n\n    await this.setProposal(proposal.id, proposal);\n    return { uri, approval };\n  };\n\n  public pair: IEngine[\"pair\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      return await this.client.core.pairing.pair(params);\n    } catch (error) {\n      this.client.logger.error(\"pair() failed\");\n      throw error;\n    }\n  };\n\n  public approve: IEngine[\"approve\"] = async (params) => {\n    const configEvent = this.client.core.eventClient.createEvent({\n      properties: {\n        topic: params?.id?.toString(),\n        trace: [EVENT_CLIENT_SESSION_TRACES.session_approve_started],\n      },\n    });\n    try {\n      this.isInitialized();\n      await this.confirmOnlineStateOrThrow();\n    } catch (error) {\n      configEvent.setError(EVENT_CLIENT_SESSION_ERRORS.no_internet_connection);\n      throw error;\n    }\n    try {\n      await this.isValidProposalId(params?.id);\n    } catch (error) {\n      this.client.logger.error(`approve() -> proposal.get(${params?.id}) failed`);\n      configEvent.setError(EVENT_CLIENT_SESSION_ERRORS.proposal_not_found);\n      throw error;\n    }\n\n    try {\n      await this.isValidApprove(params);\n    } catch (error) {\n      this.client.logger.error(\"approve() -> isValidApprove() failed\");\n      configEvent.setError(\n        EVENT_CLIENT_SESSION_ERRORS.session_approve_namespace_validation_failure,\n      );\n      throw error;\n    }\n\n    const { id, relayProtocol, namespaces, sessionProperties, scopedProperties, sessionConfig } =\n      params;\n\n    const proposal = this.client.proposal.get(id);\n\n    this.client.core.eventClient.deleteEvent({ eventId: configEvent.eventId });\n\n    const { pairingTopic, proposer, requiredNamespaces, optionalNamespaces } = proposal;\n\n    let event = this.client.core.eventClient?.getEvent({\n      topic: pairingTopic,\n    }) as EventClientTypes.Event;\n    if (!event) {\n      event = this.client.core.eventClient?.createEvent({\n        type: EVENT_CLIENT_SESSION_TRACES.session_approve_started,\n        properties: {\n          topic: pairingTopic,\n          trace: [\n            EVENT_CLIENT_SESSION_TRACES.session_approve_started,\n            EVENT_CLIENT_SESSION_TRACES.session_namespaces_validation_success,\n          ],\n        },\n      });\n    }\n\n    const selfPublicKey = await this.client.core.crypto.generateKeyPair();\n    const peerPublicKey = proposer.publicKey;\n    const sessionTopic = await this.client.core.crypto.generateSharedKey(\n      selfPublicKey,\n      peerPublicKey,\n    );\n    const sessionSettle = {\n      relay: { protocol: relayProtocol ?? \"irn\" },\n      namespaces,\n      controller: { publicKey: selfPublicKey, metadata: this.client.metadata },\n      expiry: calcExpiry(SESSION_EXPIRY),\n      ...(sessionProperties && { sessionProperties }),\n      ...(scopedProperties && { scopedProperties }),\n      ...(sessionConfig && { sessionConfig }),\n    };\n    const transportType = TRANSPORT_TYPES.relay;\n    event.addTrace(EVENT_CLIENT_SESSION_TRACES.subscribing_session_topic);\n    try {\n      await this.client.core.relayer.subscribe(sessionTopic, { transportType });\n    } catch (error) {\n      event.setError(EVENT_CLIENT_SESSION_ERRORS.subscribe_session_topic_failure);\n      throw error;\n    }\n\n    event.addTrace(EVENT_CLIENT_SESSION_TRACES.subscribe_session_topic_success);\n\n    const session = {\n      ...sessionSettle,\n      topic: sessionTopic,\n      requiredNamespaces,\n      optionalNamespaces,\n      pairingTopic,\n      acknowledged: false,\n      self: sessionSettle.controller,\n      peer: {\n        publicKey: proposer.publicKey,\n        metadata: proposer.metadata,\n      },\n      controller: selfPublicKey,\n      transportType: TRANSPORT_TYPES.relay,\n    };\n    await this.client.session.set(sessionTopic, session);\n\n    event.addTrace(EVENT_CLIENT_SESSION_TRACES.store_session);\n\n    try {\n      event.addTrace(EVENT_CLIENT_SESSION_TRACES.publishing_session_settle);\n      await this.sendRequest({\n        topic: sessionTopic,\n        method: \"wc_sessionSettle\",\n        params: sessionSettle,\n        throwOnFailedPublish: true,\n      }).catch((error) => {\n        event?.setError(EVENT_CLIENT_SESSION_ERRORS.session_settle_publish_failure);\n        throw error;\n      });\n\n      event.addTrace(EVENT_CLIENT_SESSION_TRACES.session_settle_publish_success);\n\n      event.addTrace(EVENT_CLIENT_SESSION_TRACES.publishing_session_approve);\n      await this.sendResult<\"wc_sessionPropose\">({\n        id,\n        topic: pairingTopic,\n        result: {\n          relay: {\n            protocol: relayProtocol ?? \"irn\",\n          },\n          responderPublicKey: selfPublicKey,\n        },\n        throwOnFailedPublish: true,\n      }).catch((error) => {\n        event?.setError(EVENT_CLIENT_SESSION_ERRORS.session_approve_publish_failure);\n        throw error;\n      });\n\n      event.addTrace(EVENT_CLIENT_SESSION_TRACES.session_approve_publish_success);\n    } catch (error) {\n      this.client.logger.error(error);\n      // if the publish fails, delete the session and throw an error\n      this.client.session.delete(sessionTopic, getSdkError(\"USER_DISCONNECTED\"));\n      await this.client.core.relayer.unsubscribe(sessionTopic);\n      throw error;\n    }\n\n    this.client.core.eventClient.deleteEvent({ eventId: event.eventId });\n\n    await this.client.core.pairing.updateMetadata({\n      topic: pairingTopic,\n      metadata: proposer.metadata,\n    });\n    await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n    await this.client.core.pairing.activate({ topic: pairingTopic });\n    await this.setExpiry(sessionTopic, calcExpiry(SESSION_EXPIRY));\n    return {\n      topic: sessionTopic,\n      acknowledged: () => Promise.resolve(this.client.session.get(sessionTopic)),\n    };\n  };\n\n  public reject: IEngine[\"reject\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidReject(params);\n    } catch (error) {\n      this.client.logger.error(\"reject() -> isValidReject() failed\");\n      throw error;\n    }\n    const { id, reason } = params;\n    let pairingTopic;\n    try {\n      const proposal = this.client.proposal.get(id);\n      pairingTopic = proposal.pairingTopic;\n    } catch (error) {\n      this.client.logger.error(`reject() -> proposal.get(${id}) failed`);\n      throw error;\n    }\n\n    if (pairingTopic) {\n      await this.sendError({\n        id,\n        topic: pairingTopic,\n        error: reason,\n        rpcOpts: ENGINE_RPC_OPTS.wc_sessionPropose.reject,\n      });\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n    }\n  };\n\n  public update: IEngine[\"update\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidUpdate(params);\n    } catch (error) {\n      this.client.logger.error(\"update() -> isValidUpdate() failed\");\n      throw error;\n    }\n    const { topic, namespaces } = params;\n\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    const clientRpcId = payloadId();\n    const relayRpcId = getBigIntRpcId().toString() as any;\n\n    const oldNamespaces = this.client.session.get(topic).namespaces;\n    this.events.once(engineEvent(\"session_update\", clientRpcId), ({ error }: any) => {\n      if (error) reject(error);\n      else {\n        resolve();\n      }\n    });\n    // Update the session with the new namespaces, if the publish fails, revert to the old.\n    // This allows the client to use the updated session like emitting events\n    // without waiting for the peer to acknowledge\n    await this.client.session.update(topic, { namespaces });\n    await this.sendRequest({\n      topic,\n      method: \"wc_sessionUpdate\",\n      params: { namespaces },\n      throwOnFailedPublish: true,\n      clientRpcId,\n      relayRpcId,\n    }).catch((error) => {\n      this.client.logger.error(error);\n      this.client.session.update(topic, { namespaces: oldNamespaces });\n      reject(error);\n    });\n    return { acknowledged };\n  };\n\n  public extend: IEngine[\"extend\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidExtend(params);\n    } catch (error) {\n      this.client.logger.error(\"extend() -> isValidExtend() failed\");\n      throw error;\n    }\n\n    const { topic } = params;\n    const clientRpcId = payloadId();\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    this.events.once(engineEvent(\"session_extend\", clientRpcId), ({ error }: any) => {\n      if (error) reject(error);\n      else resolve();\n    });\n\n    await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n    this.sendRequest({\n      topic,\n      method: \"wc_sessionExtend\",\n      params: {},\n      clientRpcId,\n      throwOnFailedPublish: true,\n    }).catch((e) => {\n      reject(e);\n    });\n\n    return { acknowledged };\n  };\n\n  public request: IEngine[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    this.isInitialized();\n    try {\n      await this.isValidRequest(params);\n    } catch (error) {\n      this.client.logger.error(\"request() -> isValidRequest() failed\");\n      throw error;\n    }\n    const { chainId, request, topic, expiry = ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl } = params;\n    const session = this.client.session.get(topic);\n\n    if (session?.transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n    const clientRpcId = payloadId();\n    const relayRpcId = getBigIntRpcId().toString() as any;\n    const { done, resolve, reject } = createDelayedPromise<T>(\n      expiry,\n      \"Request expired. Please try again.\",\n    );\n    this.events.once<\"session_request\">(\n      engineEvent(\"session_request\", clientRpcId),\n      ({ error, result }) => {\n        if (error) reject(error);\n        else resolve(result);\n      },\n    );\n    const protocolMethod = \"wc_sessionRequest\";\n    const appLink = this.getAppLinkIfEnabled(session.peer.metadata, session.transportType);\n    if (appLink) {\n      await this.sendRequest({\n        clientRpcId,\n        relayRpcId,\n        topic,\n        method: protocolMethod,\n        params: {\n          request: {\n            ...request,\n            expiryTimestamp: calcExpiry(expiry),\n          },\n          chainId,\n        },\n        expiry,\n        throwOnFailedPublish: true,\n        appLink,\n      }).catch((error) => reject(error));\n\n      this.client.events.emit(\"session_request_sent\", {\n        topic,\n        request,\n        chainId,\n        id: clientRpcId,\n      });\n      const result = await done();\n      return result;\n    }\n\n    const protocolRequestParams: JsonRpcTypes.RequestParams[\"wc_sessionRequest\"] = {\n      request: {\n        ...request,\n        expiryTimestamp: calcExpiry(expiry),\n      },\n      chainId,\n    };\n    const shouldSetTVF = this.shouldSetTVF(protocolMethod, protocolRequestParams);\n\n    return await Promise.all([\n      new Promise<void>(async (resolve) => {\n        await this.sendRequest({\n          clientRpcId,\n          relayRpcId,\n          topic,\n          method: protocolMethod,\n          params: protocolRequestParams,\n          expiry,\n          throwOnFailedPublish: true,\n          ...(shouldSetTVF && {\n            tvf: this.getTVFParams(clientRpcId, protocolRequestParams),\n          }),\n        }).catch((error) => reject(error));\n        this.client.events.emit(\"session_request_sent\", {\n          topic,\n          request,\n          chainId,\n          id: clientRpcId,\n        });\n        resolve();\n      }),\n      new Promise<void>(async (resolve) => {\n        // only attempt to handle deeplinks if they are not explicitly disabled in the session config\n        if (!session.sessionConfig?.disableDeepLink) {\n          const wcDeepLink = (await getDeepLink(\n            this.client.core.storage,\n            WALLETCONNECT_DEEPLINK_CHOICE,\n          )) as string;\n          await handleDeeplinkRedirect({ id: clientRpcId, topic, wcDeepLink });\n        }\n        resolve();\n      }),\n      done(),\n    ]).then((result) => result[2]); // order is important here, we want to return the result of the `done` promise\n  };\n\n  public respond: IEngine[\"respond\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidRespond(params);\n    const { topic, response } = params;\n    const { id } = response;\n    const session = this.client.session.get(topic);\n\n    if (session.transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const appLink = this.getAppLinkIfEnabled(session.peer.metadata, session.transportType);\n    if (isJsonRpcResult(response)) {\n      await this.sendResult({\n        id,\n        topic,\n        result: response.result,\n        throwOnFailedPublish: true,\n        appLink,\n      });\n    } else if (isJsonRpcError(response)) {\n      await this.sendError({ id, topic, error: response.error, appLink });\n    }\n    this.cleanupAfterResponse(params);\n  };\n\n  public ping: IEngine[\"ping\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    try {\n      await this.isValidPing(params);\n    } catch (error) {\n      this.client.logger.error(\"ping() -> isValidPing() failed\");\n      throw error;\n    }\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      const clientRpcId = payloadId();\n      const relayRpcId = getBigIntRpcId().toString() as any;\n      const { done, resolve, reject } = createDelayedPromise<void>();\n      this.events.once(engineEvent(\"session_ping\", clientRpcId), ({ error }: any) => {\n        if (error) reject(error);\n        else resolve();\n      });\n      await Promise.all([\n        this.sendRequest({\n          topic,\n          method: \"wc_sessionPing\",\n          params: {},\n          throwOnFailedPublish: true,\n          clientRpcId,\n          relayRpcId,\n        }),\n        done(),\n      ]);\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      this.client.logger.warn(\n        \"ping() on pairing topic is deprecated and will be removed in the next major release.\",\n      );\n      await this.client.core.pairing.ping({ topic });\n    }\n  };\n\n  public emit: IEngine[\"emit\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    await this.isValidEmit(params);\n    const { topic, event, chainId } = params;\n    const relayRpcId = getBigIntRpcId().toString() as any;\n    const clientRpcId = payloadId();\n    await this.sendRequest({\n      topic,\n      method: \"wc_sessionEvent\",\n      params: { event, chainId },\n      throwOnFailedPublish: true,\n      relayRpcId,\n      clientRpcId,\n    });\n  };\n\n  public disconnect: IEngine[\"disconnect\"] = async (params) => {\n    this.isInitialized();\n    await this.confirmOnlineStateOrThrow();\n    await this.isValidDisconnect(params);\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      // await an ack to ensure the relay has received the disconnect request\n      await this.sendRequest({\n        topic,\n        method: \"wc_sessionDelete\",\n        params: getSdkError(\"USER_DISCONNECTED\"),\n        throwOnFailedPublish: true,\n      });\n      await this.deleteSession({ topic, emitEvent: false });\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      await this.client.core.pairing.disconnect({ topic });\n    } else {\n      const { message } = getInternalError(\n        \"MISMATCHED_TOPIC\",\n        `Session or pairing topic not found: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  public find: IEngine[\"find\"] = (params) => {\n    this.isInitialized();\n    return this.client.session.getAll().filter((session) => isSessionCompatible(session, params));\n  };\n\n  public getPendingSessionRequests: IEngine[\"getPendingSessionRequests\"] = () => {\n    return this.client.pendingRequest.getAll();\n  };\n\n  // ---------- Auth ------------------------------------------------ //\n\n  public authenticate: IEngine[\"authenticate\"] = async (params, walletUniversalLink) => {\n    this.isInitialized();\n    this.isValidAuthenticate(params);\n\n    const isLinkMode =\n      walletUniversalLink &&\n      this.client.core.linkModeSupportedApps.includes(walletUniversalLink) &&\n      this.client.metadata.redirect?.linkMode;\n\n    const transportType: RelayerTypes.TransportType = isLinkMode\n      ? TRANSPORT_TYPES.link_mode\n      : TRANSPORT_TYPES.relay;\n\n    if (transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const {\n      chains,\n      statement = \"\",\n      uri,\n      domain,\n      nonce,\n      type,\n      exp,\n      nbf,\n      methods = [],\n      expiry,\n    } = params;\n    // reassign resources to remove reference as the array is modified and might cause side effects\n    const resources = [...(params.resources || [])];\n\n    const { topic: pairingTopic, uri: connectionUri } = await this.client.core.pairing.create({\n      methods: [\"wc_sessionAuthenticate\"],\n      transportType,\n    });\n\n    this.client.logger.info({\n      message: \"Generated new pairing\",\n      pairing: { topic: pairingTopic, uri: connectionUri },\n    });\n\n    const publicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(publicKey);\n\n    await Promise.all([\n      this.client.auth.authKeys.set(AUTH_PUBLIC_KEY_NAME, { responseTopic, publicKey }),\n      this.client.auth.pairingTopics.set(responseTopic, { topic: responseTopic, pairingTopic }),\n    ]);\n\n    // Subscribe to response topic\n    await this.client.core.relayer.subscribe(responseTopic, { transportType });\n\n    this.client.logger.info(`sending request to new pairing topic: ${pairingTopic}`);\n\n    if (methods.length > 0) {\n      const { namespace } = parseChainId(chains[0]);\n      let recap = createEncodedRecap(namespace, \"request\", methods);\n      const existingRecap = getRecapFromResources(resources);\n      if (existingRecap) {\n        // per Recaps spec, recap must occupy the last position in the resources array\n        // using .pop to remove the element given we already checked it's a recap and will replace it\n        const mergedRecap = mergeEncodedRecaps(recap, resources.pop() as string);\n        recap = mergedRecap;\n      }\n      resources.push(recap);\n    }\n\n    // Ensure the expiry is greater than the minimum required for the request - currently 1h\n    const authRequestExpiry =\n      expiry && expiry > ENGINE_RPC_OPTS.wc_sessionAuthenticate.req.ttl\n        ? expiry\n        : ENGINE_RPC_OPTS.wc_sessionAuthenticate.req.ttl;\n\n    const request: AuthTypes.SessionAuthenticateRequestParams = {\n      authPayload: {\n        type: type ?? \"caip122\",\n        chains,\n        statement,\n        aud: uri,\n        domain,\n        version: \"1\",\n        nonce,\n        iat: new Date().toISOString(),\n        exp,\n        nbf,\n        resources,\n      },\n      requester: { publicKey, metadata: this.client.metadata },\n      expiryTimestamp: calcExpiry(authRequestExpiry),\n    };\n\n    // ----- build namespaces for fallback session proposal ----- //\n    const namespaces = {\n      eip155: {\n        chains,\n        // request `personal_sign` method by default to allow for fallback siwe\n        methods: [...new Set([\"personal_sign\", ...methods])],\n        events: [\"chainChanged\", \"accountsChanged\"],\n      },\n    };\n\n    const proposal = {\n      requiredNamespaces: {},\n      optionalNamespaces: namespaces,\n      relays: [{ protocol: \"irn\" }],\n      pairingTopic,\n      proposer: {\n        publicKey,\n        metadata: this.client.metadata,\n      },\n      expiryTimestamp: calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl),\n      id: payloadId(),\n    };\n\n    const { done, resolve, reject } = createDelayedPromise(authRequestExpiry, \"Request expired\");\n\n    const authenticateId = payloadId();\n    const sessionConnectEventTarget = engineEvent(\"session_connect\", proposal.id);\n    const authenticateEventTarget = engineEvent(\"session_request\", authenticateId);\n\n    // handle fallback session proposal response\n    const onSessionConnect = async ({ error, session }: any) => {\n      // cleanup listener for authenticate response\n      this.events.off(authenticateEventTarget, onAuthenticate);\n      if (error) reject(error);\n      else if (session) {\n        resolve({\n          session,\n        });\n      }\n    };\n    // handle session authenticate response\n    const onAuthenticate = async (payload: any) => {\n      // delete this auth request on response\n      // we're using payload from the wallet to establish the session so we don't need to keep this around\n      await this.deletePendingAuthRequest(authenticateId, { message: \"fulfilled\", code: 0 });\n      if (payload.error) {\n        // wallets that do not support wc_sessionAuthenticate will return an error\n        // we should not reject the promise in this case as the fallback session proposal will be used\n        const error = getSdkError(\"WC_METHOD_UNSUPPORTED\", \"wc_sessionAuthenticate\");\n        if (payload.error.code === error.code) return;\n\n        // cleanup listener for fallback response\n        this.events.off(sessionConnectEventTarget, onSessionConnect);\n        return reject(payload.error.message);\n      }\n      // delete fallback proposal on successful authenticate as the proposal will not be responded to\n      await this.deleteProposal(proposal.id);\n      // cleanup listener for fallback response\n      this.events.off(sessionConnectEventTarget, onSessionConnect);\n\n      const {\n        cacaos,\n        responder,\n      }: {\n        cacaos: AuthTypes.SessionAuthenticateResponseParams[\"cacaos\"];\n        responder: AuthTypes.SessionAuthenticateResponseParams[\"responder\"];\n      } = payload.result;\n\n      const approvedMethods: string[] = [];\n      const approvedAccounts: string[] = [];\n      for (const cacao of cacaos) {\n        const isValid = await validateSignedCacao({ cacao, projectId: this.client.core.projectId });\n        if (!isValid) {\n          this.client.logger.error(cacao, \"Signature verification failed\");\n          reject(getSdkError(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\"));\n        }\n\n        const { p: payload } = cacao;\n        const recap = getRecapFromResources(payload.resources);\n\n        const approvedChains: string[] = [getNamespacedDidChainId(payload.iss) as string];\n        const parsedAddress = getDidAddress(payload.iss) as string;\n\n        if (recap) {\n          const methodsfromRecap = getMethodsFromRecap(recap);\n          const chainsFromRecap = getChainsFromRecap(recap);\n          approvedMethods.push(...methodsfromRecap);\n          approvedChains.push(...chainsFromRecap);\n        }\n\n        for (const chain of approvedChains) {\n          approvedAccounts.push(`${chain}:${parsedAddress}`);\n        }\n      }\n      const sessionTopic = await this.client.core.crypto.generateSharedKey(\n        publicKey,\n        responder.publicKey,\n      );\n\n      //create session object\n      let session: SessionTypes.Struct | undefined;\n\n      if (approvedMethods.length > 0) {\n        session = {\n          topic: sessionTopic,\n          acknowledged: true,\n          self: {\n            publicKey,\n            metadata: this.client.metadata,\n          },\n          peer: responder,\n          controller: responder.publicKey,\n          expiry: calcExpiry(SESSION_EXPIRY),\n          requiredNamespaces: {},\n          optionalNamespaces: {},\n          relay: { protocol: \"irn\" },\n          pairingTopic,\n          namespaces: buildNamespacesFromAuth(\n            [...new Set(approvedMethods)],\n            [...new Set(approvedAccounts)],\n          ),\n          transportType,\n        };\n\n        await this.client.core.relayer.subscribe(sessionTopic, { transportType });\n        await this.client.session.set(sessionTopic, session);\n        if (pairingTopic) {\n          await this.client.core.pairing.updateMetadata({\n            topic: pairingTopic,\n            metadata: responder.metadata,\n          });\n        }\n\n        session = this.client.session.get(sessionTopic);\n      }\n\n      if (\n        this.client.metadata.redirect?.linkMode &&\n        responder.metadata.redirect?.linkMode &&\n        responder.metadata.redirect?.universal &&\n        walletUniversalLink\n      ) {\n        // save wallet link in array of apps that support linkMode\n        this.client.core.addLinkModeSupportedApp(responder.metadata.redirect.universal);\n\n        this.client.session.update(sessionTopic, {\n          transportType: TRANSPORT_TYPES.link_mode,\n        });\n      }\n\n      resolve({\n        auths: cacaos,\n        session,\n      });\n    };\n\n    // subscribe to response events\n    this.events.once<\"session_connect\">(sessionConnectEventTarget, onSessionConnect);\n    this.events.once(authenticateEventTarget, onAuthenticate);\n\n    let linkModeURL;\n    try {\n      if (isLinkMode) {\n        const payload = formatJsonRpcRequest(\"wc_sessionAuthenticate\", request, authenticateId);\n        this.client.core.history.set(pairingTopic, payload);\n        const message = await this.client.core.crypto.encode(\"\", payload, {\n          type: TYPE_2,\n          encoding: BASE64URL,\n        });\n        linkModeURL = getLinkModeURL(walletUniversalLink, pairingTopic, message);\n      } else {\n        // send both (main & fallback) requests\n        await Promise.all([\n          this.sendRequest({\n            topic: pairingTopic,\n            method: \"wc_sessionAuthenticate\",\n            params: request,\n            expiry: params.expiry,\n            throwOnFailedPublish: true,\n            clientRpcId: authenticateId,\n          }),\n          this.sendRequest({\n            topic: pairingTopic,\n            method: \"wc_sessionPropose\",\n            params: proposal,\n            expiry: ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl,\n            throwOnFailedPublish: true,\n            clientRpcId: proposal.id,\n          }),\n        ]);\n      }\n    } catch (error) {\n      // cleanup listeners on failed publish\n      this.events.off(sessionConnectEventTarget, onSessionConnect);\n      this.events.off(authenticateEventTarget, onAuthenticate);\n      throw error;\n    }\n\n    await this.setProposal(proposal.id, proposal);\n    await this.setAuthRequest(authenticateId, {\n      request: {\n        ...request,\n        verifyContext: {} as any,\n      },\n      pairingTopic,\n      transportType,\n    });\n\n    return {\n      uri: linkModeURL ?? connectionUri,\n      response: done,\n    } as EngineTypes.SessionAuthenticateResponsePromise;\n  };\n\n  public approveSessionAuthenticate: IEngine[\"approveSessionAuthenticate\"] = async (\n    sessionAuthenticateResponseParams,\n  ) => {\n    const { id, auths } = sessionAuthenticateResponseParams;\n\n    const event = this.client.core.eventClient.createEvent({\n      properties: {\n        topic: id.toString(),\n        trace: [EVENT_CLIENT_AUTHENTICATE_TRACES.authenticated_session_approve_started],\n      },\n    });\n\n    try {\n      this.isInitialized();\n    } catch (error) {\n      event.setError(EVENT_CLIENT_AUTHENTICATE_ERRORS.no_internet_connection);\n      throw error;\n    }\n\n    const pendingRequest = this.getPendingAuthRequest(id);\n\n    if (!pendingRequest) {\n      event.setError(\n        EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_pending_request_not_found,\n      );\n      throw new Error(`Could not find pending auth request with id ${id}`);\n    }\n\n    const transportType = pendingRequest.transportType || TRANSPORT_TYPES.relay;\n    if (transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const receiverPublicKey = pendingRequest.requester.publicKey;\n    const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(receiverPublicKey);\n\n    const encodeOpts = {\n      type: TYPE_1,\n      receiverPublicKey,\n      senderPublicKey,\n    };\n\n    const approvedMethods: string[] = [];\n    const approvedAccounts: string[] = [];\n    for (const cacao of auths) {\n      const isValid = await validateSignedCacao({ cacao, projectId: this.client.core.projectId });\n      if (!isValid) {\n        event.setError(EVENT_CLIENT_AUTHENTICATE_ERRORS.invalid_cacao);\n\n        const invalidErr = getSdkError(\n          \"SESSION_SETTLEMENT_FAILED\",\n          \"Signature verification failed\",\n        );\n\n        await this.sendError({\n          id,\n          topic: responseTopic,\n          error: invalidErr,\n          encodeOpts,\n        });\n\n        throw new Error(invalidErr.message);\n      }\n\n      event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.cacaos_verified);\n\n      const { p: payload } = cacao;\n      const recap = getRecapFromResources(payload.resources);\n\n      const approvedChains: string[] = [getNamespacedDidChainId(payload.iss) as string];\n\n      const parsedAddress = getDidAddress(payload.iss) as string;\n\n      if (recap) {\n        const methodsfromRecap = getMethodsFromRecap(recap);\n        const chainsFromRecap = getChainsFromRecap(recap);\n        approvedMethods.push(...methodsfromRecap);\n        approvedChains.push(...chainsFromRecap);\n      }\n      for (const chain of approvedChains) {\n        approvedAccounts.push(`${chain}:${parsedAddress}`);\n      }\n    }\n\n    const sessionTopic = await this.client.core.crypto.generateSharedKey(\n      senderPublicKey,\n      receiverPublicKey,\n    );\n\n    event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.create_authenticated_session_topic);\n\n    let session: SessionTypes.Struct | undefined;\n    if (approvedMethods?.length > 0) {\n      session = {\n        topic: sessionTopic,\n        acknowledged: true,\n        self: {\n          publicKey: senderPublicKey,\n          metadata: this.client.metadata,\n        },\n        peer: {\n          publicKey: receiverPublicKey,\n          metadata: pendingRequest.requester.metadata,\n        },\n        controller: receiverPublicKey,\n        expiry: calcExpiry(SESSION_EXPIRY),\n        authentication: auths,\n        requiredNamespaces: {},\n        optionalNamespaces: {},\n        relay: { protocol: \"irn\" },\n        pairingTopic: pendingRequest.pairingTopic,\n        namespaces: buildNamespacesFromAuth(\n          [...new Set(approvedMethods)],\n          [...new Set(approvedAccounts)],\n        ),\n        transportType,\n      };\n\n      event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.subscribing_authenticated_session_topic);\n\n      try {\n        await this.client.core.relayer.subscribe(sessionTopic, { transportType });\n      } catch (error) {\n        event.setError(\n          EVENT_CLIENT_AUTHENTICATE_ERRORS.subscribe_authenticated_session_topic_failure,\n        );\n        throw error;\n      }\n\n      event.addTrace(\n        EVENT_CLIENT_AUTHENTICATE_TRACES.subscribe_authenticated_session_topic_success,\n      );\n\n      await this.client.session.set(sessionTopic, session);\n\n      event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.store_authenticated_session);\n\n      await this.client.core.pairing.updateMetadata({\n        topic: pendingRequest.pairingTopic,\n        metadata: pendingRequest.requester.metadata,\n      });\n    }\n\n    event.addTrace(EVENT_CLIENT_AUTHENTICATE_TRACES.publishing_authenticated_session_approve);\n\n    try {\n      await this.sendResult<\"wc_sessionAuthenticate\">({\n        topic: responseTopic,\n        id,\n        result: {\n          cacaos: auths,\n          responder: {\n            publicKey: senderPublicKey,\n            metadata: this.client.metadata,\n          },\n        },\n        encodeOpts,\n        throwOnFailedPublish: true,\n        appLink: this.getAppLinkIfEnabled(pendingRequest.requester.metadata, transportType),\n      });\n    } catch (error) {\n      event.setError(\n        EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_approve_publish_failure,\n      );\n      throw error;\n    }\n\n    await this.client.auth.requests.delete(id, { message: \"fulfilled\", code: 0 });\n    await this.client.core.pairing.activate({ topic: pendingRequest.pairingTopic });\n    this.client.core.eventClient.deleteEvent({ eventId: event.eventId });\n\n    return { session };\n  };\n\n  public rejectSessionAuthenticate: IEngine[\"rejectSessionAuthenticate\"] = async (params) => {\n    this.isInitialized();\n\n    const { id, reason } = params;\n\n    const pendingRequest = this.getPendingAuthRequest(id);\n\n    if (!pendingRequest) {\n      throw new Error(`Could not find pending auth request with id ${id}`);\n    }\n\n    if (pendingRequest.transportType === TRANSPORT_TYPES.relay) {\n      await this.confirmOnlineStateOrThrow();\n    }\n\n    const receiverPublicKey = pendingRequest.requester.publicKey;\n    const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(receiverPublicKey);\n\n    const encodeOpts = {\n      type: TYPE_1,\n      receiverPublicKey,\n      senderPublicKey,\n    };\n\n    await this.sendError({\n      id,\n      topic: responseTopic,\n      error: reason,\n      encodeOpts,\n      rpcOpts: ENGINE_RPC_OPTS.wc_sessionAuthenticate.reject,\n      appLink: this.getAppLinkIfEnabled(\n        pendingRequest.requester.metadata,\n        pendingRequest.transportType,\n      ),\n    });\n    await this.client.auth.requests.delete(id, { message: \"rejected\", code: 0 });\n    await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n  };\n\n  public formatAuthMessage: IEngine[\"formatAuthMessage\"] = (params) => {\n    this.isInitialized();\n    const { request, iss } = params;\n    return formatMessage(request, iss);\n  };\n\n  public processRelayMessageCache: IEngine[\"processRelayMessageCache\"] = () => {\n    // process the relay messages cache in the next tick to allow event listeners to be registered by the implementing app\n    setTimeout(async () => {\n      if (this.relayMessageCache.length === 0) return;\n      while (this.relayMessageCache.length > 0) {\n        try {\n          const message = this.relayMessageCache.shift();\n          if (message) {\n            await this.onRelayMessage(message);\n          }\n        } catch (error) {\n          this.client.logger.error(error);\n        }\n      }\n    }, 50);\n  };\n\n  // ---------- Private Helpers --------------------------------------- //\n\n  private cleanupDuplicatePairings: EnginePrivate[\"cleanupDuplicatePairings\"] = async (\n    session: SessionTypes.Struct,\n  ) => {\n    // older SDK versions are missing the `pairingTopic` prop thus we need to check for it\n    if (!session.pairingTopic) return;\n\n    try {\n      const pairing = this.client.core.pairing.pairings.get(session.pairingTopic);\n      const allPairings = this.client.core.pairing.pairings.getAll();\n      const duplicates = allPairings.filter(\n        (p) =>\n          p.peerMetadata?.url &&\n          p.peerMetadata?.url === session.peer.metadata.url &&\n          p.topic &&\n          p.topic !== pairing.topic,\n      );\n      if (duplicates.length === 0) return;\n      this.client.logger.info(`Cleaning up ${duplicates.length} duplicate pairing(s)`);\n      await Promise.all(\n        duplicates.map((p) => this.client.core.pairing.disconnect({ topic: p.topic })),\n      );\n      this.client.logger.info(`Duplicate pairings clean up finished`);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  };\n\n  private deleteSession: EnginePrivate[\"deleteSession\"] = async (params) => {\n    const { topic, expirerHasDeleted = false, emitEvent = true, id = 0 } = params;\n    const { self } = this.client.session.get(topic);\n    // Await the unsubscribe first to avoid deleting the symKey too early below.\n    await this.client.core.relayer.unsubscribe(topic);\n    await this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n    this.addToRecentlyDeleted(topic, \"session\");\n    if (this.client.core.crypto.keychain.has(self.publicKey)) {\n      await this.client.core.crypto.deleteKeyPair(self.publicKey);\n    }\n    if (this.client.core.crypto.keychain.has(topic)) {\n      await this.client.core.crypto.deleteSymKey(topic);\n    }\n    if (!expirerHasDeleted) this.client.core.expirer.del(topic);\n    // remove any deeplinks from storage after the session is deleted\n    // to avoid navigating to incorrect deeplink later on\n    this.client.core.storage\n      .removeItem(WALLETCONNECT_DEEPLINK_CHOICE)\n      .catch((e) => this.client.logger.warn(e));\n    this.getPendingSessionRequests().forEach((r) => {\n      if (r.topic === topic) {\n        this.deletePendingSessionRequest(r.id, getSdkError(\"USER_DISCONNECTED\"));\n      }\n    });\n    // reset the queue state back to idle if a request for the deleted session is still in the queue\n    if (topic === this.sessionRequestQueue.queue[0]?.topic) {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n    }\n    if (emitEvent) this.client.events.emit(\"session_delete\", { id, topic });\n  };\n\n  private deleteProposal: EnginePrivate[\"deleteProposal\"] = async (id, expirerHasDeleted) => {\n    if (expirerHasDeleted) {\n      try {\n        const proposal = this.client.proposal.get(id);\n        const event = this.client.core.eventClient.getEvent({ topic: proposal.pairingTopic });\n        event?.setError(EVENT_CLIENT_SESSION_ERRORS.proposal_expired);\n      } catch (error) {}\n    }\n    await Promise.all([\n      this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\")),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n    this.addToRecentlyDeleted(id, \"proposal\");\n  };\n\n  private deletePendingSessionRequest: EnginePrivate[\"deletePendingSessionRequest\"] = async (\n    id,\n    reason,\n    expirerHasDeleted = false,\n  ) => {\n    await Promise.all([\n      this.client.pendingRequest.delete(id, reason),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n    this.addToRecentlyDeleted(id, \"request\");\n    this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((r) => r.id !== id);\n    if (expirerHasDeleted) {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n      this.client.events.emit(\"session_request_expire\", { id });\n    }\n  };\n\n  private deletePendingAuthRequest: EnginePrivate[\"deletePendingAuthRequest\"] = async (\n    id,\n    reason,\n    expirerHasDeleted = false,\n  ) => {\n    await Promise.all([\n      this.client.auth.requests.delete(id, reason),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n  };\n\n  private setExpiry: EnginePrivate[\"setExpiry\"] = async (topic, expiry) => {\n    if (!this.client.session.keys.includes(topic)) return;\n    this.client.core.expirer.set(topic, expiry);\n    await this.client.session.update(topic, { expiry });\n  };\n\n  private setProposal: EnginePrivate[\"setProposal\"] = async (id, proposal) => {\n    this.client.core.expirer.set(id, calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl));\n    await this.client.proposal.set(id, proposal);\n  };\n\n  private setAuthRequest: EnginePrivate[\"setAuthRequest\"] = async (id, params) => {\n    const { request, pairingTopic, transportType = TRANSPORT_TYPES.relay } = params;\n    this.client.core.expirer.set(id, request.expiryTimestamp);\n    await this.client.auth.requests.set(id, {\n      authPayload: request.authPayload,\n      requester: request.requester,\n      expiryTimestamp: request.expiryTimestamp,\n      id,\n      pairingTopic,\n      verifyContext: request.verifyContext,\n      transportType,\n    });\n  };\n\n  private setPendingSessionRequest: EnginePrivate[\"setPendingSessionRequest\"] = async (\n    pendingRequest: PendingRequestTypes.Struct,\n  ) => {\n    const { id, topic, params, verifyContext } = pendingRequest;\n    const expiry =\n      params.request.expiryTimestamp || calcExpiry(ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl);\n    this.client.core.expirer.set(id, expiry);\n    await this.client.pendingRequest.set(id, {\n      id,\n      topic,\n      params,\n      verifyContext,\n    });\n  };\n\n  private sendRequest: EnginePrivate[\"sendRequest\"] = async (args) => {\n    const {\n      topic,\n      method,\n      params,\n      expiry,\n      relayRpcId,\n      clientRpcId,\n      throwOnFailedPublish,\n      appLink,\n      tvf,\n    } = args;\n    const payload = formatJsonRpcRequest(method, params, clientRpcId);\n\n    let message: string;\n    const isLinkMode = !!appLink;\n\n    try {\n      const encoding = isLinkMode ? BASE64URL : BASE64;\n      message = await this.client.core.crypto.encode(topic, payload, { encoding });\n    } catch (error) {\n      await this.cleanup();\n      this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${topic} failed`);\n      throw error;\n    }\n\n    let attestation: string | undefined;\n    if (METHODS_TO_VERIFY.includes(method)) {\n      const decryptedId = hashMessage(JSON.stringify(payload));\n      const id = hashMessage(message);\n      attestation = await this.client.core.verify.register({ id, decryptedId });\n    }\n    const opts = ENGINE_RPC_OPTS[method].req;\n    opts.attestation = attestation;\n    if (expiry) opts.ttl = expiry;\n    if (relayRpcId) opts.id = relayRpcId;\n    this.client.core.history.set(topic, payload);\n\n    if (isLinkMode) {\n      const redirectURL = getLinkModeURL(appLink, topic, message);\n      await (global as any).Linking.openURL(redirectURL, this.client.name);\n    } else {\n      const opts = ENGINE_RPC_OPTS[method].req;\n      if (expiry) opts.ttl = expiry;\n      if (relayRpcId) opts.id = relayRpcId;\n\n      opts.tvf = {\n        ...tvf,\n        correlationId: payload.id,\n      };\n\n      if (throwOnFailedPublish) {\n        opts.internal = {\n          ...opts.internal,\n          throwOnFailedPublish: true,\n        };\n        await this.client.core.relayer.publish(topic, message, opts);\n      } else {\n        this.client.core.relayer\n          .publish(topic, message, opts)\n          .catch((error) => this.client.logger.error(error));\n      }\n    }\n\n    return payload.id;\n  };\n\n  private sendResult: EnginePrivate[\"sendResult\"] = async (args) => {\n    const { id, topic, result, throwOnFailedPublish, encodeOpts, appLink } = args;\n    const payload = formatJsonRpcResult(id, result);\n    let message;\n    const isLinkMode = appLink && typeof (global as any)?.Linking !== \"undefined\";\n\n    try {\n      const encoding = isLinkMode ? BASE64URL : BASE64;\n      message = await this.client.core.crypto.encode(topic, payload, {\n        ...(encodeOpts || {}),\n        encoding,\n      });\n    } catch (error) {\n      // if encoding fails e.g. due to missing keychain, we want to cleanup all related data as its unusable\n      await this.cleanup();\n      this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${topic} failed`);\n      throw error;\n    }\n    let record;\n    let tvf;\n    try {\n      record = await this.client.core.history.get(topic, id);\n      const request = record.request;\n      try {\n        if (this.shouldSetTVF(request.method as JsonRpcTypes.WcMethod, request.params)) {\n          tvf = this.getTVFParams(id, request.params, result);\n        }\n      } catch (error) {\n        this.client.logger.warn(`sendResult() -> getTVFParams() failed`, error);\n      }\n    } catch (error) {\n      this.client.logger.error(`sendResult() -> history.get(${topic}, ${id}) failed`);\n      throw error;\n    }\n\n    if (isLinkMode) {\n      const redirectURL = getLinkModeURL(appLink, topic, message);\n      await (global as any).Linking.openURL(redirectURL, this.client.name);\n    } else {\n      const method = record.request.method as JsonRpcTypes.WcMethod;\n      const opts = ENGINE_RPC_OPTS[method].res;\n\n      opts.tvf = {\n        ...tvf,\n        correlationId: id,\n      };\n\n      if (throwOnFailedPublish) {\n        opts.internal = {\n          ...opts.internal,\n          throwOnFailedPublish: true,\n        };\n        await this.client.core.relayer.publish(topic, message, opts);\n      } else {\n        this.client.core.relayer\n          .publish(topic, message, opts)\n          .catch((error) => this.client.logger.error(error));\n      }\n    }\n\n    await this.client.core.history.resolve(payload);\n  };\n\n  private sendError: EnginePrivate[\"sendError\"] = async (params) => {\n    const { id, topic, error, encodeOpts, rpcOpts, appLink } = params;\n    const payload = formatJsonRpcError(id, error);\n    let message;\n    const isLinkMode = appLink && typeof (global as any)?.Linking !== \"undefined\";\n    try {\n      const encoding = isLinkMode ? BASE64URL : BASE64;\n      message = await this.client.core.crypto.encode(topic, payload, {\n        ...(encodeOpts || {}),\n        encoding,\n      });\n    } catch (error) {\n      await this.cleanup();\n      this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${topic} failed`);\n      throw error;\n    }\n    let record;\n    try {\n      record = await this.client.core.history.get(topic, id);\n    } catch (error) {\n      this.client.logger.error(`sendError() -> history.get(${topic}, ${id}) failed`);\n      throw error;\n    }\n\n    if (isLinkMode) {\n      const redirectURL = getLinkModeURL(appLink, topic, message);\n      await (global as any).Linking.openURL(redirectURL, this.client.name);\n    } else {\n      const method = record.request.method as JsonRpcTypes.WcMethod;\n      const opts = rpcOpts || ENGINE_RPC_OPTS[method].res;\n      // await is intentionally omitted to speed up performance\n      this.client.core.relayer.publish(topic, message, opts);\n    }\n\n    await this.client.core.history.resolve(payload);\n  };\n\n  private cleanup: EnginePrivate[\"cleanup\"] = async () => {\n    const sessionTopics: string[] = [];\n    const proposalIds: number[] = [];\n    this.client.session.getAll().forEach((session) => {\n      let toCleanup = false;\n      if (isExpired(session.expiry)) toCleanup = true;\n      if (!this.client.core.crypto.keychain.has(session.topic)) toCleanup = true;\n      if (toCleanup) sessionTopics.push(session.topic);\n    });\n    this.client.proposal.getAll().forEach((proposal) => {\n      if (isExpired(proposal.expiryTimestamp)) proposalIds.push(proposal.id);\n    });\n    await Promise.all([\n      ...sessionTopics.map((topic) => this.deleteSession({ topic })),\n      ...proposalIds.map((id) => this.deleteProposal(id)),\n    ]);\n  };\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  private async confirmOnlineStateOrThrow() {\n    await this.client.core.relayer.confirmOnlineStateOrThrow();\n  }\n\n  // ---------- Relay Events Router ----------------------------------- //\n\n  private registerRelayerEvents() {\n    this.client.core.relayer.on(RELAYER_EVENTS.message, (event: RelayerTypes.MessageEvent) => {\n      this.onProviderMessageEvent(event);\n    });\n  }\n\n  private onProviderMessageEvent = async (event: RelayerTypes.MessageEvent) => {\n    // capture any messages that arrive before the client is initialized so we can process them after initialization is complete\n    if (!this.initialized || this.relayMessageCache.length > 0) {\n      this.relayMessageCache.push(event);\n    } else {\n      await this.onRelayMessage(event);\n    }\n  };\n\n  private async onRelayMessage(event: RelayerTypes.MessageEvent) {\n    const { topic, message, attestation, transportType } = event;\n\n    // Retrieve the public key (if defined) to decrypt possible `auth_request` response\n    const { publicKey } = this.client.auth.authKeys.keys.includes(AUTH_PUBLIC_KEY_NAME)\n      ? this.client.auth.authKeys.get(AUTH_PUBLIC_KEY_NAME)\n      : ({ responseTopic: undefined, publicKey: undefined } as any);\n\n    try {\n      const payload = await this.client.core.crypto.decode(topic, message, {\n        receiverPublicKey: publicKey,\n        encoding: transportType === TRANSPORT_TYPES.link_mode ? BASE64URL : BASE64,\n      });\n\n      if (isJsonRpcRequest(payload)) {\n        this.client.core.history.set(topic, payload);\n        await this.onRelayEventRequest({\n          topic,\n          payload,\n          attestation,\n          transportType,\n          encryptedId: hashMessage(message),\n        });\n      } else if (isJsonRpcResponse(payload)) {\n        await this.client.core.history.resolve(payload);\n        await this.onRelayEventResponse({ topic, payload, transportType });\n        this.client.core.history.delete(topic, payload.id);\n      } else {\n        await this.onRelayEventUnknownPayload({ topic, payload, transportType });\n      }\n      await this.client.core.relayer.messages.ack(topic, message);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  }\n\n  private onRelayEventRequest: EnginePrivate[\"onRelayEventRequest\"] = async (event) => {\n    this.requestQueue.queue.push(event);\n    await this.processRequestsQueue();\n  };\n\n  private processRequestsQueue = async () => {\n    if (this.requestQueue.state === ENGINE_QUEUE_STATES.active) {\n      this.client.logger.info(`Request queue already active, skipping...`);\n      return;\n    }\n\n    this.client.logger.info(\n      `Request queue starting with ${this.requestQueue.queue.length} requests`,\n    );\n\n    while (this.requestQueue.queue.length > 0) {\n      this.requestQueue.state = ENGINE_QUEUE_STATES.active;\n      const request = this.requestQueue.queue.shift();\n      if (!request) continue;\n\n      try {\n        await this.processRequest(request);\n      } catch (error) {\n        this.client.logger.warn(error);\n      }\n    }\n    this.requestQueue.state = ENGINE_QUEUE_STATES.idle;\n  };\n\n  private processRequest: EnginePrivate[\"onRelayEventRequest\"] = async (event) => {\n    const { topic, payload, attestation, transportType, encryptedId } = event;\n\n    const reqMethod = payload.method as JsonRpcTypes.WcMethod;\n\n    if (this.shouldIgnorePairingRequest({ topic, requestMethod: reqMethod })) {\n      return;\n    }\n\n    switch (reqMethod) {\n      case \"wc_sessionPropose\":\n        return await this.onSessionProposeRequest({ topic, payload, attestation, encryptedId });\n      case \"wc_sessionSettle\":\n        return await this.onSessionSettleRequest(topic, payload);\n      case \"wc_sessionUpdate\":\n        return await this.onSessionUpdateRequest(topic, payload);\n      case \"wc_sessionExtend\":\n        return await this.onSessionExtendRequest(topic, payload);\n      case \"wc_sessionPing\":\n        return await this.onSessionPingRequest(topic, payload);\n      case \"wc_sessionDelete\":\n        return await this.onSessionDeleteRequest(topic, payload);\n      case \"wc_sessionRequest\":\n        return await this.onSessionRequest({\n          topic,\n          payload,\n          attestation,\n          encryptedId,\n          transportType,\n        });\n      case \"wc_sessionEvent\":\n        return await this.onSessionEventRequest(topic, payload);\n      case \"wc_sessionAuthenticate\":\n        return await this.onSessionAuthenticateRequest({\n          topic,\n          payload,\n          attestation,\n          encryptedId,\n          transportType,\n        });\n      default:\n        return this.client.logger.info(`Unsupported request method ${reqMethod}`);\n    }\n  };\n\n  private onRelayEventResponse: EnginePrivate[\"onRelayEventResponse\"] = async (event) => {\n    const { topic, payload, transportType } = event;\n    const record = await this.client.core.history.get(topic, payload.id);\n    const resMethod = record.request.method as JsonRpcTypes.WcMethod;\n\n    switch (resMethod) {\n      case \"wc_sessionPropose\":\n        return this.onSessionProposeResponse(topic, payload, transportType);\n      case \"wc_sessionSettle\":\n        return this.onSessionSettleResponse(topic, payload);\n      case \"wc_sessionUpdate\":\n        return this.onSessionUpdateResponse(topic, payload);\n      case \"wc_sessionExtend\":\n        return this.onSessionExtendResponse(topic, payload);\n      case \"wc_sessionPing\":\n        return this.onSessionPingResponse(topic, payload);\n      case \"wc_sessionRequest\":\n        return this.onSessionRequestResponse(topic, payload);\n      case \"wc_sessionAuthenticate\":\n        return this.onSessionAuthenticateResponse(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported response method ${resMethod}`);\n    }\n  };\n\n  private onRelayEventUnknownPayload: EnginePrivate[\"onRelayEventUnknownPayload\"] = (event) => {\n    const { topic } = event;\n    const { message } = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `Decoded payload on topic ${topic} is not identifiable as a JSON-RPC request or a response.`,\n    );\n    throw new Error(message);\n  };\n\n  private shouldIgnorePairingRequest: EnginePrivate[\"shouldIgnorePairingRequest\"] = (params) => {\n    const { topic, requestMethod } = params;\n    const expectedMethods = this.expectedPairingMethodMap.get(topic);\n    // check if the request method matches the expected method\n    if (!expectedMethods) return false;\n    if (expectedMethods.includes(requestMethod)) return false;\n\n    /**\n     * we want to make sure fallback session proposal is ignored only if there are subscribers\n     * for the `session_authenticate` event, otherwise this would result in no-op for the user\n     */\n    if (expectedMethods.includes(\"wc_sessionAuthenticate\")) {\n      if (this.client.events.listenerCount(\"session_authenticate\") > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // ---------- Relay Events Handlers --------------------------------- //\n\n  private onSessionProposeRequest: EnginePrivate[\"onSessionProposeRequest\"] = async (args) => {\n    const { topic, payload, attestation, encryptedId } = args;\n    const { params, id } = payload;\n    try {\n      const event = this.client.core.eventClient.getEvent({ topic });\n\n      if (this.client.events.listenerCount(\"session_proposal\") === 0) {\n        console.warn(\"No listener for session_proposal event\");\n        event?.setError(EVENT_CLIENT_PAIRING_ERRORS.proposal_listener_not_found);\n      }\n\n      this.isValidConnect({ ...payload.params });\n      const expiryTimestamp =\n        params.expiryTimestamp || calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl);\n      const proposal = { id, pairingTopic: topic, expiryTimestamp, ...params };\n      await this.setProposal(id, proposal);\n\n      const verifyContext = await this.getVerifyContext({\n        attestationId: attestation,\n        hash: hashMessage(JSON.stringify(payload)),\n        encryptedId,\n        metadata: proposal.proposer.metadata,\n      });\n\n      event?.addTrace(EVENT_CLIENT_PAIRING_TRACES.emit_session_proposal);\n\n      this.client.events.emit(\"session_proposal\", { id, params: proposal, verifyContext });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n        rpcOpts: ENGINE_RPC_OPTS.wc_sessionPropose.autoReject,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionProposeResponse: EnginePrivate[\"onSessionProposeResponse\"] = async (\n    topic,\n    payload,\n    transportType,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      const { result } = payload;\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", result });\n      const proposal = this.client.proposal.get(id);\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", proposal });\n      const selfPublicKey = proposal.proposer.publicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        selfPublicKey,\n      });\n      const peerPublicKey = result.responderPublicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        peerPublicKey,\n      });\n      const sessionTopic = await this.client.core.crypto.generateSharedKey(\n        selfPublicKey,\n        peerPublicKey,\n      );\n      this.pendingSessions.set(id, {\n        sessionTopic,\n        pairingTopic: topic,\n        proposalId: id,\n        publicKey: selfPublicKey,\n      });\n\n      const subscriptionId = await this.client.core.relayer.subscribe(sessionTopic, {\n        transportType,\n      });\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        subscriptionId,\n      });\n      await this.client.core.pairing.activate({ topic });\n    } else if (isJsonRpcError(payload)) {\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n      const target = engineEvent(\"session_connect\", id);\n      const listeners = this.events.listenerCount(target);\n      if (listeners === 0) {\n        throw new Error(`emitting ${target} without any listeners, 954`);\n      }\n      this.events.emit(target, { error: payload.error });\n    }\n  };\n\n  private onSessionSettleRequest: EnginePrivate[\"onSessionSettleRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      this.isValidSessionSettleRequest(params);\n      const {\n        relay,\n        controller,\n        expiry,\n        namespaces,\n        sessionProperties,\n        scopedProperties,\n        sessionConfig,\n      } = payload.params;\n      const pendingSession = [...this.pendingSessions.values()].find(\n        (s) => s.sessionTopic === topic,\n      );\n\n      if (!pendingSession) {\n        return this.client.logger.error(`Pending session not found for topic ${topic}`);\n      }\n\n      const proposal = this.client.proposal.get(pendingSession.proposalId);\n\n      const session: SessionTypes.Struct = {\n        topic,\n        relay,\n        expiry,\n        namespaces,\n        acknowledged: true,\n        pairingTopic: pendingSession.pairingTopic,\n        requiredNamespaces: proposal.requiredNamespaces,\n        optionalNamespaces: proposal.optionalNamespaces,\n        controller: controller.publicKey,\n        self: {\n          publicKey: pendingSession.publicKey,\n          metadata: this.client.metadata,\n        },\n        peer: {\n          publicKey: controller.publicKey,\n          metadata: controller.metadata,\n        },\n        ...(sessionProperties && { sessionProperties }),\n        ...(scopedProperties && { scopedProperties }),\n        ...(sessionConfig && { sessionConfig }),\n        transportType: TRANSPORT_TYPES.relay,\n      };\n\n      await this.client.session.set(session.topic, session);\n      await this.setExpiry(session.topic, session.expiry);\n\n      await this.client.core.pairing.updateMetadata({\n        topic: pendingSession.pairingTopic,\n        metadata: session.peer.metadata,\n      });\n\n      this.client.events.emit(\"session_connect\", { session });\n      this.events.emit(engineEvent(\"session_connect\", pendingSession.proposalId), { session });\n\n      this.pendingSessions.delete(pendingSession.proposalId);\n      this.deleteProposal(pendingSession.proposalId, false);\n      this.cleanupDuplicatePairings(session);\n\n      await this.sendResult<\"wc_sessionSettle\">({\n        id: payload.id,\n        topic,\n        result: true,\n        throwOnFailedPublish: true,\n      });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionSettleResponse: EnginePrivate[\"onSessionSettleResponse\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      await this.client.session.update(topic, { acknowledged: true });\n      this.events.emit(engineEvent(\"session_approve\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      await this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n      this.events.emit(engineEvent(\"session_approve\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionUpdateRequest: EnginePrivate[\"onSessionUpdateRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { params, id } = payload;\n    try {\n      const memoryKey = `${topic}_session_update`;\n      // compare the current request id with the last processed session update\n      // we want to update only if the request is newer than the last processed one\n      const lastSessionUpdateId = MemoryStore.get<number>(memoryKey);\n\n      if (lastSessionUpdateId && this.isRequestOutOfSync(lastSessionUpdateId, id)) {\n        this.client.logger.warn(`Discarding out of sync request - ${id}`);\n        this.sendError({ id, topic, error: getSdkError(\"INVALID_UPDATE_REQUEST\") });\n        return;\n      }\n      this.isValidUpdate({ topic, ...params });\n      try {\n        MemoryStore.set(memoryKey, id);\n        await this.client.session.update(topic, { namespaces: params.namespaces });\n        await this.sendResult<\"wc_sessionUpdate\">({\n          id,\n          topic,\n          result: true,\n          throwOnFailedPublish: true,\n        });\n      } catch (e) {\n        MemoryStore.delete(memoryKey);\n        throw e;\n      }\n\n      this.client.events.emit(\"session_update\", { id, topic, params });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  // compares the timestamp of the last processed request with the current request\n  // client <-> client rpc ID is timestamp + 3 random digits\n  private isRequestOutOfSync = (lastId: number, currentId: number) => {\n    return currentId.toString().slice(0, -3) < lastId.toString().slice(0, -3);\n  };\n\n  private onSessionUpdateResponse: EnginePrivate[\"onSessionUpdateResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_update\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionExtendRequest: EnginePrivate[\"onSessionExtendRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidExtend({ topic });\n      await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n      await this.sendResult<\"wc_sessionExtend\">({\n        id,\n        topic,\n        result: true,\n        throwOnFailedPublish: true,\n      });\n      this.client.events.emit(\"session_extend\", { id, topic });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionExtendResponse: EnginePrivate[\"onSessionExtendResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_extend\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionPingRequest: EnginePrivate[\"onSessionPingRequest\"] = async (topic, payload) => {\n    const { id } = payload;\n    try {\n      this.isValidPing({ topic });\n      await this.sendResult<\"wc_sessionPing\">({\n        id,\n        topic,\n        result: true,\n        throwOnFailedPublish: true,\n      });\n      this.client.events.emit(\"session_ping\", { id, topic });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionPingResponse: EnginePrivate[\"onSessionPingResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_ping\", id);\n\n    // put at the end of the stack to avoid a race condition\n    // where session_ping listener is not yet initialized\n    setTimeout(() => {\n      const listeners = this.events.listenerCount(target);\n      if (listeners === 0) {\n        throw new Error(`emitting ${target} without any listeners 2176`);\n      }\n\n      if (isJsonRpcResult(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), {});\n      } else if (isJsonRpcError(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), { error: payload.error });\n      }\n    }, 500);\n  };\n\n  private onSessionDeleteRequest: EnginePrivate[\"onSessionDeleteRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidDisconnect({ topic, reason: payload.params });\n      Promise.all([\n        new Promise((resolve) => {\n          // RPC request needs to happen before deletion as it utalises session encryption\n          this.client.core.relayer.once(RELAYER_EVENTS.publish, async () => {\n            resolve(await this.deleteSession({ topic, id }));\n          });\n        }),\n        this.sendResult<\"wc_sessionDelete\">({\n          id,\n          topic,\n          result: true,\n          throwOnFailedPublish: true,\n        }),\n        this.cleanupPendingSentRequestsForTopic({ topic, error: getSdkError(\"USER_DISCONNECTED\") }),\n      ]).catch((err) => this.client.logger.error(err));\n    } catch (err: any) {\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequest: EnginePrivate[\"onSessionRequest\"] = async (args) => {\n    const { topic, payload, attestation, encryptedId, transportType } = args;\n    const { id, params } = payload;\n    try {\n      await this.isValidRequest({ topic, ...params });\n      const session = this.client.session.get(topic);\n      const verifyContext = await this.getVerifyContext({\n        attestationId: attestation,\n        hash: hashMessage(JSON.stringify(formatJsonRpcRequest(\"wc_sessionRequest\", params, id))),\n        encryptedId,\n        metadata: session.peer.metadata,\n        transportType,\n      });\n      const request = {\n        id,\n        topic,\n        params,\n        verifyContext,\n      };\n      await this.setPendingSessionRequest(request);\n\n      if (\n        transportType === TRANSPORT_TYPES.link_mode &&\n        session.peer.metadata.redirect?.universal\n      ) {\n        // save app as supported for link mode\n        this.client.core.addLinkModeSupportedApp(session.peer.metadata.redirect?.universal);\n      }\n\n      if (this.client.signConfig?.disableRequestQueue) {\n        this.emitSessionRequest(request);\n      } else {\n        this.addSessionRequestToSessionRequestQueue(request);\n        this.processSessionRequestQueue();\n      }\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequestResponse: EnginePrivate[\"onSessionRequestResponse\"] = (\n    _topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_request\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { result: payload.result });\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionEventRequest: EnginePrivate[\"onSessionEventRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      // similar to session update, we want to discard out of sync requests\n      // additionally we have to check the event type as well e.g. chainChanged/accountsChanged\n      const memoryKey = `${topic}_session_event_${params.event.name}`;\n      // compare the current request id with the last processed session update\n      // we want to update only if the request is newer than the last processed one\n      const lastSessionUpdateId = MemoryStore.get<number>(memoryKey);\n      if (lastSessionUpdateId && this.isRequestOutOfSync(lastSessionUpdateId, id)) {\n        this.client.logger.info(`Discarding out of sync request - ${id}`);\n        return;\n      }\n\n      this.isValidEmit({ topic, ...params });\n      this.client.events.emit(\"session_event\", { id, topic, params });\n      MemoryStore.set(memoryKey, id);\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionAuthenticateResponse: EnginePrivate[\"onSessionAuthenticateResponse\"] = (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    this.client.logger.trace({\n      type: \"method\",\n      method: \"onSessionAuthenticateResponse\",\n      topic,\n      payload,\n    });\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { result: payload.result });\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionAuthenticateRequest: EnginePrivate[\"onSessionAuthenticateRequest\"] = async (\n    args,\n  ) => {\n    const { topic, payload, attestation, encryptedId, transportType } = args;\n    try {\n      const { requester, authPayload, expiryTimestamp } = payload.params;\n      const verifyContext = await this.getVerifyContext({\n        attestationId: attestation,\n        hash: hashMessage(JSON.stringify(payload)),\n        encryptedId,\n        metadata: requester.metadata,\n        transportType,\n      });\n      const pendingRequest = {\n        requester,\n        pairingTopic: topic,\n        id: payload.id,\n        authPayload,\n        verifyContext,\n        expiryTimestamp,\n      };\n      await this.setAuthRequest(payload.id, {\n        request: pendingRequest,\n        pairingTopic: topic,\n        transportType,\n      });\n\n      if (transportType === TRANSPORT_TYPES.link_mode && requester.metadata.redirect?.universal) {\n        // save app as supported for link mode\n        this.client.core.addLinkModeSupportedApp(requester.metadata.redirect.universal);\n      }\n\n      this.client.events.emit(\"session_authenticate\", {\n        topic,\n        params: payload.params,\n        id: payload.id,\n        verifyContext,\n      });\n    } catch (err: any) {\n      this.client.logger.error(err);\n\n      const receiverPublicKey = payload.params.requester.publicKey;\n      const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n      const appLink = this.getAppLinkIfEnabled(payload.params.requester.metadata, transportType);\n\n      const encodeOpts = {\n        type: TYPE_1,\n        receiverPublicKey,\n        senderPublicKey,\n      };\n      await this.sendError({\n        id: payload.id,\n        topic,\n        error: err,\n        encodeOpts,\n        rpcOpts: ENGINE_RPC_OPTS.wc_sessionAuthenticate.autoReject,\n        appLink,\n      });\n    }\n  };\n\n  private addSessionRequestToSessionRequestQueue = (request: PendingRequestTypes.Struct) => {\n    this.sessionRequestQueue.queue.push(request);\n  };\n\n  private cleanupAfterResponse = (params: EngineTypes.RespondParams) => {\n    this.deletePendingSessionRequest(params.response.id, { message: \"fulfilled\", code: 0 });\n    // intentionally delay the emitting of the next pending request a bit\n    setTimeout(() => {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n      this.processSessionRequestQueue();\n    }, toMiliseconds(this.requestQueueDelay));\n  };\n\n  // Allows for cleanup on any sent pending requests if the peer disconnects the session before responding\n  private cleanupPendingSentRequestsForTopic = ({\n    topic,\n    error,\n  }: {\n    topic: string;\n    error: ErrorResponse;\n  }) => {\n    const pendingRequests = this.client.core.history.pending;\n    if (pendingRequests.length > 0) {\n      const forSession = pendingRequests.filter(\n        (r) => r.topic === topic && r.request.method === \"wc_sessionRequest\",\n      );\n      forSession.forEach((r) => {\n        const id = r.request.id;\n        const target = engineEvent(\"session_request\", id);\n        const listeners = this.events.listenerCount(target);\n        if (listeners === 0) {\n          throw new Error(`emitting ${target} without any listeners`);\n        }\n        // notify .request() handler of the rejection\n        this.events.emit(engineEvent(\"session_request\", r.request.id), {\n          error,\n        });\n      });\n    }\n  };\n\n  private processSessionRequestQueue = () => {\n    if (this.sessionRequestQueue.state === ENGINE_QUEUE_STATES.active) {\n      this.client.logger.info(\"session request queue is already active.\");\n      return;\n    }\n    // Select the first/oldest request in the array to ensure last-in-first-out (LIFO)\n    const request = this.sessionRequestQueue.queue[0];\n    if (!request) {\n      this.client.logger.info(\"session request queue is empty.\");\n      return;\n    }\n\n    try {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.active;\n      this.emitSessionRequest(request);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  };\n\n  private emitSessionRequest = (request: PendingRequestTypes.Struct) => {\n    this.client.events.emit(\"session_request\", request);\n  };\n\n  // ---------- Expirer Events ---------------------------------------- //\n\n  private registerExpirerEvents() {\n    this.client.core.expirer.on(EXPIRER_EVENTS.expired, async (event: ExpirerTypes.Expiration) => {\n      const { topic, id } = parseExpirerTarget(event.target);\n      if (id && this.client.pendingRequest.keys.includes(id)) {\n        return await this.deletePendingSessionRequest(id, getInternalError(\"EXPIRED\"), true);\n      }\n      if (id && this.client.auth.requests.keys.includes(id)) {\n        return await this.deletePendingAuthRequest(id, getInternalError(\"EXPIRED\"), true);\n      }\n\n      if (topic) {\n        if (this.client.session.keys.includes(topic)) {\n          await this.deleteSession({ topic, expirerHasDeleted: true });\n          this.client.events.emit(\"session_expire\", { topic });\n        }\n      } else if (id) {\n        await this.deleteProposal(id, true);\n        this.client.events.emit(\"proposal_expire\", { id });\n      }\n    });\n  }\n\n  // ---------- Pairing Events ---------------------------------------- //\n  private registerPairingEvents() {\n    this.client.core.pairing.events.on(PAIRING_EVENTS.create, (pairing: PairingTypes.Struct) =>\n      this.onPairingCreated(pairing),\n    );\n    this.client.core.pairing.events.on(PAIRING_EVENTS.delete, (pairing: PairingTypes.Struct) => {\n      this.addToRecentlyDeleted(pairing.topic, \"pairing\");\n    });\n  }\n\n  /**\n   * when a pairing is created, we check if there is a pending proposal for it.\n   * if there is, we send it to onSessionProposeRequest to be processed as if it was received from the relay.\n   * It allows QR/URI to be scanned multiple times without having to create new pairing.\n   */\n  private onPairingCreated = (pairing: PairingTypes.Struct) => {\n    if (pairing.methods) {\n      this.expectedPairingMethodMap.set(pairing.topic, pairing.methods);\n    }\n    if (pairing.active) return;\n    const proposals = this.client.proposal.getAll();\n    const proposal = proposals.find((p) => p.pairingTopic === pairing.topic);\n    if (!proposal) return;\n    this.onSessionProposeRequest({\n      topic: pairing.topic,\n      payload: formatJsonRpcRequest(\n        \"wc_sessionPropose\",\n        {\n          ...proposal,\n          requiredNamespaces: proposal.requiredNamespaces,\n          optionalNamespaces: proposal.optionalNamespaces,\n          relays: proposal.relays,\n          proposer: proposal.proposer,\n          sessionProperties: proposal.sessionProperties,\n          scopedProperties: proposal.scopedProperties,\n        },\n        proposal.id,\n      ),\n    });\n  };\n\n  // ---------- Validation Helpers ------------------------------------ //\n  private isValidPairingTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.core.pairing.pairings.get(topic).expiry)) {\n      const { message } = getInternalError(\"EXPIRED\", `pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    // Store will throw custom message if topic was recently deleted\n    this.checkRecentlyDeleted(topic);\n    if (!this.client.session.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.session.get(topic).expiry)) {\n      await this.deleteSession({ topic });\n      const { message } = getInternalError(\"EXPIRED\", `session topic: ${topic}`);\n      throw new Error(message);\n    }\n\n    if (!this.client.core.crypto.keychain.has(topic)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session topic does not exist in keychain: ${topic}`,\n      );\n      await this.deleteSession({ topic });\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionOrPairingTopic(topic: string) {\n    this.checkRecentlyDeleted(topic);\n    if (this.client.session.keys.includes(topic)) {\n      await this.isValidSessionTopic(topic);\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      this.isValidPairingTopic(topic);\n    } else if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session or pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    } else {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session or pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  }\n\n  private async isValidProposalId(id: any) {\n    if (!isValidId(id)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `proposal id should be a number: ${id}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.proposal.keys.includes(id)) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${id}`);\n      throw new Error(message);\n    }\n    if (isExpired(this.client.proposal.get(id).expiryTimestamp)) {\n      await this.deleteProposal(id);\n      const { message } = getInternalError(\"EXPIRED\", `proposal id: ${id}`);\n      throw new Error(message);\n    }\n  }\n\n  // ---------- Validation  ------------------------------------------- //\n\n  private isValidConnect: EnginePrivate[\"isValidConnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `connect() params: ${JSON.stringify(params)}`,\n      );\n      throw new Error(message);\n    }\n    const {\n      pairingTopic,\n      requiredNamespaces,\n      optionalNamespaces,\n      sessionProperties,\n      scopedProperties,\n      relays,\n    } = params;\n    if (!isUndefined(pairingTopic)) await this.isValidPairingTopic(pairingTopic);\n\n    if (!isValidRelays(relays, true)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `connect() relays: ${relays}`);\n      throw new Error(message);\n    }\n\n    // validate required namespaces only if they are defined\n    if (!isUndefined(requiredNamespaces) && isValidObject(requiredNamespaces) !== 0) {\n      const warning =\n        \"requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces\";\n      // if logger level is one of the following, the logger.warn will not be shown, so we need to use console.warn\n      if ([\"fatal\", \"error\", \"silent\"].includes(this.client.logger.level)) {\n        console.warn(warning);\n      } else {\n        this.client.logger.warn(warning);\n      }\n      this.validateNamespaces(requiredNamespaces, \"requiredNamespaces\");\n    }\n\n    // validate optional namespaces only if they are defined\n    if (!isUndefined(optionalNamespaces) && isValidObject(optionalNamespaces) !== 0) {\n      this.validateNamespaces(optionalNamespaces, \"optionalNamespaces\");\n    }\n\n    // validate session properties only if they are defined\n    if (!isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n\n    if (!isUndefined(scopedProperties)) {\n      this.validateSessionProps(scopedProperties, \"scopedProperties\");\n\n      const requestedNamespaces = Object.keys(requiredNamespaces || {}).concat(\n        Object.keys(optionalNamespaces || {}),\n      );\n\n      const scopedNamespaces = Object.keys(scopedProperties);\n      const valid = scopedNamespaces.every((ns) => requestedNamespaces.includes(ns));\n      if (!valid) {\n        throw new Error(\n          `Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(\n            scopedProperties,\n          )}, required/optional namespaces: ${JSON.stringify(requestedNamespaces)}`,\n        );\n      }\n    }\n  };\n\n  private validateNamespaces = (\n    namespaces: ProposalTypes.RequiredNamespaces | ProposalTypes.OptionalNamespaces,\n    type: string,\n  ) => {\n    const validRequiredNamespacesError = isValidRequiredNamespaces(namespaces, \"connect()\", type);\n    if (validRequiredNamespacesError) throw new Error(validRequiredNamespacesError.message);\n  };\n\n  private isValidApprove: EnginePrivate[\"isValidApprove\"] = async (params) => {\n    if (!isValidParams(params))\n      throw new Error(\n        getInternalError(\"MISSING_OR_INVALID\", `approve() params: ${params}`).message,\n      );\n    const { id, namespaces, relayProtocol, sessionProperties, scopedProperties } = params;\n\n    this.checkRecentlyDeleted(id);\n    await this.isValidProposalId(id);\n    const proposal = this.client.proposal.get(id);\n    const validNamespacesError = isValidNamespaces(namespaces, \"approve()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      proposal.requiredNamespaces,\n      namespaces,\n      \"approve()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    if (!isValidString(relayProtocol, true)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `approve() relayProtocol: ${relayProtocol}`,\n      );\n      throw new Error(message);\n    }\n\n    if (!isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n\n    if (!isUndefined(scopedProperties)) {\n      this.validateSessionProps(scopedProperties, \"scopedProperties\");\n\n      const approvedNamespaces = new Set(Object.keys(namespaces));\n      const scopedNamespaces = Object.keys(scopedProperties);\n\n      // the approved scoped namespaces must be a subset of the approved namespaces\n      const valid = scopedNamespaces.every((ns) => approvedNamespaces.has(ns));\n      if (!valid) {\n        throw new Error(\n          `Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(\n            scopedProperties,\n          )}, approved namespaces: ${Array.from(approvedNamespaces).join(\", \")}`,\n        );\n      }\n    }\n  };\n\n  private isValidReject: EnginePrivate[\"isValidReject\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `reject() params: ${params}`);\n      throw new Error(message);\n    }\n    const { id, reason } = params;\n    this.checkRecentlyDeleted(id);\n    await this.isValidProposalId(id);\n    if (!isValidErrorReason(reason)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `reject() reason: ${JSON.stringify(reason)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidSessionSettleRequest: EnginePrivate[\"isValidSessionSettleRequest\"] = (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() params: ${params}`,\n      );\n      throw new Error(message);\n    }\n    const { relay, controller, namespaces, expiry } = params;\n    if (!isValidRelay(relay)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() relay protocol should be a string`,\n      );\n      throw new Error(message);\n    }\n    const validControllerError = isValidController(controller, \"onSessionSettleRequest()\");\n    if (validControllerError) throw new Error(validControllerError.message);\n    const validNamespacesError = isValidNamespaces(namespaces, \"onSessionSettleRequest()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    if (isExpired(expiry)) {\n      const { message } = getInternalError(\"EXPIRED\", `onSessionSettleRequest()`);\n      throw new Error(message);\n    }\n  };\n\n  private isValidUpdate: EnginePrivate[\"isValidUpdate\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `update() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, namespaces } = params;\n\n    this.checkRecentlyDeleted(topic);\n    await this.isValidSessionTopic(topic);\n    const session = this.client.session.get(topic);\n    const validNamespacesError = isValidNamespaces(namespaces, \"update()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      session.requiredNamespaces,\n      namespaces,\n      \"update()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    // TODO(ilja) - check if wallet\n  };\n\n  private isValidExtend: EnginePrivate[\"isValidExtend\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `extend() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n\n    this.checkRecentlyDeleted(topic);\n    await this.isValidSessionTopic(topic);\n  };\n\n  private isValidRequest: EnginePrivate[\"isValidRequest\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, request, chainId, expiry } = params;\n    this.checkRecentlyDeleted(topic);\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidRequest(request)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() ${JSON.stringify(request)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesRequest(namespaces, chainId, request.method)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() method: ${request.method}`,\n      );\n      throw new Error(message);\n    }\n    if (expiry && !isValidRequestExpiry(expiry, SESSION_REQUEST_EXPIRY_BOUNDARIES)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() expiry: ${expiry}. Expiry must be a number (in seconds) between ${SESSION_REQUEST_EXPIRY_BOUNDARIES.min} and ${SESSION_REQUEST_EXPIRY_BOUNDARIES.max}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidRespond: EnginePrivate[\"isValidRespond\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `respond() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, response } = params;\n    try {\n      // if the session is already disconnected, we can't respond to the request so we need to delete it\n      await this.isValidSessionTopic(topic);\n    } catch (error) {\n      if (params?.response?.id) this.cleanupAfterResponse(params);\n      throw error;\n    }\n    if (!isValidResponse(response)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `respond() response: ${JSON.stringify(response)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidPing: EnginePrivate[\"isValidPing\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `ping() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private isValidEmit: EnginePrivate[\"isValidEmit\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, event, chainId } = params;\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidEvent(event)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesEvent(namespaces, chainId, event.name)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidDisconnect: EnginePrivate[\"isValidDisconnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `disconnect() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private isValidAuthenticate = (params: AuthTypes.SessionAuthenticateParams) => {\n    const { chains, uri, domain, nonce } = params;\n\n    // ----- validate params ----- //\n    if (!Array.isArray(chains) || chains.length === 0) {\n      throw new Error(\"chains is required and must be a non-empty array\");\n    }\n    if (!isValidString(uri, false)) {\n      throw new Error(\"uri is required parameter\");\n    }\n    if (!isValidString(domain, false)) {\n      throw new Error(\"domain is required parameter\");\n    }\n    if (!isValidString(nonce, false)) {\n      throw new Error(\"nonce is required parameter\");\n    }\n\n    // ----- reject multi namespaces ----- //\n    const uniqueNamespaces = [...new Set(chains.map((chain) => parseChainId(chain).namespace))];\n    if (uniqueNamespaces.length > 1) {\n      throw new Error(\n        \"Multi-namespace requests are not supported. Please request single namespace only.\",\n      );\n    }\n\n    const { namespace } = parseChainId(chains[0]);\n    if (namespace !== \"eip155\") {\n      throw new Error(\n        \"Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.\",\n      );\n    }\n  };\n\n  private getVerifyContext = async (params: {\n    attestationId?: string;\n    hash?: string;\n    encryptedId?: string;\n    metadata: CoreTypes.Metadata;\n    transportType?: RelayerTypes.TransportType;\n  }) => {\n    const { attestationId, hash, encryptedId, metadata, transportType } = params;\n    const context: Verify.Context = {\n      verified: {\n        verifyUrl: metadata.verifyUrl || VERIFY_SERVER,\n        validation: \"UNKNOWN\",\n        origin: metadata.url || \"\",\n      },\n    };\n\n    try {\n      if (transportType === TRANSPORT_TYPES.link_mode) {\n        const applink = this.getAppLinkIfEnabled(metadata, transportType);\n        context.verified.validation =\n          applink && new URL(applink).origin === new URL(metadata.url).origin ? \"VALID\" : \"INVALID\";\n        return context;\n      }\n      const result = await this.client.core.verify.resolve({\n        attestationId,\n        hash,\n        encryptedId,\n        verifyUrl: metadata.verifyUrl,\n      });\n      if (result) {\n        context.verified.origin = result.origin;\n        context.verified.isScam = result.isScam;\n        context.verified.validation =\n          result.origin === new URL(metadata.url).origin ? \"VALID\" : \"INVALID\";\n      }\n    } catch (e) {\n      this.client.logger.warn(e);\n    }\n\n    this.client.logger.debug(`Verify context: ${JSON.stringify(context)}`);\n    return context;\n  };\n\n  private validateSessionProps = (properties: SessionTypes.ScopedProperties, type: string) => {\n    Object.values(properties).forEach((property, index) => {\n      if (property === null || property === undefined) {\n        const { message } = getInternalError(\n          \"MISSING_OR_INVALID\",\n          `${type} must contain an existing value for each key. Received: ${property} for key ${\n            Object.keys(properties)[index]\n          }`,\n        );\n        throw new Error(message);\n      }\n    });\n  };\n\n  private getPendingAuthRequest = (id: number) => {\n    const request = this.client.auth.requests.get(id);\n    return typeof request === \"object\" ? request : undefined;\n  };\n\n  private addToRecentlyDeleted = (\n    id: string | number,\n    type: \"pairing\" | \"session\" | \"proposal\" | \"request\",\n  ) => {\n    this.recentlyDeletedMap.set(id, type);\n    // remove first half of the map if it exceeds the limit\n    if (this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {\n      let i = 0;\n      const numItemsToDelete = this.recentlyDeletedLimit / 2;\n      for (const k of this.recentlyDeletedMap.keys()) {\n        if (i++ >= numItemsToDelete) {\n          break;\n        }\n        this.recentlyDeletedMap.delete(k);\n      }\n    }\n  };\n\n  private checkRecentlyDeleted = (id: string | number) => {\n    const deletedRecord = this.recentlyDeletedMap.get(id);\n    if (deletedRecord) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `Record was recently deleted - ${deletedRecord}: ${id}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isLinkModeEnabled = (\n    peerMetadata?: CoreTypes.Metadata,\n    transportType?: RelayerTypes.TransportType,\n  ): boolean => {\n    if (!peerMetadata || transportType !== TRANSPORT_TYPES.link_mode) return false;\n\n    return (\n      this.client.metadata?.redirect?.linkMode === true &&\n      this.client.metadata?.redirect?.universal !== undefined &&\n      this.client.metadata?.redirect?.universal !== \"\" &&\n      peerMetadata?.redirect?.universal !== undefined &&\n      peerMetadata?.redirect?.universal !== \"\" &&\n      peerMetadata?.redirect?.linkMode === true &&\n      this.client.core.linkModeSupportedApps.includes(peerMetadata.redirect.universal) &&\n      typeof (global as any)?.Linking !== \"undefined\"\n    );\n  };\n\n  private getAppLinkIfEnabled = (\n    peerMetadata?: CoreTypes.Metadata,\n    transportType?: RelayerTypes.TransportType,\n  ): string | undefined => {\n    return this.isLinkModeEnabled(peerMetadata, transportType)\n      ? peerMetadata?.redirect?.universal\n      : undefined;\n  };\n\n  private handleLinkModeMessage = ({ url }: { url: string }) => {\n    if (!url || !url.includes(\"wc_ev\") || !url.includes(\"topic\")) return;\n\n    const topic = getSearchParamFromURL(url, \"topic\") || \"\";\n    const message = decodeURIComponent(getSearchParamFromURL(url, \"wc_ev\") || \"\");\n\n    const sessionExists = this.client.session.keys.includes(topic);\n\n    if (sessionExists) {\n      this.client.session.update(topic, { transportType: TRANSPORT_TYPES.link_mode });\n    }\n\n    this.client.core.dispatchEnvelope({ topic, message, sessionExists });\n  };\n\n  private registerLinkModeListeners = async () => {\n    if (isTestRun() || (isReactNative() && this.client.metadata.redirect?.linkMode)) {\n      const linking = (global as any)?.Linking;\n      // global.Linking is set by react-native-compat\n      if (typeof linking !== \"undefined\") {\n        // set URL listener\n        linking.addEventListener(\"url\", this.handleLinkModeMessage, this.client.name);\n\n        // check for initial URL -> cold boots\n        const initialUrl = await linking.getInitialURL();\n        if (initialUrl) {\n          // wait to process the message to allow event listeners to be registered by the implementing app\n          setTimeout(() => {\n            this.handleLinkModeMessage({ url: initialUrl });\n          }, 50);\n        }\n      }\n    }\n  };\n\n  private shouldSetTVF = (\n    protocolMethod: JsonRpcTypes.WcMethod,\n    params: JsonRpcTypes.RequestParams[\"wc_sessionRequest\"],\n  ) => {\n    if (!params) return false;\n    if (protocolMethod !== \"wc_sessionRequest\") return false;\n    const { request } = params;\n    return Object.keys(TVF_METHODS).includes(request.method);\n  };\n\n  private getTVFParams = (\n    id: number,\n    params: JsonRpcTypes.RequestParams[\"wc_sessionRequest\"],\n    result?: any,\n  ) => {\n    try {\n      const requestMethod = params.request.method;\n      const txHashes = this.extractTxHashesFromResult(requestMethod, result);\n      const tvf: RelayerTypes.ITVF = {\n        correlationId: id,\n        rpcMethods: [requestMethod],\n        chainId: params.chainId,\n        ...(this.isValidContractData(params.request.params) && {\n          // initially only get contractAddresses from EVM txs\n          contractAddresses: [params.request.params?.[0]?.to],\n        }),\n        txHashes,\n      };\n      return tvf;\n    } catch (e) {\n      this.client.logger.warn(\"Error getting TVF params\", e);\n    }\n    return {};\n  };\n\n  private isValidContractData = (params: any) => {\n    if (!params) return false;\n    try {\n      const data = params?.data || params?.[0]?.data;\n\n      if (!data.startsWith(\"0x\")) return false;\n\n      const hexPart = data.slice(2);\n      if (!/^[0-9a-fA-F]*$/.test(hexPart)) return false;\n\n      return hexPart.length % 2 === 0;\n    } catch (e) {}\n    return false;\n  };\n\n  private extractTxHashesFromResult = (method: string, result: any): string[] => {\n    try {\n      const methodConfig = TVF_METHODS[method as keyof typeof TVF_METHODS];\n      // result = 0x...\n      if (typeof result === \"string\") {\n        return [result];\n      }\n\n      // result = { key: [0x...] } or { key: 0x... }\n      const hashes: string[] = result[methodConfig.key];\n\n      // result = { key: [0x...] }\n      if (isValidArray(hashes)) {\n        if (method === \"solana_signAllTransactions\") {\n          return hashes.map((hash) => extractSolanaTransactionId(hash));\n        }\n\n        return hashes;\n\n        // result = { key: 0x... }\n      } else if (typeof hashes === \"string\") {\n        return [hashes];\n      }\n    } catch (e) {\n      this.client.logger.warn(\"Error extracting tx hashes from result\", e);\n    }\n    return [];\n  };\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, ProposalTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, PROPOSAL_CONTEXT } from \"../constants\";\n\nexport class Proposal extends Store<number, ProposalTypes.Struct> {\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super(core, logger, PROPOSAL_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, SessionTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, SESSION_CONTEXT } from \"../constants\";\n\nexport class Session extends Store<string, SessionTypes.Struct> {\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super(core, logger, SESSION_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, PendingRequestTypes } from \"@walletconnect/types\";\nimport { REQUEST_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX } from \"../constants\";\n\nexport class PendingRequest extends Store<number, PendingRequestTypes.Struct> {\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super(\n      core,\n      logger,\n      REQUEST_CONTEXT,\n      SIGN_CLIENT_STORAGE_PREFIX,\n      (val: PendingRequestTypes.Struct) => val.id,\n    );\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"@walletconnect/types\";\n\nimport { AUTH_KEYS_CONTEXT, AUTH_STORAGE_PREFIX, AUTH_PUBLIC_KEY_NAME } from \"../constants\";\n\nexport class AuthKey extends Store<string, { responseTopic: string; publicKey: string }> {\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super(core, logger, AUTH_KEYS_CONTEXT, AUTH_STORAGE_PREFIX, () => AUTH_PUBLIC_KEY_NAME);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"@walletconnect/types\";\n\nimport { AUTH_PAIRING_TOPIC_CONTEXT, AUTH_STORAGE_PREFIX } from \"../constants\";\n\nexport class AuthPairingTopic extends Store<string, { topic: string; pairingTopic: string }> {\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super(core, logger, AUTH_PAIRING_TOPIC_CONTEXT, AUTH_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { AuthTypes, ICore } from \"@walletconnect/types\";\n\nimport { AUTH_STORAGE_PREFIX, AUTH_REQUEST_CONTEXT } from \"../constants\";\n\nexport class AuthRequest extends Store<number, AuthTypes.PendingRequest> {\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    super(\n      core,\n      logger,\n      AUTH_REQUEST_CONTEXT,\n      AUTH_STORAGE_PREFIX,\n      (val: AuthTypes.PendingRequest) => val.id,\n    );\n  }\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { IAuth, ICore } from \"@walletconnect/types\";\nimport { AuthPairingTopic } from \"./authPairingTopic\";\nimport { AuthRequest } from \"./authRequest\";\nimport { AuthKey } from \"./authKey\";\n\nexport class AuthStore {\n  public authKeys: IAuth[\"authKeys\"];\n  public pairingTopics: IAuth[\"pairingTopics\"];\n  public requests: IAuth[\"requests\"];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n  ) {\n    this.authKeys = new AuthKey(this.core, this.logger);\n    this.pairingTopics = new AuthPairingTopic(this.core, this.logger);\n    this.requests = new AuthRequest(this.core, this.logger);\n  }\n\n  public async init() {\n    await this.authKeys.init();\n    await this.pairingTopics.init();\n    await this.requests.init();\n  }\n}\n","import { Core } from \"@walletconnect/core\";\nimport {\n  generateChildLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n  pino,\n} from \"@walletconnect/logger\";\nimport { SignClientTypes, ISignClient, ISignClientEvents, EngineTypes } from \"@walletconnect/types\";\nimport { ONE_SECOND, toMiliseconds } from \"@walletconnect/time\";\nimport { populateAppMetadata } from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport { SIGN_CLIENT_DEFAULT, SIGN_CLIENT_PROTOCOL, SIGN_CLIENT_VERSION } from \"./constants\";\nimport { AuthStore, Engine, PendingRequest, Proposal, Session } from \"./controllers\";\n\nexport class SignClient extends ISignClient {\n  public readonly protocol = SIGN_CLIENT_PROTOCOL;\n  public readonly version = SIGN_CLIENT_VERSION;\n  public readonly name: ISignClient[\"name\"] = SIGN_CLIENT_DEFAULT.name;\n  public readonly metadata: ISignClient[\"metadata\"];\n\n  public core: ISignClient[\"core\"];\n  public logger: ISignClient[\"logger\"];\n  public events: ISignClient[\"events\"] = new EventEmitter();\n  public engine: ISignClient[\"engine\"];\n  public session: ISignClient[\"session\"];\n  public proposal: ISignClient[\"proposal\"];\n  public pendingRequest: ISignClient[\"pendingRequest\"];\n  public auth: ISignClient[\"auth\"];\n  public signConfig?: ISignClient[\"signConfig\"];\n\n  static async init(opts?: SignClientTypes.Options) {\n    const client = new SignClient(opts);\n    await client.initialize();\n\n    return client;\n  }\n\n  constructor(opts?: SignClientTypes.Options) {\n    super(opts);\n\n    this.name = opts?.name || SIGN_CLIENT_DEFAULT.name;\n    this.metadata = populateAppMetadata(opts?.metadata);\n    this.signConfig = opts?.signConfig;\n\n    const logger =\n      typeof opts?.logger !== \"undefined\" && typeof opts?.logger !== \"string\"\n        ? opts.logger\n        : pino(getDefaultLoggerOptions({ level: opts?.logger || SIGN_CLIENT_DEFAULT.logger }));\n\n    this.core = opts?.core || new Core(opts);\n    this.logger = generateChildLogger(logger, this.name);\n    this.session = new Session(this.core, this.logger);\n    this.proposal = new Proposal(this.core, this.logger);\n    this.pendingRequest = new PendingRequest(this.core, this.logger);\n    this.engine = new Engine(this);\n    this.auth = new AuthStore(this.core, this.logger);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n\n  // ---------- Events ----------------------------------------------- //\n\n  public on: ISignClientEvents[\"on\"] = (name, listener) => {\n    return this.events.on(name, listener);\n  };\n\n  public once: ISignClientEvents[\"once\"] = (name, listener) => {\n    return this.events.once(name, listener);\n  };\n\n  public off: ISignClientEvents[\"off\"] = (name, listener) => {\n    return this.events.off(name, listener);\n  };\n\n  public removeListener: ISignClientEvents[\"removeListener\"] = (name, listener) => {\n    return this.events.removeListener(name, listener);\n  };\n\n  public removeAllListeners: ISignClientEvents[\"removeAllListeners\"] = (name) => {\n    return this.events.removeAllListeners(name);\n  };\n\n  // ---------- Engine ----------------------------------------------- //\n\n  public connect: ISignClient[\"connect\"] = async (params) => {\n    try {\n      return await this.engine.connect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public pair: ISignClient[\"pair\"] = async (params) => {\n    try {\n      return await this.engine.pair(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public approve: ISignClient[\"approve\"] = async (params) => {\n    try {\n      return await this.engine.approve(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public reject: ISignClient[\"reject\"] = async (params) => {\n    try {\n      return await this.engine.reject(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public update: ISignClient[\"update\"] = async (params) => {\n    try {\n      return await this.engine.update(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public extend: ISignClient[\"extend\"] = async (params) => {\n    try {\n      return await this.engine.extend(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public request: ISignClient[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    try {\n      return await this.engine.request<T>(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public respond: ISignClient[\"respond\"] = async (params) => {\n    try {\n      return await this.engine.respond(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public ping: ISignClient[\"ping\"] = async (params) => {\n    try {\n      return await this.engine.ping(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public emit: ISignClient[\"emit\"] = async (params) => {\n    try {\n      return await this.engine.emit(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public disconnect: ISignClient[\"disconnect\"] = async (params) => {\n    try {\n      return await this.engine.disconnect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public find: ISignClient[\"find\"] = (params) => {\n    try {\n      return this.engine.find(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public getPendingSessionRequests: ISignClient[\"getPendingSessionRequests\"] = () => {\n    try {\n      return this.engine.getPendingSessionRequests();\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public authenticate: ISignClient[\"authenticate\"] = async (params, walletUniversalLink) => {\n    try {\n      return await this.engine.authenticate(params, walletUniversalLink);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public formatAuthMessage: ISignClient[\"formatAuthMessage\"] = (params) => {\n    try {\n      return this.engine.formatAuthMessage(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public approveSessionAuthenticate: ISignClient[\"approveSessionAuthenticate\"] = async (params) => {\n    try {\n      return await this.engine.approveSessionAuthenticate(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public rejectSessionAuthenticate: ISignClient[\"rejectSessionAuthenticate\"] = async (params) => {\n    try {\n      return await this.engine.rejectSessionAuthenticate(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    try {\n      await this.core.start();\n      await this.session.init();\n      await this.proposal.init();\n      await this.pendingRequest.init();\n      await this.auth.init();\n      await this.engine.init();\n      this.logger.info(`SignClient Initialization Success`);\n      setTimeout(() => {\n        this.engine.processRelayMessageCache();\n      }, toMiliseconds(ONE_SECOND));\n    } catch (error: any) {\n      this.logger.info(`SignClient Initialization Failure`);\n      this.logger.error(error.message);\n      throw error;\n    }\n  }\n}\n","import { SignClient as Client } from \"./client\";\nimport { Session } from \"./controllers/session\";\nexport * from \"./constants\";\n\nexport const SessionStore = Session;\nexport const SignClient = Client;\nexport default Client;\n"],"names":["THIRTY_DAYS","SEVEN_DAYS","FIVE_MINUTES","ONE_DAY","ONE_HOUR","IEngine","client","__publicField","ENGINE_CONTEXT","EventEmmiter","ENGINE_QUEUE_STATES","ONE_SECOND","ENGINE_RPC_OPTS","toMiliseconds","params","connectParams","__spreadProps","__spreadValues","mergeRequiredAndOptionalNamespaces","pairingTopic","requiredNamespaces","optionalNamespaces","sessionProperties","scopedProperties","relays","topic","uri","active","pairing","error","newTopic","newUri","message","getInternalError","publicKey","expiry","expiryTimestamp","calcExpiry","proposal","RELAYER_DEFAULT_PROTOCOL","payloadId","sessionConnectTarget","engineEvent","reject","resolve","approval","createDelayedPromise","PROPOSAL_EXPIRY_MESSAGE","proposalExpireHandler","id","session","_a","_b","_c","configEvent","EVENT_CLIENT_SESSION_TRACES","EVENT_CLIENT_SESSION_ERRORS","relayProtocol","namespaces","sessionConfig","proposer","event","selfPublicKey","peerPublicKey","sessionTopic","sessionSettle","SESSION_EXPIRY","transportType","TRANSPORT_TYPES","getSdkError","reason","acknowledged","clientRpcId","relayRpcId","getBigIntRpcId","oldNamespaces","e","chainId","request","done","result","protocolMethod","appLink","protocolRequestParams","shouldSetTVF","wcDeepLink","getDeepLink","WALLETCONNECT_DEEPLINK_CHOICE","handleDeeplinkRedirect","response","isJsonRpcResult","isJsonRpcError","isSessionCompatible","walletUniversalLink","isLinkMode","chains","statement","domain","nonce","type","exp","nbf","methods","resources","connectionUri","responseTopic","hashKey","AUTH_PUBLIC_KEY_NAME","namespace","parseChainId","recap","createEncodedRecap","getRecapFromResources","mergeEncodedRecaps","authRequestExpiry","authenticateId","sessionConnectEventTarget","authenticateEventTarget","onSessionConnect","onAuthenticate","payload","cacaos","responder","approvedMethods","approvedAccounts","cacao","validateSignedCacao","approvedChains","getNamespacedDidChainId","parsedAddress","getDidAddress","methodsfromRecap","getMethodsFromRecap","chainsFromRecap","getChainsFromRecap","chain","buildNamespacesFromAuth","linkModeURL","formatJsonRpcRequest","TYPE_2","BASE64URL","getLinkModeURL","sessionAuthenticateResponseParams","auths","EVENT_CLIENT_AUTHENTICATE_TRACES","EVENT_CLIENT_AUTHENTICATE_ERRORS","pendingRequest","receiverPublicKey","senderPublicKey","encodeOpts","TYPE_1","invalidErr","iss","formatMessage","duplicates","p","expirerHasDeleted","emitEvent","self","r","verifyContext","args","method","throwOnFailedPublish","tvf","encoding","BASE64","attestation","METHODS_TO_VERIFY","decryptedId","hashMessage","opts","redirectURL","formatJsonRpcResult","record","rpcOpts","formatJsonRpcError","sessionTopics","proposalIds","toCleanup","isExpired","encryptedId","reqMethod","resMethod","requestMethod","expectedMethods","EVENT_CLIENT_PAIRING_ERRORS","EVENT_CLIENT_PAIRING_TRACES","err","subscriptionId","target","relay","controller","pendingSession","s","memoryKey","lastSessionUpdateId","MemoryStore","lastId","currentId","_topic","RELAYER_EVENTS","requester","authPayload","pendingRequests","isValidParams","isUndefined","isValidRelays","isValidObject","warning","requestedNamespaces","ns","validRequiredNamespacesError","isValidRequiredNamespaces","validNamespacesError","isValidNamespaces","conformingNamespacesError","isConformingNamespaces","isValidString","approvedNamespaces","isValidErrorReason","isValidRelay","validControllerError","isValidController","isValidNamespacesChainId","isValidRequest","isValidNamespacesRequest","isValidRequestExpiry","SESSION_REQUEST_EXPIRY_BOUNDARIES","isValidResponse","isValidEvent","isValidNamespacesEvent","attestationId","hash","metadata","context","VERIFY_SERVER","applink","properties","property","index","i","numItemsToDelete","k","deletedRecord","peerMetadata","_d","_e","_f","_g","_h","_i","url","getSearchParamFromURL","sessionExists","isTestRun","isReactNative","linking","initialUrl","TVF_METHODS","txHashes","data","hexPart","methodConfig","hashes","isValidArray","extractSolanaTransactionId","topics","pendingMessages","messages","isJsonRpcRequest","isJsonRpcResponse","EXPIRER_EVENTS","parseExpirerTarget","PAIRING_EVENTS","isValidId","Store","core","logger","PROPOSAL_CONTEXT","SIGN_CLIENT_STORAGE_PREFIX","SESSION_CONTEXT","REQUEST_CONTEXT","val","AUTH_KEYS_CONTEXT","AUTH_STORAGE_PREFIX","AUTH_PAIRING_TOPIC_CONTEXT","AUTH_REQUEST_CONTEXT","o","AuthKey","AuthPairingTopic","AuthRequest","SignClient","ISignClient","SIGN_CLIENT_PROTOCOL","SIGN_CLIENT_VERSION","SIGN_CLIENT_DEFAULT","EventEmitter","name","listener","populateAppMetadata","pino","getDefaultLoggerOptions","Core","generateChildLogger","Session","Proposal","PendingRequest","Engine","AuthStore","getLoggerContext","Client"],"mappings":"","debugId":null}},
    {"offset": {"line": 12949, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/universal-provider/dist/index.es.js","sources":["file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/universal-provider/src/constants/values.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/universal-provider/src/constants/events.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/function/noop.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/predicate/isPrimitive.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/predicate/isTypedArray.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/object/clone.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/compat/predicate/isObjectLike.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/compat/_internal/getTag.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/compat/_internal/tags.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/object/cloneDeepWith.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/compat/object/cloneDeepWith.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/compat/object/cloneDeep.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/compat/predicate/isArguments.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/compat/predicate/isTypedArray.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/compat/predicate/isPlainObject.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/compat/object/mergeWith.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/node_modules/es-toolkit/dist/compat/object/merge.mjs","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/universal-provider/src/utils/misc.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/universal-provider/src/utils/globals.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/universal-provider/src/providers/polkadot.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/universal-provider/src/providers/eip155.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/universal-provider/src/providers/solana.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/universal-provider/src/providers/cosmos.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/universal-provider/src/providers/algorand.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/universal-provider/src/providers/cardano.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/universal-provider/src/providers/elrond.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/universal-provider/src/providers/multiversx.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/universal-provider/src/providers/near.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/universal-provider/src/providers/tezos.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/universal-provider/src/providers/generic.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/universal-provider/src/UniversalProvider.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/universal-provider/src/index.ts"],"sourcesContent":["export const LOGGER = \"error\";\n\nexport const RELAY_URL = \"wss://relay.walletconnect.org\";\n\nexport const PROTOCOL = \"wc\";\nexport const WC_VERSION = 2;\nexport const CONTEXT = \"universal_provider\";\n\nexport const STORAGE = `${PROTOCOL}@${WC_VERSION}:${CONTEXT}:`;\n\nexport const RPC_URL = \"https://rpc.walletconnect.org/v1/\";\n\nexport const GENERIC_SUBPROVIDER_NAME = \"generic\";\n\nexport const BUNDLER_URL = `${RPC_URL}bundler`;\n","export const PROVIDER_EVENTS = {\n  DEFAULT_CHAIN_CHANGED: \"default_chain_changed\",\n};\n","function noop() { }\n\nexport { noop };\n","function isPrimitive(value) {\n    return value == null || (typeof value !== 'object' && typeof value !== 'function');\n}\n\nexport { isPrimitive };\n","function isTypedArray(x) {\n    return ArrayBuffer.isView(x) && !(x instanceof DataView);\n}\n\nexport { isTypedArray };\n","import { isPrimitive } from '../predicate/isPrimitive.mjs';\nimport { isTypedArray } from '../predicate/isTypedArray.mjs';\n\nfunction clone(obj) {\n    if (isPrimitive(obj)) {\n        return obj;\n    }\n    if (Array.isArray(obj) ||\n        isTypedArray(obj) ||\n        obj instanceof ArrayBuffer ||\n        (typeof SharedArrayBuffer !== 'undefined' && obj instanceof SharedArrayBuffer)) {\n        return obj.slice(0);\n    }\n    const prototype = Object.getPrototypeOf(obj);\n    const Constructor = prototype.constructor;\n    if (obj instanceof Date || obj instanceof Map || obj instanceof Set) {\n        return new Constructor(obj);\n    }\n    if (obj instanceof RegExp) {\n        const newRegExp = new Constructor(obj);\n        newRegExp.lastIndex = obj.lastIndex;\n        return newRegExp;\n    }\n    if (obj instanceof DataView) {\n        return new Constructor(obj.buffer.slice(0));\n    }\n    if (obj instanceof Error) {\n        const newError = new Constructor(obj.message);\n        newError.stack = obj.stack;\n        newError.name = obj.name;\n        newError.cause = obj.cause;\n        return newError;\n    }\n    if (typeof File !== 'undefined' && obj instanceof File) {\n        const newFile = new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });\n        return newFile;\n    }\n    if (typeof obj === 'object') {\n        const newObject = Object.create(prototype);\n        return Object.assign(newObject, obj);\n    }\n    return obj;\n}\n\nexport { clone };\n","function isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\n\nexport { isObjectLike };\n","function getSymbols(object) {\n    return Object.getOwnPropertySymbols(object).filter(symbol => Object.prototype.propertyIsEnumerable.call(object, symbol));\n}\n\nexport { getSymbols };\n","function getTag(value) {\n    if (value == null) {\n        return value === undefined ? '[object Undefined]' : '[object Null]';\n    }\n    return Object.prototype.toString.call(value);\n}\n\nexport { getTag };\n","const regexpTag = '[object RegExp]';\nconst stringTag = '[object String]';\nconst numberTag = '[object Number]';\nconst booleanTag = '[object Boolean]';\nconst argumentsTag = '[object Arguments]';\nconst symbolTag = '[object Symbol]';\nconst dateTag = '[object Date]';\nconst mapTag = '[object Map]';\nconst setTag = '[object Set]';\nconst arrayTag = '[object Array]';\nconst functionTag = '[object Function]';\nconst arrayBufferTag = '[object ArrayBuffer]';\nconst objectTag = '[object Object]';\nconst errorTag = '[object Error]';\nconst dataViewTag = '[object DataView]';\nconst uint8ArrayTag = '[object Uint8Array]';\nconst uint8ClampedArrayTag = '[object Uint8ClampedArray]';\nconst uint16ArrayTag = '[object Uint16Array]';\nconst uint32ArrayTag = '[object Uint32Array]';\nconst bigUint64ArrayTag = '[object BigUint64Array]';\nconst int8ArrayTag = '[object Int8Array]';\nconst int16ArrayTag = '[object Int16Array]';\nconst int32ArrayTag = '[object Int32Array]';\nconst bigInt64ArrayTag = '[object BigInt64Array]';\nconst float32ArrayTag = '[object Float32Array]';\nconst float64ArrayTag = '[object Float64Array]';\n\nexport { argumentsTag, arrayBufferTag, arrayTag, bigInt64ArrayTag, bigUint64ArrayTag, booleanTag, dataViewTag, dateTag, errorTag, float32ArrayTag, float64ArrayTag, functionTag, int16ArrayTag, int32ArrayTag, int8ArrayTag, mapTag, numberTag, objectTag, regexpTag, setTag, stringTag, symbolTag, uint16ArrayTag, uint32ArrayTag, uint8ArrayTag, uint8ClampedArrayTag };\n","import { getSymbols } from '../compat/_internal/getSymbols.mjs';\nimport { getTag } from '../compat/_internal/getTag.mjs';\nimport { uint32ArrayTag, uint16ArrayTag, uint8ClampedArrayTag, uint8ArrayTag, symbolTag, stringTag, setTag, regexpTag, objectTag, numberTag, mapTag, int32ArrayTag, int16ArrayTag, int8ArrayTag, float64ArrayTag, float32ArrayTag, dateTag, booleanTag, dataViewTag, arrayBufferTag, arrayTag, argumentsTag } from '../compat/_internal/tags.mjs';\nimport { isPrimitive } from '../predicate/isPrimitive.mjs';\nimport { isTypedArray } from '../predicate/isTypedArray.mjs';\n\nfunction cloneDeepWith(obj, cloneValue) {\n    return cloneDeepWithImpl(obj, undefined, obj, new Map(), cloneValue);\n}\nfunction cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = new Map(), cloneValue = undefined) {\n    const cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);\n    if (cloned != null) {\n        return cloned;\n    }\n    if (isPrimitive(valueToClone)) {\n        return valueToClone;\n    }\n    if (stack.has(valueToClone)) {\n        return stack.get(valueToClone);\n    }\n    if (Array.isArray(valueToClone)) {\n        const result = new Array(valueToClone.length);\n        stack.set(valueToClone, result);\n        for (let i = 0; i < valueToClone.length; i++) {\n            result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);\n        }\n        if (Object.hasOwn(valueToClone, 'index')) {\n            result.index = valueToClone.index;\n        }\n        if (Object.hasOwn(valueToClone, 'input')) {\n            result.input = valueToClone.input;\n        }\n        return result;\n    }\n    if (valueToClone instanceof Date) {\n        return new Date(valueToClone.getTime());\n    }\n    if (valueToClone instanceof RegExp) {\n        const result = new RegExp(valueToClone.source, valueToClone.flags);\n        result.lastIndex = valueToClone.lastIndex;\n        return result;\n    }\n    if (valueToClone instanceof Map) {\n        const result = new Map();\n        stack.set(valueToClone, result);\n        for (const [key, value] of valueToClone) {\n            result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));\n        }\n        return result;\n    }\n    if (valueToClone instanceof Set) {\n        const result = new Set();\n        stack.set(valueToClone, result);\n        for (const value of valueToClone) {\n            result.add(cloneDeepWithImpl(value, undefined, objectToClone, stack, cloneValue));\n        }\n        return result;\n    }\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(valueToClone)) {\n        return valueToClone.subarray();\n    }\n    if (isTypedArray(valueToClone)) {\n        const result = new (Object.getPrototypeOf(valueToClone).constructor)(valueToClone.length);\n        stack.set(valueToClone, result);\n        for (let i = 0; i < valueToClone.length; i++) {\n            result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);\n        }\n        return result;\n    }\n    if (valueToClone instanceof ArrayBuffer ||\n        (typeof SharedArrayBuffer !== 'undefined' && valueToClone instanceof SharedArrayBuffer)) {\n        return valueToClone.slice(0);\n    }\n    if (valueToClone instanceof DataView) {\n        const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (typeof File !== 'undefined' && valueToClone instanceof File) {\n        const result = new File([valueToClone], valueToClone.name, {\n            type: valueToClone.type,\n        });\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (valueToClone instanceof Blob) {\n        const result = new Blob([valueToClone], { type: valueToClone.type });\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (valueToClone instanceof Error) {\n        const result = new valueToClone.constructor();\n        stack.set(valueToClone, result);\n        result.message = valueToClone.message;\n        result.name = valueToClone.name;\n        result.stack = valueToClone.stack;\n        result.cause = valueToClone.cause;\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (typeof valueToClone === 'object' && isCloneableObject(valueToClone)) {\n        const result = Object.create(Object.getPrototypeOf(valueToClone));\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    return valueToClone;\n}\nfunction copyProperties(target, source, objectToClone = target, stack, cloneValue) {\n    const keys = [...Object.keys(source), ...getSymbols(source)];\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const descriptor = Object.getOwnPropertyDescriptor(target, key);\n        if (descriptor == null || descriptor.writable) {\n            target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);\n        }\n    }\n}\nfunction isCloneableObject(object) {\n    switch (getTag(object)) {\n        case argumentsTag:\n        case arrayTag:\n        case arrayBufferTag:\n        case dataViewTag:\n        case booleanTag:\n        case dateTag:\n        case float32ArrayTag:\n        case float64ArrayTag:\n        case int8ArrayTag:\n        case int16ArrayTag:\n        case int32ArrayTag:\n        case mapTag:\n        case numberTag:\n        case objectTag:\n        case regexpTag:\n        case setTag:\n        case stringTag:\n        case symbolTag:\n        case uint8ArrayTag:\n        case uint8ClampedArrayTag:\n        case uint16ArrayTag:\n        case uint32ArrayTag: {\n            return true;\n        }\n        default: {\n            return false;\n        }\n    }\n}\n\nexport { cloneDeepWith, cloneDeepWithImpl, copyProperties };\n","import { cloneDeepWith as cloneDeepWith$1, copyProperties } from '../../object/cloneDeepWith.mjs';\nimport { argumentsTag, booleanTag, stringTag, numberTag } from '../_internal/tags.mjs';\n\nfunction cloneDeepWith(obj, cloneValue) {\n    return cloneDeepWith$1(obj, (value, key, object, stack) => {\n        const cloned = cloneValue?.(value, key, object, stack);\n        if (cloned != null) {\n            return cloned;\n        }\n        if (typeof obj !== 'object') {\n            return undefined;\n        }\n        switch (Object.prototype.toString.call(obj)) {\n            case numberTag:\n            case stringTag:\n            case booleanTag: {\n                const result = new obj.constructor(obj?.valueOf());\n                copyProperties(result, obj);\n                return result;\n            }\n            case argumentsTag: {\n                const result = {};\n                copyProperties(result, obj);\n                result.length = obj.length;\n                result[Symbol.iterator] = obj[Symbol.iterator];\n                return result;\n            }\n            default: {\n                return undefined;\n            }\n        }\n    });\n}\n\nexport { cloneDeepWith };\n","import { cloneDeepWith } from './cloneDeepWith.mjs';\n\nfunction cloneDeep(obj) {\n    return cloneDeepWith(obj);\n}\n\nexport { cloneDeep };\n","import { getTag } from '../_internal/getTag.mjs';\n\nfunction isArguments(value) {\n    return value !== null && typeof value === 'object' && getTag(value) === '[object Arguments]';\n}\n\nexport { isArguments };\n","import { isTypedArray as isTypedArray$1 } from '../../predicate/isTypedArray.mjs';\n\nfunction isTypedArray(x) {\n    return isTypedArray$1(x);\n}\n\nexport { isTypedArray };\n","function isPlainObject(object) {\n    if (typeof object !== 'object') {\n        return false;\n    }\n    if (object == null) {\n        return false;\n    }\n    if (Object.getPrototypeOf(object) === null) {\n        return true;\n    }\n    if (Object.prototype.toString.call(object) !== '[object Object]') {\n        const tag = object[Symbol.toStringTag];\n        if (tag == null) {\n            return false;\n        }\n        const isTagReadonly = !Object.getOwnPropertyDescriptor(object, Symbol.toStringTag)?.writable;\n        if (isTagReadonly) {\n            return false;\n        }\n        return object.toString() === `[object ${tag}]`;\n    }\n    let proto = object;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(object) === proto;\n}\n\nexport { isPlainObject };\n","import { cloneDeep } from './cloneDeep.mjs';\nimport { clone } from '../../object/clone.mjs';\nimport { isPrimitive } from '../../predicate/isPrimitive.mjs';\nimport { getSymbols } from '../_internal/getSymbols.mjs';\nimport { isArguments } from '../predicate/isArguments.mjs';\nimport { isObjectLike } from '../predicate/isObjectLike.mjs';\nimport { isPlainObject } from '../predicate/isPlainObject.mjs';\nimport { isTypedArray } from '../predicate/isTypedArray.mjs';\n\nfunction mergeWith(object, ...otherArgs) {\n    const sources = otherArgs.slice(0, -1);\n    const merge = otherArgs[otherArgs.length - 1];\n    let result = object;\n    for (let i = 0; i < sources.length; i++) {\n        const source = sources[i];\n        result = mergeWithDeep(result, source, merge, new Map());\n    }\n    return result;\n}\nfunction mergeWithDeep(target, source, merge, stack) {\n    if (isPrimitive(target)) {\n        target = Object(target);\n    }\n    if (source == null || typeof source !== 'object') {\n        return target;\n    }\n    if (stack.has(source)) {\n        return clone(stack.get(source));\n    }\n    stack.set(source, target);\n    if (Array.isArray(source)) {\n        source = source.slice();\n        for (let i = 0; i < source.length; i++) {\n            source[i] = source[i] ?? undefined;\n        }\n    }\n    const sourceKeys = [...Object.keys(source), ...getSymbols(source)];\n    for (let i = 0; i < sourceKeys.length; i++) {\n        const key = sourceKeys[i];\n        let sourceValue = source[key];\n        let targetValue = target[key];\n        if (isArguments(sourceValue)) {\n            sourceValue = { ...sourceValue };\n        }\n        if (isArguments(targetValue)) {\n            targetValue = { ...targetValue };\n        }\n        if (typeof Buffer !== 'undefined' && Buffer.isBuffer(sourceValue)) {\n            sourceValue = cloneDeep(sourceValue);\n        }\n        if (Array.isArray(sourceValue)) {\n            if (typeof targetValue === 'object' && targetValue != null) {\n                const cloned = [];\n                const targetKeys = Reflect.ownKeys(targetValue);\n                for (let i = 0; i < targetKeys.length; i++) {\n                    const targetKey = targetKeys[i];\n                    cloned[targetKey] = targetValue[targetKey];\n                }\n                targetValue = cloned;\n            }\n            else {\n                targetValue = [];\n            }\n        }\n        const merged = merge(targetValue, sourceValue, key, target, source, stack);\n        if (merged != null) {\n            target[key] = merged;\n        }\n        else if (Array.isArray(sourceValue)) {\n            target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\n        }\n        else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {\n            target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\n        }\n        else if (targetValue == null && isPlainObject(sourceValue)) {\n            target[key] = mergeWithDeep({}, sourceValue, merge, stack);\n        }\n        else if (targetValue == null && isTypedArray(sourceValue)) {\n            target[key] = cloneDeep(sourceValue);\n        }\n        else if (targetValue === undefined || sourceValue !== undefined) {\n            target[key] = sourceValue;\n        }\n    }\n    return target;\n}\n\nexport { mergeWith };\n","import { mergeWith } from './mergeWith.mjs';\nimport { noop } from '../../function/noop.mjs';\n\nfunction merge(object, ...sources) {\n    return mergeWith(object, ...sources, noop);\n}\n\nexport { merge };\n","import { SessionTypes } from \"@walletconnect/types\";\nimport {\n  isCaipNamespace,\n  isValidObject,\n  mergeArrays,\n  parseChainId,\n  parseNamespaceKey,\n} from \"@walletconnect/utils\";\nimport { RPC_URL } from \"../constants\";\nimport { Namespace, NamespaceConfig } from \"../types\";\nimport { merge } from \"es-toolkit/compat\";\n\nexport function getRpcUrl(chainId: string, rpc: Namespace, projectId?: string): string | undefined {\n  const chain = parseChainId(chainId);\n  return (\n    rpc.rpcMap?.[chain.reference] ||\n    `${RPC_URL}?chainId=${chain.namespace}:${chain.reference}&projectId=${projectId}`\n  );\n}\n\nexport function getChainId(chain: string): string {\n  return chain.includes(\":\") ? chain.split(\":\")[1] : chain;\n}\n\nexport function validateChainApproval(chain: string, chains: string[]): void {\n  if (!chains.includes(chain)) {\n    throw new Error(\n      `Chain '${chain}' not approved. Please use one of the following: ${chains.toString()}`,\n    );\n  }\n}\n\nexport function getChainsFromApprovedSession(accounts: string[]): string[] {\n  return accounts.map((address) => `${address.split(\":\")[0]}:${address.split(\":\")[1]}`);\n}\n\nexport function getAccountsFromSession(namespace: string, session: SessionTypes.Struct): string[] {\n  // match namespaces e.g. eip155 with eip155:1\n  const matchedNamespaceKeys = Object.keys(session.namespaces).filter((key) =>\n    key.includes(namespace),\n  );\n  if (!matchedNamespaceKeys.length) return [];\n  const accounts: string[] = [];\n  matchedNamespaceKeys.forEach((key) => {\n    const accountsForNamespace = session.namespaces[key].accounts;\n    accounts.push(...accountsForNamespace);\n  });\n  return accounts;\n}\n\nexport function mergeRequiredOptionalNamespaces(\n  required: NamespaceConfig = {},\n  optional: NamespaceConfig = {},\n) {\n  const requiredNamespaces = normalizeNamespaces(required);\n  const optionalNamespaces = normalizeNamespaces(optional);\n  return merge(requiredNamespaces, optionalNamespaces);\n}\n\n/**\n * Converts\n * {\n *  \"eip155:1\": {...},\n *  \"eip155:2\": {...},\n * }\n * into\n * {\n *  \"eip155\": {\n *      chains: [\"eip155:1\", \"eip155:2\"],\n *      ...\n *    }\n * }\n *\n */\nexport function normalizeNamespaces(namespaces: NamespaceConfig): NamespaceConfig {\n  const normalizedNamespaces: NamespaceConfig = {};\n  if (!isValidObject(namespaces)) return normalizedNamespaces;\n\n  for (const [key, values] of Object.entries(namespaces)) {\n    const chains = isCaipNamespace(key) ? [key] : values.chains;\n    const methods = values.methods || [];\n    const events = values.events || [];\n    const rpcMap = values.rpcMap || {};\n    const normalizedKey = parseNamespaceKey(key);\n    normalizedNamespaces[normalizedKey] = {\n      ...normalizedNamespaces[normalizedKey],\n      ...values,\n      chains: mergeArrays(chains, normalizedNamespaces[normalizedKey]?.chains),\n      methods: mergeArrays(methods, normalizedNamespaces[normalizedKey]?.methods),\n      events: mergeArrays(events, normalizedNamespaces[normalizedKey]?.events),\n    };\n    // avoid adding empty `rpcMap: {}` if there are no values for it\n    if (isValidObject(rpcMap) || isValidObject(normalizedNamespaces[normalizedKey]?.rpcMap || {})) {\n      normalizedNamespaces[normalizedKey].rpcMap = {\n        ...rpcMap,\n        ...normalizedNamespaces[normalizedKey]?.rpcMap,\n      };\n    }\n  }\n  return normalizedNamespaces;\n}\n\nexport function parseCaip10Account(caip10Account: string): string {\n  return caip10Account.includes(\":\") ? caip10Account.split(\":\")[2] : caip10Account;\n}\n\n/**\n * Populates the chains array for each namespace with the chains extracted from the accounts if are otherwise missing\n */\nexport function populateNamespacesChains(\n  namespaces: SessionTypes.Namespaces,\n): Record<string, SessionTypes.Namespace> {\n  const parsedNamespaces: Record<string, SessionTypes.Namespace> = {};\n  for (const [key, values] of Object.entries(namespaces)) {\n    const methods = values.methods || [];\n    const events = values.events || [];\n    const accounts = values.accounts || [];\n    // If the key includes a CAIP separator `:` we know it's a namespace + chainId (e.g. `eip155:1`)\n    const chains = isCaipNamespace(key)\n      ? [key]\n      : values.chains\n        ? values.chains\n        : getChainsFromApprovedSession(values.accounts);\n    parsedNamespaces[key] = {\n      chains,\n      methods,\n      events,\n      accounts,\n    };\n  }\n  return parsedNamespaces;\n}\n\nexport function convertChainIdToNumber(chainId: string | number): number | string {\n  if (typeof chainId === \"number\") return chainId;\n  if (chainId.includes(\"0x\")) {\n    return parseInt(chainId, 16);\n  }\n\n  chainId = chainId.includes(\":\") ? chainId.split(\":\")[1] : chainId;\n  return isNaN(Number(chainId)) ? chainId : Number(chainId);\n}\n","const globals = {};\nexport const getGlobal = (key: string) => {\n  return globals[key];\n};\n\nexport const setGlobal = (key: string, value: unknown) => {\n  globals[key] = value;\n};\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\n\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\nclass PolkadotProvider implements IProvider {\n  public name = \"polkadot\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  // ---------------- PRIVATE ---------------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return (\n      accounts\n        // get the accounts from the active chain\n        .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n        // remove namespace & chainId from the string\n        .map((account) => account.split(\":\")[2]) || []\n    );\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default PolkadotProvider;\n","import Client from \"@walletconnect/sign-client\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport { HttpConnection } from \"@walletconnect/jsonrpc-http-connection\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\n\nimport {\n  IProvider,\n  RpcProvidersMap,\n  SubProviderOpts,\n  RequestParams,\n  SessionNamespace,\n} from \"../types\";\n\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\nimport EventEmitter from \"events\";\nimport { BUNDLER_URL, PROVIDER_EVENTS } from \"../constants\";\nimport { formatJsonRpcRequest } from \"@walletconnect/jsonrpc-utils\";\n\nclass Eip155Provider implements IProvider {\n  public name = \"eip155\";\n  public client: Client;\n  // the active chainId on the dapp\n  public chainId: number;\n  public namespace: SessionNamespace;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.httpProviders = this.createHttpProviders();\n    this.chainId = parseInt(this.getDefaultChain());\n  }\n\n  public async request<T = unknown>(args: RequestParams): Promise<T> {\n    switch (args.request.method) {\n      case \"eth_requestAccounts\":\n        return this.getAccounts() as unknown as T;\n      case \"eth_accounts\":\n        return this.getAccounts() as unknown as T;\n      case \"wallet_switchEthereumChain\": {\n        return (await this.handleSwitchChain(args)) as unknown as T;\n      }\n      case \"eth_chainId\":\n        return parseInt(this.getDefaultChain()) as unknown as T;\n      case \"wallet_getCapabilities\":\n        return (await this.getCapabilities(args)) as unknown as T;\n      case \"wallet_getCallsStatus\":\n        return (await this.getCallStatus(args)) as unknown as T;\n      default:\n        break;\n    }\n    if (this.namespace.methods.includes(args.request.method)) {\n      return await this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(parseInt(chainId), rpcUrl);\n    }\n    this.chainId = parseInt(chainId);\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId.toString();\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private createHttpProvider(\n    chainId: number,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc =\n      rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n\n  private setHttpProvider(chainId: number, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChain = parseInt(getChainId(chain));\n      http[parsedChain] = this.createHttpProvider(parsedChain, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = this.chainId;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private async handleSwitchChain(args: RequestParams): Promise<any> {\n    let hexChainId = args.request.params ? args.request.params[0]?.chainId : \"0x0\";\n    hexChainId = hexChainId.startsWith(\"0x\") ? hexChainId : `0x${hexChainId}`;\n    const parsedChainId = parseInt(hexChainId, 16);\n    // if chainId is already approved, switch locally\n    if (this.isChainApproved(parsedChainId)) {\n      this.setDefaultChain(`${parsedChainId}`);\n    } else if (this.namespace.methods.includes(\"wallet_switchEthereumChain\")) {\n      // try to switch chain within the wallet\n      await this.client.request({\n        topic: args.topic,\n        request: {\n          method: args.request.method,\n          params: [\n            {\n              chainId: hexChainId,\n            },\n          ],\n        },\n        chainId: this.namespace.chains?.[0], // Sending a previously unapproved chainId will cause namespace validation failure so we must set request chainId to the first chainId in the namespace to avoid it\n      } as EngineTypes.RequestParams);\n      this.setDefaultChain(`${parsedChainId}`);\n    } else {\n      throw new Error(\n        `Failed to switch to chain 'eip155:${parsedChainId}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`,\n      );\n    }\n    return null;\n  }\n\n  private isChainApproved(chainId: number): boolean {\n    return this.namespace.chains.includes(`${this.name}:${chainId}`);\n  }\n\n  private async getCapabilities(args: RequestParams) {\n    // if capabilities are stored in the session, return them, else send the request to the wallet\n    const address = args.request?.params?.[0];\n    const chainIds: string[] = args.request?.params?.[1] || [];\n\n    // cache key is address + chainIds to allow requests to be made to different chains\n    const capabilitiesKey = `${address}${chainIds.join(\",\")}`;\n    if (!address) throw new Error(\"Missing address parameter in `wallet_getCapabilities` request\");\n    const session = this.client.session.get(args.topic);\n    const sessionCapabilities = session?.sessionProperties?.capabilities || {};\n\n    if (sessionCapabilities?.[capabilitiesKey]) {\n      return sessionCapabilities?.[capabilitiesKey];\n    }\n\n    // intentionally omit catching errors/rejection during `request` to allow the error to bubble up\n    const capabilities = await this.client.request(args as EngineTypes.RequestParams);\n    try {\n      // update the session with the capabilities so they can be retrieved later\n      await this.client.session.update(args.topic, {\n        sessionProperties: {\n          ...(session.sessionProperties || {}),\n          capabilities: {\n            ...(sessionCapabilities || {}),\n            [capabilitiesKey]: capabilities,\n          } as any, // by spec sessionProperties should be <string, string> but here are used as objects?\n        },\n      });\n    } catch (error) {\n      console.warn(\"Failed to update session with capabilities\", error);\n    }\n    return capabilities;\n  }\n\n  private async getCallStatus(args: RequestParams) {\n    const session = this.client.session.get(args.topic);\n    const bundlerName = session.sessionProperties?.bundler_name;\n    if (bundlerName) {\n      const bundlerUrl = this.getBundlerUrl(args.chainId, bundlerName);\n      try {\n        return await this.getUserOperationReceipt(bundlerUrl, args);\n      } catch (error) {\n        console.warn(\"Failed to fetch call status from bundler\", error, bundlerUrl);\n      }\n    }\n    const customUrl = session.sessionProperties?.bundler_url;\n    if (customUrl) {\n      try {\n        return await this.getUserOperationReceipt(customUrl, args);\n      } catch (error) {\n        console.warn(\"Failed to fetch call status from custom bundler\", error, customUrl);\n      }\n    }\n\n    if (this.namespace.methods.includes(args.request.method)) {\n      return await this.client.request(args as EngineTypes.RequestParams);\n    }\n\n    throw new Error(\"Fetching call status not approved by the wallet.\");\n  }\n\n  private async getUserOperationReceipt(bundlerUrl: string, args: RequestParams) {\n    const url = new URL(bundlerUrl);\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(\n        formatJsonRpcRequest(\"eth_getUserOperationReceipt\", [args.request.params?.[0]]),\n      ),\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch user operation receipt - ${response.status}`);\n    }\n    return await response.json();\n  }\n\n  private getBundlerUrl(cap2ChainId: string, bundlerName: string) {\n    return `${BUNDLER_URL}?projectId=${this.client.core.projectId}&chainId=${cap2ChainId}&bundler=${bundlerName}`;\n  }\n}\n\nexport default Eip155Provider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\nclass SolanaProvider implements IProvider {\n  public name = \"solana\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default SolanaProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\nclass CosmosProvider implements IProvider {\n  public name = \"cosmos\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  // ---------------- PRIVATE ---------------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default CosmosProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getGlobal, getRpcUrl } from \"../utils\";\n\nclass AlgorandProvider implements IProvider {\n  public name = \"algorand\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      const rpc =\n        rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace, this.client.core.projectId);\n      if (!rpc) {\n        throw new Error(`No RPC url provided for chainId: ${chainId}`);\n      }\n      this.setHttpProvider(chainId, rpc);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      http[chain] = this.createHttpProvider(chain, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (typeof rpc === \"undefined\") return undefined;\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default AlgorandProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal } from \"../utils\";\n\nclass CardanoProvider implements IProvider {\n  public name = \"cip34\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  // ------------- PRIVATE -------------- /\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const rpcURL = this.getCardanoRPCUrl(chain);\n      const parsedChain = getChainId(chain);\n      http[parsedChain] = this.createHttpProvider(parsedChain, rpcURL);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private getCardanoRPCUrl(chainId: string): string | undefined {\n    const rpcMap = this.namespace.rpcMap;\n    if (!rpcMap) return undefined;\n    return rpcMap[chainId];\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || this.getCardanoRPCUrl(chainId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default CardanoProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\n// Old wallet connect provider for Elrond\nclass ElrondProvider implements IProvider {\n  public name = \"elrond\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default ElrondProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\nclass MultiversXProvider implements IProvider {\n  public name = \"multiversx\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default MultiversXProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getGlobal, getRpcUrl } from \"../utils\";\n\nclass NearProvider implements IProvider {\n  public name = \"near\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    this.chainId = chainId;\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      const rpc = rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace);\n      if (!rpc) {\n        throw new Error(`No RPC url provided for chainId: ${chainId}`);\n      }\n      this.setHttpProvider(chainId, rpc);\n    }\n\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  // ---------------- PRIVATE ---------------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return (\n      accounts\n        // get the accounts from the active chain\n        .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n        // remove namespace & chainId from the string\n        .map((account) => account.split(\":\")[2]) || []\n    );\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      http[chain] = this.createHttpProvider(chain, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace);\n    if (typeof rpc === \"undefined\") return undefined;\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default NearProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\n\nimport { getRpcUrl, getGlobal } from \"../utils\";\n\nclass TezosProvider implements IProvider {\n  public name = \"tezos\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    this.chainId = chainId;\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      const rpc = rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace);\n      if (!rpc) {\n        throw new Error(`No RPC url provided for chainId: ${chainId}`);\n      }\n      this.setHttpProvider(chainId, rpc);\n    }\n\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  // ---------------- PRIVATE ---------------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return (\n      accounts\n        // get the accounts from the active chain\n        .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n        // remove namespace & chainId from the string\n        .map((account) => account.split(\":\")[2]) || []\n    );\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http: any = {};\n    this.namespace.chains.forEach((chain) => {\n      http[chain] = this.createHttpProvider(chain);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace);\n    if (typeof rpc === \"undefined\") return undefined;\n    const http = new JsonRpcProvider(new HttpConnection(rpc));\n    return http;\n  }\n}\n\nexport default TezosProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { GENERIC_SUBPROVIDER_NAME, PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getGlobal, getRpcUrl } from \"../utils\";\nimport { parseChainId } from \"@walletconnect/utils\";\n\nclass GenericProvider implements IProvider {\n  public name = GENERIC_SUBPROVIDER_NAME;\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace.chains = [\n      ...new Set((this.namespace.chains || []).concat(namespace.chains || [])),\n    ];\n    this.namespace.accounts = [\n      ...new Set((this.namespace.accounts || []).concat(namespace.accounts || [])),\n    ];\n    this.namespace.methods = [\n      ...new Set((this.namespace.methods || []).concat(namespace.methods || [])),\n    ];\n    this.namespace.events = [\n      ...new Set((this.namespace.events || []).concat(namespace.events || [])),\n    ];\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider(args.chainId).request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace?.accounts?.forEach((account) => {\n      const chain = parseChainId(account);\n      http[`${chain.namespace}:${chain.reference}`] = this.createHttpProvider(account);\n    });\n    return http;\n  }\n\n  private getHttpProvider(chain: string): JsonRpcProvider {\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(chainId: string, rpcUrl?: string): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default GenericProvider;\n","import SignClient from \"@walletconnect/sign-client\";\nimport { SessionTypes } from \"@walletconnect/types\";\nimport { JsonRpcResult } from \"@walletconnect/jsonrpc-types\";\nimport { getSdkError, isValidArray, parseNamespaceKey } from \"@walletconnect/utils\";\nimport { getDefaultLoggerOptions, Logger, pino } from \"@walletconnect/logger\";\nimport {\n  convertChainIdToNumber,\n  getAccountsFromSession,\n  getChainsFromApprovedSession,\n  mergeRequiredOptionalNamespaces,\n  parseCaip10Account,\n  populateNamespacesChains,\n  setGlobal,\n} from \"./utils\";\nimport PolkadotProvider from \"./providers/polkadot\";\nimport Eip155Provider from \"./providers/eip155\";\nimport SolanaProvider from \"./providers/solana\";\nimport CosmosProvider from \"./providers/cosmos\";\nimport AlgorandProvider from \"./providers/algorand\";\nimport CardanoProvider from \"./providers/cardano\";\nimport ElrondProvider from \"./providers/elrond\";\nimport MultiversXProvider from \"./providers/multiversx\";\nimport NearProvider from \"./providers/near\";\nimport TezosProvider from \"./providers/tezos\";\nimport GenericProvider from \"./providers/generic\";\n\nimport {\n  IUniversalProvider,\n  IProvider,\n  RpcProviderMap,\n  ConnectParams,\n  RequestArguments,\n  UniversalProviderOpts,\n  NamespaceConfig,\n  PairingsCleanupOpts,\n  ProviderAccounts,\n  AuthenticateParams,\n} from \"./types\";\n\nimport { RELAY_URL, LOGGER, STORAGE, PROVIDER_EVENTS, GENERIC_SUBPROVIDER_NAME } from \"./constants\";\nimport EventEmitter from \"events\";\nimport { formatJsonRpcResult } from \"@walletconnect/jsonrpc-utils\";\n\nexport class UniversalProvider implements IUniversalProvider {\n  public client!: SignClient;\n  public namespaces?: NamespaceConfig;\n  public optionalNamespaces?: NamespaceConfig;\n  public sessionProperties?: SessionTypes.SessionProperties;\n  public scopedProperties?: SessionTypes.ScopedProperties;\n  public events: EventEmitter = new EventEmitter();\n  public rpcProviders: RpcProviderMap = {};\n  public session?: SessionTypes.Struct;\n  public providerOpts: UniversalProviderOpts;\n  public logger: Logger;\n  public uri: string | undefined;\n\n  private disableProviderPing = false;\n\n  static async init(opts: UniversalProviderOpts) {\n    const provider = new UniversalProvider(opts);\n    await provider.initialize();\n    return provider;\n  }\n\n  constructor(opts: UniversalProviderOpts) {\n    this.providerOpts = opts;\n    this.logger =\n      typeof opts?.logger !== \"undefined\" && typeof opts?.logger !== \"string\"\n        ? opts.logger\n        : pino(getDefaultLoggerOptions({ level: opts?.logger || LOGGER }));\n    this.disableProviderPing = opts?.disableProviderPing || false;\n  }\n\n  public async request<T = unknown>(\n    args: RequestArguments,\n    chain?: string | undefined,\n    expiry?: number | undefined,\n  ): Promise<T> {\n    const [namespace, chainId] = this.validateChain(chain);\n\n    if (!this.session) {\n      throw new Error(\"Please call connect() before request()\");\n    }\n\n    return await this.getProvider(namespace).request({\n      request: {\n        ...args,\n      },\n      chainId: `${namespace}:${chainId}`,\n      topic: this.session.topic,\n      expiry,\n    });\n  }\n\n  public sendAsync(\n    args: RequestArguments,\n    callback: (error: Error | null, response: JsonRpcResult) => void,\n    chain?: string | undefined,\n    expiry?: number | undefined,\n  ): void {\n    const id = new Date().getTime();\n    this.request(args, chain, expiry)\n      .then((response) => callback(null, formatJsonRpcResult(id, response)))\n      .catch((error) => callback(error, undefined as any));\n  }\n\n  public async enable(): Promise<ProviderAccounts> {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n    if (!this.session) {\n      await this.connect({\n        namespaces: this.namespaces,\n        optionalNamespaces: this.optionalNamespaces,\n        sessionProperties: this.sessionProperties,\n        scopedProperties: this.scopedProperties,\n      });\n    }\n    const accounts = await this.requestAccounts();\n    return accounts as ProviderAccounts;\n  }\n\n  public async disconnect(): Promise<void> {\n    if (!this.session) {\n      throw new Error(\"Please call connect() before enable()\");\n    }\n    await this.client.disconnect({\n      topic: this.session?.topic,\n      reason: getSdkError(\"USER_DISCONNECTED\"),\n    });\n    await this.cleanup();\n  }\n\n  public async connect(opts: ConnectParams): Promise<SessionTypes.Struct | undefined> {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n    this.setNamespaces(opts);\n    await this.cleanupPendingPairings();\n    if (opts.skipPairing) return;\n\n    return await this.pair(opts.pairingTopic);\n  }\n\n  public async authenticate(opts: AuthenticateParams, walletUniversalLink?: string) {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n    this.setNamespaces(opts);\n    await this.cleanupPendingPairings();\n\n    const { uri, response } = await this.client.authenticate(opts, walletUniversalLink);\n    if (uri) {\n      this.uri = uri;\n      this.events.emit(\"display_uri\", uri);\n    }\n    const result = await response();\n    this.session = result.session;\n    if (this.session) {\n      // assign namespaces from session if not already defined\n      const approved = populateNamespacesChains(this.session.namespaces) as NamespaceConfig;\n      this.namespaces = mergeRequiredOptionalNamespaces(this.namespaces, approved);\n      await this.persist(\"namespaces\", this.namespaces);\n      this.onConnect();\n    }\n    return result;\n  }\n\n  public on(event: any, listener: any): void {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any): void {\n    this.events.once(event, listener);\n  }\n\n  public removeListener(event: string, listener: any): void {\n    this.events.removeListener(event, listener);\n  }\n\n  public off(event: string, listener: any): void {\n    this.events.off(event, listener);\n  }\n\n  get isWalletConnect() {\n    return true;\n  }\n\n  public async pair(pairingTopic: string | undefined): Promise<SessionTypes.Struct> {\n    const { uri, approval } = await this.client.connect({\n      pairingTopic,\n      requiredNamespaces: this.namespaces,\n      optionalNamespaces: this.optionalNamespaces,\n      sessionProperties: this.sessionProperties,\n      scopedProperties: this.scopedProperties,\n    });\n\n    if (uri) {\n      this.uri = uri;\n      this.events.emit(\"display_uri\", uri);\n    }\n\n    const session = await approval();\n    this.session = session;\n    // assign namespaces from session if not already defined\n    const approved = populateNamespacesChains(session.namespaces) as NamespaceConfig;\n    this.namespaces = mergeRequiredOptionalNamespaces(this.namespaces, approved);\n    await this.persist(\"namespaces\", this.namespaces);\n    await this.persist(\"optionalNamespaces\", this.optionalNamespaces);\n\n    this.onConnect();\n    return this.session;\n  }\n\n  public setDefaultChain(chain: string, rpcUrl?: string | undefined) {\n    try {\n      // ignore without active session\n      if (!this.session) return;\n      const [namespace, chainId] = this.validateChain(chain);\n      const provider = this.getProvider(namespace);\n      // @ts-expect-error\n      if (provider.name === GENERIC_SUBPROVIDER_NAME) {\n        provider.setDefaultChain(`${namespace}:${chainId}`, rpcUrl);\n      } else {\n        provider.setDefaultChain(chainId, rpcUrl);\n      }\n    } catch (error) {\n      // ignore the error if the fx is used prematurely before namespaces are set\n      if (!/Please call connect/.test((error as Error).message)) throw error;\n    }\n  }\n\n  public async cleanupPendingPairings(opts: PairingsCleanupOpts = {}): Promise<void> {\n    this.logger.info(\"Cleaning up inactive pairings...\");\n    const inactivePairings = this.client.pairing.getAll();\n\n    if (!isValidArray(inactivePairings)) return;\n\n    for (const pairing of inactivePairings) {\n      if (opts.deletePairings) {\n        this.client.core.expirer.set(pairing.topic, 0);\n      } else {\n        await this.client.core.relayer.subscriber.unsubscribe(pairing.topic);\n      }\n    }\n\n    this.logger.info(`Inactive pairings cleared: ${inactivePairings.length}`);\n  }\n\n  public abortPairingAttempt() {\n    this.logger.warn(\"abortPairingAttempt is deprecated. This is now a no-op.\");\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async checkStorage() {\n    this.namespaces = (await this.getFromStore(`namespaces`)) || {};\n    this.optionalNamespaces = (await this.getFromStore(`optionalNamespaces`)) || {};\n    if (this.session) this.createProviders();\n  }\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    await this.createClient();\n    await this.checkStorage();\n    this.registerEventListeners();\n  }\n\n  private async createClient() {\n    this.client =\n      this.providerOpts.client ||\n      (await SignClient.init({\n        core: this.providerOpts.core,\n        logger: this.providerOpts.logger || LOGGER,\n        relayUrl: this.providerOpts.relayUrl || RELAY_URL,\n        projectId: this.providerOpts.projectId,\n        metadata: this.providerOpts.metadata,\n        storageOptions: this.providerOpts.storageOptions,\n        storage: this.providerOpts.storage,\n        name: this.providerOpts.name,\n        customStoragePrefix: this.providerOpts.customStoragePrefix,\n        telemetryEnabled: this.providerOpts.telemetryEnabled,\n      }));\n\n    if (this.providerOpts.session) {\n      try {\n        this.session = this.client.session.get(this.providerOpts.session.topic);\n      } catch (error) {\n        this.logger.error(\"Failed to get session\", error);\n        throw new Error(\n          `The provided session: ${this.providerOpts?.session?.topic} doesn't exist in the Sign client`,\n        );\n      }\n    } else {\n      const sessions = this.client.session.getAll();\n      this.session = sessions[0];\n    }\n    this.logger.trace(`SignClient Initialized`);\n  }\n\n  private createProviders(): void {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n\n    if (!this.session) {\n      throw new Error(\"Session not initialized. Please call connect() before enable()\");\n    }\n\n    const providersToCreate = [\n      ...new Set(\n        Object.keys(this.session.namespaces).map((namespace) => parseNamespaceKey(namespace)),\n      ),\n    ];\n\n    setGlobal(\"client\", this.client);\n    setGlobal(\"events\", this.events);\n    setGlobal(\"disableProviderPing\", this.disableProviderPing);\n\n    providersToCreate.forEach((namespace) => {\n      if (!this.session) return;\n      const accounts = getAccountsFromSession(namespace, this.session);\n      const approvedChains = getChainsFromApprovedSession(accounts);\n      const mergedNamespaces = mergeRequiredOptionalNamespaces(\n        this.namespaces,\n        this.optionalNamespaces,\n      );\n      const combinedNamespace = {\n        ...mergedNamespaces[namespace],\n        accounts,\n        chains: approvedChains,\n      };\n      switch (namespace) {\n        case \"eip155\":\n          this.rpcProviders[namespace] = new Eip155Provider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"algorand\":\n          this.rpcProviders[namespace] = new AlgorandProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"solana\":\n          this.rpcProviders[namespace] = new SolanaProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"cosmos\":\n          this.rpcProviders[namespace] = new CosmosProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"polkadot\":\n          this.rpcProviders[namespace] = new PolkadotProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"cip34\":\n          this.rpcProviders[namespace] = new CardanoProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"elrond\":\n          this.rpcProviders[namespace] = new ElrondProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"multiversx\":\n          this.rpcProviders[namespace] = new MultiversXProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"near\":\n          this.rpcProviders[namespace] = new NearProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"tezos\":\n          this.rpcProviders[namespace] = new TezosProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        default:\n          if (!this.rpcProviders[GENERIC_SUBPROVIDER_NAME]) {\n            this.rpcProviders[GENERIC_SUBPROVIDER_NAME] = new GenericProvider({\n              namespace: combinedNamespace,\n            });\n          } else {\n            this.rpcProviders[GENERIC_SUBPROVIDER_NAME].updateNamespace(combinedNamespace);\n          }\n      }\n    });\n  }\n\n  private registerEventListeners(): void {\n    if (typeof this.client === \"undefined\") {\n      throw new Error(\"Sign Client is not initialized\");\n    }\n\n    this.client.on(\"session_ping\", (args) => {\n      const { topic } = args;\n      if (topic !== this.session?.topic) return;\n      this.events.emit(\"session_ping\", args);\n    });\n\n    this.client.on(\"session_event\", (args) => {\n      const { params, topic } = args;\n      if (topic !== this.session?.topic) return;\n      const { event } = params;\n      if (event.name === \"accountsChanged\") {\n        const accounts = event.data;\n        if (accounts && isValidArray(accounts))\n          this.events.emit(\"accountsChanged\", accounts.map(parseCaip10Account));\n      } else if (event.name === \"chainChanged\") {\n        const requestChainId = params.chainId;\n        const payloadChainId = params.event.data as number;\n        const namespace = parseNamespaceKey(requestChainId);\n        // chainIds might differ between the request & payload - request is always in CAIP2 format, while payload might be string, number, CAIP2 or hex\n        // take priority of the payload chainId\n        const chainIdToProcess =\n          convertChainIdToNumber(requestChainId) !== convertChainIdToNumber(payloadChainId)\n            ? `${namespace}:${convertChainIdToNumber(payloadChainId)}`\n            : requestChainId;\n\n        this.onChainChanged(chainIdToProcess);\n      } else {\n        this.events.emit(event.name, event.data);\n      }\n\n      this.events.emit(\"session_event\", args);\n    });\n\n    this.client.on(\"session_update\", ({ topic, params }) => {\n      if (topic !== this.session?.topic) return;\n      const { namespaces } = params;\n      const _session = this.client?.session.get(topic);\n      this.session = { ..._session, namespaces } as SessionTypes.Struct;\n      this.onSessionUpdate();\n      this.events.emit(\"session_update\", { topic, params });\n    });\n\n    this.client.on(\"session_delete\", async (payload) => {\n      if (payload.topic !== this.session?.topic) return;\n      await this.cleanup();\n      this.events.emit(\"session_delete\", payload);\n      this.events.emit(\"disconnect\", {\n        ...getSdkError(\"USER_DISCONNECTED\"),\n        data: payload.topic,\n      });\n    });\n\n    this.on(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, (caip2ChainId: string) => {\n      this.onChainChanged(caip2ChainId, true);\n    });\n  }\n\n  private getProvider(namespace: string): IProvider {\n    return this.rpcProviders[namespace] || this.rpcProviders[GENERIC_SUBPROVIDER_NAME];\n  }\n\n  private onSessionUpdate(): void {\n    Object.keys(this.rpcProviders).forEach((namespace: string) => {\n      this.getProvider(namespace).updateNamespace(\n        this.session?.namespaces[namespace] as SessionTypes.BaseNamespace,\n      );\n    });\n  }\n\n  private setNamespaces(params: ConnectParams): void {\n    const {\n      namespaces = {},\n      optionalNamespaces = {},\n      sessionProperties,\n      scopedProperties,\n    } = params;\n\n    // requiredNamespaces are deprecated, assign them to optionalNamespaces\n    this.optionalNamespaces = mergeRequiredOptionalNamespaces(namespaces, optionalNamespaces);\n    this.sessionProperties = sessionProperties;\n    this.scopedProperties = scopedProperties;\n  }\n\n  private validateChain(chain?: string): [string, string] {\n    const [namespace, chainId] = chain?.split(\":\") || [\"\", \"\"];\n    if (!this.namespaces || !Object.keys(this.namespaces).length) return [namespace, chainId];\n    // validate namespace\n    if (namespace) {\n      if (\n        // some namespaces might be defined with inline chainId e.g. eip155:1\n        // and we need to parse them\n        !Object.keys(this.namespaces || {})\n          .map((key) => parseNamespaceKey(key))\n          .includes(namespace)\n      ) {\n        throw new Error(\n          `Namespace '${namespace}' is not configured. Please call connect() first with namespace config.`,\n        );\n      }\n    }\n    if (namespace && chainId) {\n      return [namespace, chainId];\n    }\n    const defaultNamespace = parseNamespaceKey(Object.keys(this.namespaces)[0]);\n    const defaultChain = this.rpcProviders[defaultNamespace].getDefaultChain();\n    return [defaultNamespace, defaultChain];\n  }\n\n  private async requestAccounts(): Promise<string[]> {\n    const [namespace] = this.validateChain();\n    return await this.getProvider(namespace).requestAccounts();\n  }\n\n  private async onChainChanged(caip2Chain: string, internal = false): Promise<void> {\n    if (!this.namespaces) return;\n\n    const [namespace, chainId] = this.validateChain(caip2Chain);\n\n    if (!chainId) return;\n\n    this.updateNamespaceChain(namespace, chainId);\n\n    this.events.emit(\"chainChanged\", chainId);\n\n    const previousChainId = this.getProvider(namespace).getDefaultChain();\n    if (!internal) {\n      this.getProvider(namespace).setDefaultChain(chainId);\n    }\n\n    this.emitAccountsChangedOnChainChange({ namespace, previousChainId, newChainId: caip2Chain });\n    await this.persist(\"namespaces\", this.namespaces);\n  }\n\n  /**\n   * Emits `accountsChanged` event when a chain is changed and there are new accounts on the new chain\n   */\n  private emitAccountsChangedOnChainChange({\n    namespace,\n    previousChainId,\n    newChainId,\n  }: {\n    namespace: string;\n    previousChainId: string;\n    newChainId: string;\n  }): void {\n    try {\n      if (previousChainId === newChainId) {\n        return;\n      }\n\n      const accounts = this.session?.namespaces[namespace]?.accounts;\n      if (!accounts) return;\n      const newChainIdAccounts = accounts\n        .filter((account) => account.includes(`${newChainId}:`))\n        .map(parseCaip10Account);\n      if (!isValidArray(newChainIdAccounts)) return;\n      this.events.emit(\"accountsChanged\", newChainIdAccounts);\n    } catch (error) {\n      this.logger.warn(\"Failed to emit accountsChanged on chain change\", error);\n    }\n  }\n\n  private updateNamespaceChain(namespace: string, chainId: string): void {\n    if (!this.namespaces) return;\n\n    const namespaceKey = this.namespaces[namespace] ? namespace : `${namespace}:${chainId}`;\n\n    const defaultNamespace = {\n      chains: [],\n      methods: [],\n      events: [],\n      defaultChain: chainId,\n    };\n\n    if (!this.namespaces[namespaceKey]) {\n      this.namespaces[namespaceKey] = defaultNamespace;\n    } else if (this.namespaces[namespaceKey]) {\n      this.namespaces[namespaceKey].defaultChain = chainId;\n    }\n  }\n\n  private onConnect() {\n    this.createProviders();\n    this.events.emit(\"connect\", { session: this.session });\n  }\n\n  private async cleanup() {\n    this.namespaces = undefined;\n    this.optionalNamespaces = undefined;\n    this.sessionProperties = undefined;\n    await this.deleteFromStore(\"namespaces\");\n    await this.deleteFromStore(\"optionalNamespaces\");\n    await this.deleteFromStore(\"sessionProperties\");\n    // reset the session after removing from store as the topic is used there\n    this.session = undefined;\n    await this.cleanupPendingPairings({ deletePairings: true });\n    await this.cleanupStorage();\n  }\n\n  private async persist(key: string, data: unknown) {\n    const topic = this.session?.topic || \"\";\n    await this.client.core.storage.setItem(`${STORAGE}/${key}${topic}`, data);\n  }\n\n  private async getFromStore(key: string) {\n    const topic = this.session?.topic || \"\";\n    return await this.client.core.storage.getItem(`${STORAGE}/${key}${topic}`);\n  }\n\n  private async deleteFromStore(key: string) {\n    const topic = this.session?.topic || \"\";\n    await this.client.core.storage.removeItem(`${STORAGE}/${key}${topic}`);\n  }\n\n  // remove all storage items if there are no sessions left\n  private async cleanupStorage() {\n    try {\n      if (this.client?.session.length > 0) {\n        return;\n      }\n      const keys = await this.client.core.storage.getKeys();\n      for (const key of keys) {\n        if (key.startsWith(STORAGE)) {\n          await this.client.core.storage.removeItem(key);\n        }\n      }\n    } catch (error) {\n      this.logger.warn(\"Failed to cleanup storage\", error);\n    }\n  }\n}\nexport default UniversalProvider;\n","import { UniversalProvider as Provider } from \"./UniversalProvider\";\nexport * from \"./types\";\nexport const UniversalProvider = Provider;\nexport default Provider;\n"],"names":["isTypedArray","cloneDeepWith","chainId","rpc","projectId","_a","chain","parseChainId","RPC_URL","accounts","address","namespace","session","matchedNamespaceKeys","key","accountsForNamespace","required","optional","requiredNamespaces","optionalNamespaces","merge","namespaces","_b","_c","_d","_e","normalizedNamespaces","isValidObject","values","chains","isCaipNamespace","methods","events","rpcMap","normalizedKey","parseNamespaceKey","__spreadProps","__spreadValues","mergeArrays","caip10Account","parsedNamespaces","globals","value","p","a","r","PolkadotProvider","opts","__publicField","getGlobal","args","rpcUrl","PROVIDER_EVENTS","account","http","parsedChainId","getChainId","getRpcUrl","JsonRpcProvider","HttpConnection","Eip155Provider","parsedChain","hexChainId","chainIds","capabilitiesKey","sessionCapabilities","capabilities","error","bundlerName","bundlerUrl","customUrl","url","response","formatJsonRpcRequest","cap2ChainId","BUNDLER_URL","SolanaProvider","CosmosProvider","AlgorandProvider","CardanoProvider","rpcURL","ElrondProvider","MultiversXProvider","NearProvider","TezosProvider","GenericProvider","GENERIC_SUBPROVIDER_NAME","UniversalProvider","EventEmitter","pino","getDefaultLoggerOptions","LOGGER","provider","expiry","callback","id","formatJsonRpcResult","getSdkError","walletUniversalLink","uri","result","approved","populateNamespacesChains","mergeRequiredOptionalNamespaces","event","listener","pairingTopic","approval","inactivePairings","isValidArray","pairing","SignClient","RELAY_URL","sessions","providersToCreate","setGlobal","getAccountsFromSession","approvedChains","getChainsFromApprovedSession","mergedNamespaces","combinedNamespace","topic","params","parseCaip10Account","requestChainId","payloadChainId","chainIdToProcess","convertChainIdToNumber","_session","payload","caip2ChainId","sessionProperties","scopedProperties","defaultNamespace","defaultChain","caip2Chain","internal","previousChainId","newChainId","newChainIdAccounts","namespaceKey","data","STORAGE","keys","Provider"],"mappings":"","debugId":null}},
    {"offset": {"line": 14428, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@walletconnect/ethereum-provider/dist/index.es.js","sources":["file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/ethereum-provider/src/constants/values.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/ethereum-provider/src/constants/rpc.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/ethereum-provider/src/utils/appkit.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/ethereum-provider/src/EthereumProvider.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/ethereum-provider/src/index.ts","file:///C:/Users/Red/Documents/GitHub/375-arcade-test/node_modules/%40walletconnect/ethereum-provider/src/wcmToAppKit.ts"],"sourcesContent":["export const PROTOCOL = \"wc\";\nexport const WC_VERSION = 2;\nexport const CONTEXT = \"ethereum_provider\";\nexport const STORAGE_KEY = `${PROTOCOL}@${WC_VERSION}:${CONTEXT}:`;\nexport const RPC_URL = \"https://rpc.walletconnect.org/v1/\";\n","export const REQUIRED_METHODS = [\"eth_sendTransaction\", \"personal_sign\"];\nexport const OPTIONAL_METHODS = [\n  \"eth_accounts\",\n  \"eth_requestAccounts\",\n  \"eth_sendRawTransaction\",\n  \"eth_sign\",\n  \"eth_signTransaction\",\n  \"eth_signTypedData\",\n  \"eth_signTypedData_v3\",\n  \"eth_signTypedData_v4\",\n  \"eth_sendTransaction\",\n  \"personal_sign\",\n  \"wallet_switchEthereumChain\",\n  \"wallet_addEthereumChain\",\n  \"wallet_getPermissions\",\n  \"wallet_requestPermissions\",\n  \"wallet_registerOnboarding\",\n  \"wallet_watchAsset\",\n  \"wallet_scanQRCode\",\n  \"wallet_sendCalls\",\n  \"wallet_getCapabilities\",\n  \"wallet_getCallsStatus\",\n  \"wallet_showCallsStatus\",\n];\nexport const REQUIRED_EVENTS = [\"chainChanged\", \"accountsChanged\"];\nexport const OPTIONAL_EVENTS = [\n  \"chainChanged\",\n  \"accountsChanged\",\n  \"message\",\n  \"disconnect\",\n  \"connect\",\n];\n","export const getAppkit = async () => {\n  const { createAppKit } = await import(\"@reown/appkit/core\");\n  return createAppKit;\n};\n","import { EventEmitter } from \"events\";\nimport { getAccountsFromNamespaces, getSdkError, isValidArray } from \"@walletconnect/utils\";\nimport { KeyValueStorageOptions } from \"@walletconnect/keyvaluestorage\";\nimport {\n  IEthereumProvider as IProvider,\n  IEthereumProviderEvents,\n  ProviderAccounts,\n  RequestArguments,\n  QrModalOptions,\n} from \"./types\";\nimport {\n  Metadata,\n  Namespace,\n  UniversalProvider,\n  UniversalProviderOpts,\n} from \"@walletconnect/universal-provider\";\nimport { AuthTypes, SessionTypes, SignClientTypes } from \"@walletconnect/types\";\nimport { JsonRpcResult } from \"@walletconnect/jsonrpc-types\";\nimport {\n  STORAGE_KEY,\n  REQUIRED_METHODS,\n  REQUIRED_EVENTS,\n  RPC_URL,\n  OPTIONAL_METHODS,\n  OPTIONAL_EVENTS,\n} from \"./constants\";\nimport { getAppkit } from \"./utils/appkit\";\n\nexport type RpcMethod =\n  | \"personal_sign\"\n  | \"eth_sendTransaction\"\n  | \"eth_accounts\"\n  | \"eth_requestAccounts\"\n  | \"eth_call\"\n  | \"eth_getBalance\"\n  | \"eth_sendRawTransaction\"\n  | \"eth_sign\"\n  | \"eth_signTransaction\"\n  | \"eth_signTypedData\"\n  | \"eth_signTypedData_v3\"\n  | \"eth_signTypedData_v4\"\n  | \"wallet_switchEthereumChain\"\n  | \"wallet_addEthereumChain\"\n  | \"wallet_getPermissions\"\n  | \"wallet_requestPermissions\"\n  | \"wallet_registerOnboarding\"\n  | \"wallet_watchAsset\"\n  | \"wallet_scanQRCode\"\n  | \"wallet_sendCalls\"\n  | \"wallet_getCapabilities\"\n  | \"wallet_getCallsStatus\"\n  | \"wallet_showCallsStatus\";\n\nexport type RpcEvent = \"accountsChanged\" | \"chainChanged\" | \"message\" | \"disconnect\" | \"connect\";\n\nexport interface EthereumRpcMap {\n  [chainId: string]: string;\n}\n\nexport interface SessionEvent {\n  event: { name: string; data: any };\n  chainId: string;\n}\n\nexport interface EthereumRpcConfig {\n  chains: string[];\n  optionalChains: string[];\n  methods: string[];\n  optionalMethods?: string[];\n  /**\n   * @description Events that the wallet MUST support or the connection will be rejected\n   */\n  events: string[];\n  optionalEvents?: string[];\n  rpcMap: EthereumRpcMap;\n  projectId: string;\n  metadata?: Metadata;\n  showQrModal: boolean;\n  qrModalOptions?: QrModalOptions;\n}\nexport interface ConnectOps {\n  chains?: number[];\n  optionalChains?: number[];\n  rpcMap?: EthereumRpcMap;\n  pairingTopic?: string;\n  scopedProperties?: unknown;\n}\n\nexport type AuthenticateParams = {\n  chains?: number[];\n} & Omit<AuthTypes.SessionAuthenticateParams, \"chains\">;\n\nexport interface IEthereumProvider extends IProvider {\n  connect(opts?: ConnectOps | undefined): Promise<void>;\n}\n\nexport function getRpcUrl(chainId: string, rpc: EthereumRpcConfig): string | undefined {\n  let rpcUrl: string | undefined;\n  if (rpc.rpcMap) {\n    rpcUrl = rpc.rpcMap[getEthereumChainId([chainId])];\n  }\n  return rpcUrl;\n}\n\nexport function getEthereumChainId(chains: string[]): number {\n  return Number(chains[0].split(\":\")[1]);\n}\n\nexport function toHexChainId(chainId: number): string {\n  return `0x${chainId.toString(16)}`;\n}\n\nexport type NamespacesParams = {\n  chains: EthereumRpcConfig[\"chains\"];\n  optionalChains: EthereumRpcConfig[\"optionalChains\"];\n  methods?: EthereumRpcConfig[\"methods\"];\n  optionalMethods?: EthereumRpcConfig[\"methods\"];\n  events?: EthereumRpcConfig[\"events\"];\n  rpcMap: EthereumRpcConfig[\"rpcMap\"];\n  optionalEvents?: EthereumRpcConfig[\"events\"];\n};\n\nexport function buildNamespaces(params: NamespacesParams): {\n  required?: Namespace;\n  optional?: Namespace;\n} {\n  const { chains, optionalChains, methods, optionalMethods, events, optionalEvents, rpcMap } =\n    params;\n  if (!isValidArray(chains)) {\n    throw new Error(\"Invalid chains\");\n  }\n\n  const required: Namespace = {\n    chains,\n    methods: methods || REQUIRED_METHODS,\n    events: events || REQUIRED_EVENTS,\n    rpcMap: {\n      ...(chains.length\n        ? { [getEthereumChainId(chains)]: rpcMap[getEthereumChainId(chains)] }\n        : {}),\n    },\n  };\n\n  // make a list of events and methods that require additional permissions\n  // so we know if we should to include the required chains in the optional namespace\n  const eventsRequiringPermissions = events?.filter((event) => !REQUIRED_EVENTS.includes(event));\n  const methodsRequiringPermissions = methods?.filter((event) => !REQUIRED_METHODS.includes(event));\n\n  if (\n    !optionalChains &&\n    !optionalEvents &&\n    !optionalMethods &&\n    !eventsRequiringPermissions?.length &&\n    !methodsRequiringPermissions?.length\n  ) {\n    return { required: chains.length ? required : undefined };\n  }\n\n  /*\n   * decides whether or not to include the required chains in the optional namespace\n   * use case: if there is a single chain as required but additional methods/events as optional\n   */\n  const shouldIncludeRequiredChains =\n    (eventsRequiringPermissions?.length && methodsRequiringPermissions?.length) || !optionalChains;\n\n  const optional: Namespace = {\n    chains: [\n      ...new Set(\n        shouldIncludeRequiredChains ? required.chains.concat(optionalChains || []) : optionalChains,\n      ),\n    ],\n    methods: [\n      ...new Set(\n        required.methods.concat(optionalMethods?.length ? optionalMethods : OPTIONAL_METHODS),\n      ),\n    ],\n    events: [\n      ...new Set(required.events.concat(optionalEvents?.length ? optionalEvents : OPTIONAL_EVENTS)),\n    ],\n    rpcMap,\n  };\n\n  return {\n    required: chains.length ? required : undefined,\n    optional: optionalChains.length ? optional : undefined,\n  };\n}\n\n// helper type to force setting at least one value in an array\ntype ArrayOneOrMore<T> = {\n  0: T;\n} & Array<T>;\n\n/**\n * @param {number[]} chains - The Chains your app intents to use and the peer MUST support. If the peer does not support these chains, the connection will be rejected.\n * @param {number[]} optionalChains - The Chains your app MAY attempt to use and the peer MAY support. If the peer does not support these chains, the connection will still be established.\n * @description either chains or optionalChains must be provided\n */\nexport type ChainsProps =\n  | {\n      chains: ArrayOneOrMore<number>;\n      optionalChains?: number[];\n    }\n  | {\n      chains?: number[];\n      optionalChains: ArrayOneOrMore<number>;\n    };\n\nexport type EthereumProviderOptions = {\n  projectId: string;\n  /**\n   * @note Methods that your app intents to use and the peer MUST support. If the peer does not support these methods, the connection will be rejected.\n   * @default [\"eth_sendTransaction\", \"personal_sign\"]\n   */\n  methods?: string[];\n  /**\n   * @note Methods that your app MAY attempt to use and the peer MAY support. If the peer does not support these methods, the connection will still be established.\n   */\n  optionalMethods?: string[];\n  events?: string[];\n  optionalEvents?: string[];\n  rpcMap?: EthereumRpcMap;\n  metadata?: Metadata;\n  showQrModal: boolean;\n  qrModalOptions?: QrModalOptions;\n  disableProviderPing?: boolean;\n  relayUrl?: string;\n  storageOptions?: KeyValueStorageOptions;\n} & ChainsProps &\n  UniversalProviderOpts;\n\nexport class EthereumProvider implements IEthereumProvider {\n  public events = new EventEmitter();\n  public namespace = \"eip155\";\n  public accounts: string[] = [];\n  public signer: InstanceType<typeof UniversalProvider>;\n  public chainId = 1;\n  public modal?: any;\n\n  protected rpc: EthereumRpcConfig;\n  protected readonly STORAGE_KEY = STORAGE_KEY;\n\n  constructor() {\n    // assigned during initialize\n    this.signer = {} as InstanceType<typeof UniversalProvider>;\n    this.rpc = {} as EthereumRpcConfig;\n  }\n\n  static async init(opts: EthereumProviderOptions): Promise<EthereumProvider> {\n    const provider = new EthereumProvider();\n    await provider.initialize(opts);\n    return provider;\n  }\n\n  public async request<T = unknown>(args: RequestArguments, expiry?: number): Promise<T> {\n    return await this.signer.request(args, this.formatChainId(this.chainId), expiry);\n  }\n\n  public sendAsync(\n    args: RequestArguments,\n    callback: (error: Error | null, response: JsonRpcResult) => void,\n    expiry?: number,\n  ): void {\n    this.signer.sendAsync(args, callback, this.formatChainId(this.chainId), expiry);\n  }\n\n  get connected(): boolean {\n    if (!this.signer.client) return false;\n    return this.signer.client.core.relayer.connected;\n  }\n\n  get connecting(): boolean {\n    if (!this.signer.client) return false;\n    return this.signer.client.core.relayer.connecting;\n  }\n\n  public async enable(): Promise<ProviderAccounts> {\n    if (!this.session) await this.connect();\n    const accounts = await this.request({ method: \"eth_requestAccounts\" });\n    return accounts as ProviderAccounts;\n  }\n\n  public async connect(opts?: ConnectOps): Promise<void> {\n    if (!this.signer.client) {\n      throw new Error(\"Provider not initialized. Call init() first\");\n    }\n\n    this.loadConnectOpts(opts);\n    const { required, optional } = buildNamespaces(this.rpc);\n    try {\n      const session = await new Promise<SessionTypes.Struct | undefined>(\n        async (resolve, reject) => {\n          if (this.rpc.showQrModal) {\n            this.modal?.open();\n\n            this.modal?.subscribeState((state: { open: boolean }) => {\n              // the modal was closed so reject the promise\n              if (!state.open && !this.signer.session) {\n                this.signer.abortPairingAttempt();\n                reject(new Error(\"Connection request reset. Please try again.\"));\n              }\n            });\n          }\n          const scopedProperties = opts?.scopedProperties\n            ? { [this.namespace]: opts.scopedProperties }\n            : undefined;\n\n          await this.signer\n            .connect({\n              namespaces: {\n                ...(required && {\n                  [this.namespace]: required,\n                }),\n              },\n              ...(optional && {\n                optionalNamespaces: {\n                  [this.namespace]: optional,\n                },\n              }),\n              pairingTopic: opts?.pairingTopic,\n              scopedProperties,\n            })\n            .then((session?: SessionTypes.Struct) => {\n              resolve(session);\n            })\n            .catch((error: Error) => {\n              this.modal?.showErrorMessage(\"Unable to connect\");\n              reject(new Error(error.message));\n            });\n        },\n      );\n\n      if (!session) return;\n\n      const accounts = getAccountsFromNamespaces(session.namespaces, [this.namespace]);\n      // if no required chains are set, use the approved accounts to fetch chainIds\n      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : accounts);\n      this.setAccounts(accounts);\n      this.events.emit(\"connect\", { chainId: toHexChainId(this.chainId) });\n    } catch (error) {\n      this.signer.logger.error(error);\n      throw error;\n    } finally {\n      this.modal?.close();\n    }\n  }\n\n  public async authenticate(\n    params: AuthenticateParams,\n    walletUniversalLink?: string,\n  ): Promise<AuthTypes.AuthenticateResponseResult | undefined> {\n    if (!this.signer.client) {\n      throw new Error(\"Provider not initialized. Call init() first\");\n    }\n\n    this.loadConnectOpts({\n      chains: params?.chains,\n    });\n\n    try {\n      const result = await new Promise<AuthTypes.AuthenticateResponseResult>(\n        async (resolve, reject) => {\n          if (this.rpc.showQrModal) {\n            this.modal?.open();\n            this.modal?.subscribeState((state: { open: boolean }) => {\n              // the modal was closed so reject the promise\n              if (!state.open && !this.signer.session) {\n                this.signer.abortPairingAttempt();\n                reject(new Error(\"Connection request reset. Please try again.\"));\n              }\n            });\n          }\n          await this.signer\n            .authenticate(\n              {\n                ...params,\n                chains: this.rpc.chains,\n              },\n              walletUniversalLink,\n            )\n            .then((result: AuthTypes.AuthenticateResponseResult) => {\n              resolve(result);\n            })\n            .catch((error: Error) => {\n              this.modal?.showErrorMessage(\"Unable to connect\");\n              reject(new Error(error.message));\n            });\n        },\n      );\n\n      const session = result.session;\n      if (session) {\n        const accounts = getAccountsFromNamespaces(session.namespaces, [this.namespace]);\n        // if no required chains are set, use the approved accounts to fetch chainIds as both contain <namespace>:<chainId>\n        this.setChainIds(this.rpc.chains.length ? this.rpc.chains : accounts);\n        this.setAccounts(accounts);\n\n        this.events.emit(\"connect\", { chainId: toHexChainId(this.chainId) });\n      }\n\n      return result;\n    } catch (error) {\n      this.signer.logger.error(error);\n      throw error;\n    } finally {\n      this.modal?.close();\n    }\n  }\n\n  public async disconnect(): Promise<void> {\n    if (this.session) {\n      await this.signer.disconnect();\n    }\n    this.reset();\n  }\n\n  public on: IEthereumProviderEvents[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n    return this;\n  };\n\n  public once: IEthereumProviderEvents[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n    return this;\n  };\n\n  public removeListener: IEthereumProviderEvents[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n    return this;\n  };\n\n  public off: IEthereumProviderEvents[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n    return this;\n  };\n\n  get isWalletConnect() {\n    return true;\n  }\n\n  get session() {\n    return this.signer.session;\n  }\n\n  // ---------- Protected --------------------------------------------- //\n\n  protected registerEventListeners() {\n    this.signer.on(\"session_event\", (payload: SignClientTypes.EventArguments[\"session_event\"]) => {\n      const { params } = payload;\n      const { event } = params;\n      if (event.name === \"accountsChanged\") {\n        this.accounts = this.parseAccounts(event.data);\n        this.events.emit(\"accountsChanged\", this.accounts);\n      } else if (event.name === \"chainChanged\") {\n        this.setChainId(this.formatChainId(event.data));\n      } else {\n        this.events.emit(event.name as any, event.data);\n      }\n      this.events.emit(\"session_event\", payload);\n    });\n\n    this.signer.on(\"accountsChanged\", (accounts: string[]) => {\n      this.accounts = this.parseAccounts(accounts);\n      this.events.emit(\"accountsChanged\", this.accounts);\n    });\n\n    this.signer.on(\"chainChanged\", (chainId: string) => {\n      const chain = parseInt(chainId);\n      this.chainId = chain;\n      this.events.emit(\"chainChanged\", toHexChainId(this.chainId));\n      this.persist();\n    });\n\n    this.signer.on(\n      \"session_update\",\n      (payload: SignClientTypes.EventArguments[\"session_update\"]) => {\n        this.events.emit(\"session_update\", payload);\n      },\n    );\n\n    this.signer.on(\n      \"session_delete\",\n      (payload: SignClientTypes.EventArguments[\"session_delete\"]) => {\n        this.reset();\n        this.events.emit(\"session_delete\", payload);\n        this.events.emit(\"disconnect\", {\n          ...getSdkError(\"USER_DISCONNECTED\"),\n          data: payload.topic,\n          name: \"USER_DISCONNECTED\",\n        });\n      },\n    );\n\n    this.signer.on(\"display_uri\", (uri: string) => {\n      this.events.emit(\"display_uri\", uri);\n    });\n  }\n\n  protected switchEthereumChain(chainId: number): void {\n    this.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: chainId.toString(16) }],\n    });\n  }\n\n  protected isCompatibleChainId(chainId: string): boolean {\n    return typeof chainId === \"string\" ? chainId.startsWith(`${this.namespace}:`) : false;\n  }\n\n  protected formatChainId(chainId: number): string {\n    return `${this.namespace}:${chainId}`;\n  }\n\n  protected parseChainId(chainId: string): number {\n    return Number(chainId.split(\":\")[1]);\n  }\n\n  protected setChainIds(chains: string[]) {\n    const compatible = chains.filter((x) => this.isCompatibleChainId(x));\n    const chainIds = compatible.map((c) => this.parseChainId(c));\n    if (chainIds.length) {\n      this.chainId = chainIds[0];\n      this.events.emit(\"chainChanged\", toHexChainId(this.chainId));\n      this.persist();\n    }\n  }\n\n  protected setChainId(chain: string) {\n    if (this.isCompatibleChainId(chain)) {\n      const chainId = this.parseChainId(chain);\n      this.chainId = chainId;\n      this.switchEthereumChain(chainId);\n    }\n  }\n\n  protected parseAccountId(account: string): { chainId: string; address: string } {\n    const [namespace, reference, address] = account.split(\":\");\n    const chainId = `${namespace}:${reference}`;\n    return { chainId, address };\n  }\n\n  protected setAccounts(accounts: string[]) {\n    this.accounts = accounts\n      .filter((x) => this.parseChainId(this.parseAccountId(x).chainId) === this.chainId)\n      .map((x) => this.parseAccountId(x).address);\n    this.events.emit(\"accountsChanged\", this.accounts);\n  }\n\n  protected getRpcConfig(opts: EthereumProviderOptions): EthereumRpcConfig {\n    const requiredChains = opts?.chains ?? [];\n    const optionalChains = opts?.optionalChains ?? [];\n    const allChains = requiredChains.concat(optionalChains);\n    if (!allChains.length)\n      throw new Error(\"No chains specified in either `chains` or `optionalChains`\");\n    const requiredMethods = requiredChains.length ? opts?.methods || REQUIRED_METHODS : [];\n    const requiredEvents = requiredChains.length ? opts?.events || REQUIRED_EVENTS : [];\n    const optionalMethods = opts?.optionalMethods || [];\n    const optionalEvents = opts?.optionalEvents || [];\n    const rpcMap = opts?.rpcMap || this.buildRpcMap(allChains, opts.projectId);\n    const qrModalOptions = opts?.qrModalOptions || undefined;\n    return {\n      chains: requiredChains?.map((chain: number) => this.formatChainId(chain)),\n      optionalChains: optionalChains.map((chain: number) => this.formatChainId(chain)),\n      methods: requiredMethods,\n      events: requiredEvents,\n      optionalMethods,\n      optionalEvents,\n      rpcMap,\n      showQrModal: Boolean(opts?.showQrModal),\n      qrModalOptions,\n      projectId: opts.projectId,\n      metadata: opts.metadata,\n    };\n  }\n\n  protected buildRpcMap(chains: number[], projectId: string): EthereumRpcMap {\n    const map: EthereumRpcMap = {};\n    chains.forEach((chain) => {\n      map[chain] = this.getRpcUrl(chain, projectId);\n    });\n    return map;\n  }\n\n  protected async initialize(opts: EthereumProviderOptions) {\n    this.rpc = this.getRpcConfig(opts);\n\n    this.chainId = this.rpc.chains.length\n      ? getEthereumChainId(this.rpc.chains)\n      : getEthereumChainId(this.rpc.optionalChains);\n    this.signer = await UniversalProvider.init({\n      projectId: this.rpc.projectId,\n      metadata: this.rpc.metadata,\n      disableProviderPing: opts.disableProviderPing,\n      relayUrl: opts.relayUrl,\n      storage: opts.storage,\n      storageOptions: opts.storageOptions,\n      customStoragePrefix: opts.customStoragePrefix,\n      telemetryEnabled: opts.telemetryEnabled,\n      logger: opts.logger,\n    });\n    this.registerEventListeners();\n    await this.loadPersistedSession();\n    if (this.rpc.showQrModal) {\n      let appKit;\n      try {\n        const createAppKit = await getAppkit();\n        const { convertWCMToAppKitOptions } = await import(\"./wcmToAppKit\");\n        const options = convertWCMToAppKitOptions({\n          ...this.rpc.qrModalOptions,\n          chains: [...new Set([...this.rpc.chains, ...this.rpc.optionalChains])],\n          metadata: this.rpc.metadata,\n          projectId: this.rpc.projectId,\n        });\n\n        if (!options.networks.length) {\n          throw new Error(\"No networks found for WalletConnect·\");\n        }\n\n        appKit = createAppKit({\n          ...options,\n          universalProvider: this.signer as any,\n          manualWCControl: true,\n        });\n      } catch (e) {\n        console.warn(e);\n        throw new Error(\"To use QR modal, please install @reown/appkit package\");\n      }\n      if (appKit) {\n        try {\n          this.modal = appKit;\n        } catch (e) {\n          this.signer.logger.error(e);\n          throw new Error(\"Could not generate WalletConnectModal Instance\");\n        }\n      }\n    }\n  }\n\n  protected loadConnectOpts(opts?: ConnectOps) {\n    if (!opts) return;\n    const { chains, optionalChains, rpcMap } = opts;\n    if (chains && isValidArray(chains)) {\n      this.rpc.chains = chains.map((chain) => this.formatChainId(chain));\n      chains.forEach((chain) => {\n        this.rpc.rpcMap[chain] = rpcMap?.[chain] || this.getRpcUrl(chain);\n      });\n    }\n    if (optionalChains && isValidArray(optionalChains)) {\n      this.rpc.optionalChains = [];\n      this.rpc.optionalChains = optionalChains?.map((chain) => this.formatChainId(chain));\n      optionalChains.forEach((chain) => {\n        this.rpc.rpcMap[chain] = rpcMap?.[chain] || this.getRpcUrl(chain);\n      });\n    }\n  }\n\n  protected getRpcUrl(chainId: number, projectId?: string): string {\n    const providedRpc = this.rpc.rpcMap?.[chainId];\n    return (\n      providedRpc ||\n      `${RPC_URL}?chainId=eip155:${chainId}&projectId=${projectId || this.rpc.projectId}`\n    );\n  }\n\n  protected async loadPersistedSession() {\n    if (!this.session) return;\n    try {\n      const chainId = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`);\n\n      // cater to both inline & nested namespace formats\n      const namespace = this.session.namespaces[`${this.namespace}:${chainId}`]\n        ? this.session.namespaces[`${this.namespace}:${chainId}`]\n        : this.session.namespaces[this.namespace];\n\n      this.setChainIds(chainId ? [this.formatChainId(chainId)] : namespace?.accounts);\n      this.setAccounts(namespace?.accounts);\n    } catch (error) {\n      this.signer.logger.error(\"Failed to load persisted session, clearing state...\");\n      this.signer.logger.error(error);\n      await this.disconnect().catch((error) => this.signer.logger.warn(error));\n    }\n  }\n\n  protected reset() {\n    this.chainId = 1;\n    this.accounts = [];\n  }\n\n  protected persist() {\n    if (!this.session) return;\n    this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);\n  }\n\n  protected parseAccounts(payload: string | string[]): string[] {\n    if (typeof payload === \"string\" || payload instanceof String) {\n      return [this.parseAccount(payload)];\n    }\n    return payload.map((account: string) => this.parseAccount(account));\n  }\n\n  protected parseAccount = (payload: any): string => {\n    return this.isCompatibleChainId(payload) ? this.parseAccountId(payload).address : payload;\n  };\n}\n\nexport default EthereumProvider;\n","import { EthereumProvider as Provider } from \"./EthereumProvider\";\nexport const EthereumProvider = Provider;\nexport type { EthereumProviderOptions, RpcEvent, RpcMethod } from \"./EthereumProvider\";\nexport * from \"./constants/rpc\";\nexport default Provider;\n","import type { AppKitOptions, CaipNetwork, CaipNetworkId } from \"@reown/appkit\";\nimport type { WalletConnectModalConfig } from \"./types\";\nimport type { AppKitNetwork } from \"@reown/appkit/networks\";\nimport type { EthereumProviderOptions } from \"./EthereumProvider\";\nimport type { Assign, ChainFormatters, Prettify } from \"viem\";\n\nfunction convertThemeVariables(\n  wcmTheme?: WalletConnectModalConfig[\"themeVariables\"],\n): AppKitOptions[\"themeVariables\"] | undefined {\n  if (!wcmTheme) return undefined;\n\n  return {\n    \"--w3m-font-family\": wcmTheme[\"--wcm-font-family\"],\n    \"--w3m-accent\": wcmTheme[\"--wcm-accent-color\"],\n    \"--w3m-color-mix\": wcmTheme[\"--wcm-background-color\"],\n    \"--w3m-z-index\": wcmTheme[\"--wcm-z-index\"] ? Number(wcmTheme[\"--wcm-z-index\"]) : undefined,\n\n    \"--w3m-qr-color\": wcmTheme[\"--wcm-accent-color\"],\n\n    \"--w3m-font-size-master\": wcmTheme[\"--wcm-text-medium-regular-size\"],\n    \"--w3m-border-radius-master\": wcmTheme[\"--wcm-container-border-radius\"],\n    \"--w3m-color-mix-strength\": 0,\n  };\n}\n\nconst mapCaipIdToAppKitCaipNetwork = (caipId: CaipNetworkId): CaipNetwork => {\n  const [namespace, chainId] = caipId.split(\":\");\n  const chain = defineChain({\n    id: chainId,\n    caipNetworkId: caipId,\n    chainNamespace: namespace as CaipNetwork[\"chainNamespace\"],\n    name: \"\",\n    nativeCurrency: {\n      name: \"\",\n      symbol: \"\",\n      decimals: 8,\n    },\n    rpcUrls: {\n      default: { http: [\"https://rpc.walletconnect.org/v1\"] },\n    },\n  });\n\n  return chain as CaipNetwork;\n};\n\nexport function convertWCMToAppKitOptions(\n  wcmConfig: WalletConnectModalConfig & { metadata?: EthereumProviderOptions[\"metadata\"] },\n): AppKitOptions {\n  // Convert chains toCaipNetwork format\n  const networks: CaipNetwork[] = (wcmConfig.chains as CaipNetworkId[])\n    ?.map(mapCaipIdToAppKitCaipNetwork)\n    .filter(Boolean);\n\n  // Ensure at least one network is present\n  if (networks.length === 0) {\n    throw new Error(\"At least one chain must be specified\");\n  }\n\n  const defaultNetwork = networks.find((network) => network.id === wcmConfig.defaultChain?.id);\n  const appKitOptions: AppKitOptions = {\n    projectId: wcmConfig.projectId,\n    networks: networks as [AppKitNetwork, ...AppKitNetwork[]],\n    themeMode: wcmConfig.themeMode,\n    themeVariables: convertThemeVariables(wcmConfig.themeVariables),\n    chainImages: wcmConfig.chainImages,\n    connectorImages: wcmConfig.walletImages,\n    defaultNetwork,\n    metadata: {\n      ...wcmConfig.metadata,\n      name: wcmConfig.metadata?.name || \"WalletConnect\",\n      description: wcmConfig.metadata?.description || \"Connect to WalletConnect-compatible wallets\",\n      url: wcmConfig.metadata?.url || \"https://walletconnect.org\",\n      icons: wcmConfig.metadata?.icons || [\"https://walletconnect.org/walletconnect-logo.png\"],\n    },\n    showWallets: true,\n    // Explorer options mapping\n    featuredWalletIds:\n      wcmConfig.explorerRecommendedWalletIds === \"NONE\"\n        ? []\n        : Array.isArray(wcmConfig.explorerRecommendedWalletIds)\n          ? wcmConfig.explorerRecommendedWalletIds\n          : [],\n\n    excludeWalletIds:\n      wcmConfig.explorerExcludedWalletIds === \"ALL\"\n        ? []\n        : Array.isArray(wcmConfig.explorerExcludedWalletIds)\n          ? wcmConfig.explorerExcludedWalletIds\n          : [],\n\n    // Additional AppKit-specific options that don't have direct WCM equivalents\n    enableEIP6963: false, // Disable 6963 by default\n    enableInjected: false, // Disable injected by default\n    enableCoinbase: true, // Default to true\n    enableWalletConnect: true, // Default to true,\n    features: {\n      email: false,\n      socials: false,\n    },\n  };\n\n  // Add mobile and desktop wallets as custom wallets if provided\n  if (wcmConfig.mobileWallets?.length || wcmConfig.desktopWallets?.length) {\n    const customWallets = [\n      ...(wcmConfig.mobileWallets || []).map((wallet) => ({\n        id: wallet.id,\n        name: wallet.name,\n        links: wallet.links,\n      })),\n      ...(wcmConfig.desktopWallets || []).map((wallet) => ({\n        id: wallet.id,\n        name: wallet.name,\n        links: {\n          native: wallet.links.native,\n          universal: wallet.links.universal,\n        },\n      })),\n    ];\n\n    const allWallets = [\n      ...(appKitOptions.featuredWalletIds || []),\n      ...(appKitOptions.excludeWalletIds || []),\n    ];\n\n    // Only add a custom wallet if it's not on the other lists\n    const uniqueCustomWallets = customWallets.filter((wallet) => !allWallets.includes(wallet.id));\n\n    if (uniqueCustomWallets.length) {\n      appKitOptions.customWallets = uniqueCustomWallets;\n    }\n  }\n\n  return appKitOptions;\n}\n\nexport function defineChain<\n  formatters extends ChainFormatters,\n  const chain extends CaipNetwork<formatters>,\n>(chain: chain): Prettify<Assign<CaipNetwork<undefined>, chain>> {\n  return {\n    formatters: undefined,\n    fees: undefined,\n    serializers: undefined,\n    ...chain,\n  } as Assign<CaipNetwork<undefined>, chain>;\n}\n"],"names":["createAppKit","chains","chainId","params","optionalChains","methods","optionalMethods","events","optionalEvents","rpcMap","isValidArray","required","REQUIRED_METHODS","REQUIRED_EVENTS","__spreadValues","eventsRequiringPermissions","event","methodsRequiringPermissions","shouldIncludeRequiredChains","optional","OPTIONAL_METHODS","OPTIONAL_EVENTS","EthereumProvider","__publicField","EventEmitter","STORAGE_KEY","listener","payload","opts","provider","args","expiry","callback","_a","session","resolve","reject","_b","state","scopedProperties","__spreadProps","error","accounts","getAccountsFromNamespaces","walletUniversalLink","result","chain","getSdkError","uri","chainIds","x","c","account","namespace","reference","address","requiredChains","allChains","requiredMethods","requiredEvents","qrModalOptions","projectId","map","UniversalProvider","appKit","getAppkit","convertWCMToAppKitOptions","options","e","RPC_URL","Provider","convertThemeVariables","wcmTheme","mapCaipIdToAppKitCaipNetwork","caipId","wcmConfig","_c","_d","_e","_f","_g","networks","defaultNetwork","network","appKitOptions","customWallets","wallet","allWallets","uniqueCustomWallets"],"mappings":"","debugId":null}}]
}